/* $OpenXM: OpenXM/src/asir-contrib/packages/src/ot_hgm_ahg.rr,v 1.41 2015/09/25 01:10:33 takayama Exp $

  Applying the HGM for A-hypergeometric system by a sylvester matrix like method.
  Imported from h-mle/A-hg/Prog/disc5.rr, cbase.rr
  ot_ = oh_ & tk_
*/
extern ForPaper$
ForPaper=0$  // To prepare data for our paper.
extern ForPaper_data1$
extern ForPaper_data2$
extern ForPaper_data3$
extern Strategy_N$  
Strategy_N=1$  // Do not compute the matrix product in hgm_ahg_contiguity. More efficient in our benchmark.  See h-mle/A-hg2/Prog/note-ot.tex
extern Start_pm$   // flag if polymake is already running.
extern Sing_poly_pf$

import("names.rr")$
import("nk_toric.rr")$
import("tk_sm1emu.rr")$
import("tk_cc111.rr")$
import("oh_base.rr")$
import("oh_number.rr")$
import("tk_hgpoly.rr")$
import("yang.rr")$
import("tk_polymake.rr")$

#include <defs.h>
#define _getopt(X,Y) (type(getopt(X))<0? (Y): getopt(X))

extern Disc_Supp2$
extern Disc_Toric$
extern Disc_R$
extern Disc_R1$
extern Disc_R2$

extern Verbose$
extern Counting$

def verbose(F) {
    T = Verbose;
    Verbose = (F!=0);
    return T;
}

def counting(F) {
    T = Counting;
    Counting = (F!=0);
    return T;
}

def alert(L) {
    if (Verbose) {
        if (isstr(L)) {
            printf("%a",L);
        }else if (islist(L)) {
            call(printf,L);
        }
    }
}

/* T0 は time() 関数の返り値で計測の開始時点を表す */
def print_time(Func,T0) {
    T1=time();
    S0="%a: time=%a, gc=%a, mem=%a, elapsed=%a\n";
    S1="%a: opt=%a: time=%a, gc=%a, mem=%a, elapsed=%a\n";
    if(Counting) {
        DT=vtol(ltov(T1)-ltov(T0));
        Opt=getopt(opt);
        if(type(Opt)<0) {
            S=cons(S0,cons(Func,DT));
        }else {
            S=cons(S1,cons(Func,cons(Opt,DT)));
        }
        call(printf,S);
    }
}
    
def cbase(A) {
  Time0=time();
  W=[[dx1, 1]]; /* dummy */
  T0=mytoric(A,W);
  E=T0[0];
  T=T0[1];
  V=T0[2]; Vb=T0[3]; Vd=add_d(V); 
  Gt=nd_gr(T,Vd,0,0);
  dp_ord(0); /* rev lex */
  T2=map(dp_ptod,Gt,Vd); T2=map(dp_ht,T2); T2=map(dp_dtop,T2,Vd);

  Er=base_replace(E,genrule_p(Vb)); /* prob method */
  alert(["We use a probabilistic algorithm to determine the base: %a\n",T2]);  /*Er=E;*/
  OrdM=poly_r_omatrix(length(V));
  Vall=append(V,Vd);
  G=nd_weyl_gr(append(Er,T2),Vall,0,OrdM);
  G1=G;
  for (I=0; I<length(V); I++) {
    G1=map(poly_in_w,G1,Vall,OrdM[I]);
  }  
  dp_ord(0);
  Gin = map(dp_ht,map(dp_ptod,G1,Vd)); Gin_p=map(dp_dtop,Gin,Vd);
  Std = dp_mbase(Gin); Std=map(dp_dtop,Std,Vd);
  print_time("cbase",Time0);
  return Std;
}

def ctest1() {
 A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
  B=cbase(A);
  return B;
}

def genrule_1(V) {
  R=[];
  for (I=0; I<length(V); I++) {  
    R = cons([V[I],1],R);
  }
  return reverse(R);
}
def genrule_p(V) {
  R=[]; P1=2;
  for (I=0; I<length(V); I++) { 
    P1 = pari(nextprime,P1+1); 
    P2 = pari(nextprime,P1+1);
    R = cons([V[I],P1/P2],R);
    P1 = P2;
  }
  return reverse(R);
}
/*
genrule_1([x,y,z]);
genrule_p([b1,b2,b3]);
ctest1();
*/

def ctest2() {
  A=[[1,1,1,1,1],[0,1,2,3,4]];
  Std=cbase(A);
  printf("Std=%a\n",Std);
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1]]; 
  Mset=append(Std,[dx2]);
  return get_mat(A,W,Std,Mset);
}
/*
R=ctest2();
matrix_rank(R);  We get a full rank matrix.
*/

def ctest3() {
  A=[[1,1,1,1],[0,1,3,4]];
  Std=cbase(A);
  printf("Std=%a\n",Std);
  W=[[dx1,1,dx2,1,dx3,1,dx4,1]]; 
  Mset=append(Std,[dx2,dx1,dx1*dx2,dx1*dx3,dx1*dx4,dx2*dx3,dx2*dx4,dx3*dx4,
                   dx1^2,dx2^2,dx3^2]);  /* 30x23, rank 23 の行列. 解ける. std が dx4^2 まであるので 2 次を全部とってきた. */
  return get_mat(A,W,Std,Mset);
}

/* 
R=ctest3();
matrix_rank(R);
*/

def ctest4() {
  A=[[1,1,1],[0,1,2]];
  Std=cbase(A);
  printf("Std=%a\n",Std);
  W=[[dx1,1,dx2,1,dx3,1]]; 
  Mset=append(Std,[1,dx1,dx2,dx3]);
  return get_mat(A,W,Std,Mset);
}

def ctest5() {
 A = [[1,0,0,1,1,0,1],
      [0,1,0,1,0,1,1],
      [0,0,1,0,1,1,1]];
 /* confluent type of ctest1() */
  B=cbase(A);
  return B;
}

/*
  mytoric(A,W)
  [euler,toric,V,Vb,weight_vec,toric_init_by_weight_vec] 
*/

def mytoric(A,W) {
  En=length(A);
  Gkz=tk_sm1emu.gkz([A,vtol(newvect(En))]);
  V=Gkz[1];
  T=Gkz[0];
  E=[]; Vb=[];
  for (I=0; I<En; I++) { E=cons(car(T)-util_v(b,[I+1]),E); T=cdr(T); Vb=cons(util_v(b,[I+1]),Vb);}
  E=reverse(E);  Vb=reverse(Vb);
  T=tk_sm1emu.gb([T,V,W]);
  return [E,T[0],V,Vb,W,T[1]];
  /* [euler,toric,V,Vb,weight_vec,toric_init_by_weight_vec] */
}

def test1() {
  A=[[1,1,1,1],[0,1,2,3]];
  W=[[dx1,1],[dx2,1],[dx3,1],[dx4,1]];
  /* W=[[dx1,100,dx2,30,dx3,3]]; */
  F=mytoric(A,W);
  print(F[1]);
  print(map(get_support,F[1],[dx1,dx2,dx3,dx4]));
  return F;
}

def get_support(F,V) {
  if (type(F) >= 4) {
     T=map(get_support,F,V);
     return merge(T);
  }
  if (dn(F) != 1) error("get_support: argument cannot be a rational.");
  F=dp_ptod(F,V);
  S=[];
  while (F != 0) {
    M=dp_ht(F); F=dp_rest(F);
    M=dp_dtop(M,V);
    if (!base_memberq(M,S)) S=cons(M,S);
  }
  return(S);
}

/* coef of M in F */
def mcoef(F,M,V) {
  for (I=0; I<length(V); I++) {
    F=coef(F,deg(M,V[I]),V[I]);
  }
  return F;
}

def test2() {
  F=(dx1+dx2+dx3+a)^4;
  V=[dx1,dx2,dx3];
  print(get_support(F,V));
  return mcoef(F,dx1*dx2^2,[dx1,dx2]);
}

def add_d(V) {
  Dv = newvect(length(V));
  for (I=0; I<length(V); I++) {
    Dv[I] = eval_str("d"+rtostr(V[I]));
  }
  return vtol(Dv);
}

def merge(Varray) {
  A=[];
  for (I=0; I<length(Varray); I++) {
    V=Varray[I];
    for (J=0; J<length(V); J++) {
      if (!base_memberq(V[J],A)) A=cons(V[J],A);
    }
  }
  return reverse(A);
}

/*
 P=get_mat2(A,W,Std,Mset); の時
 Mat=P[0]; RM=P[1]; Supp2=P[2]; とおくと,
 Mat*Supp2 = RM*Std
 が成り立つ.  cf. test3b();
*/
def get_mat2(A,W,Std,Mset) {
  T0=time();
  if (Mset == 0) Mset=Std;
  E=mytoric(A,W);
  /* [euler,toric,V,Vb,weight_vec,toric_init_by_weight_vec] */
  Disc_Toric=E;
  Euler=E[0];
  Toric=E[1];
  V=E[2]; Vb=E[3];  Vall=append(V,Vb);
  Vd = add_d(V);
  G=[];
  /* Mset を Euler 作用素に掛けて Toric で reduction する. 行列式の素 */ 
  for (I=0; I<length(Euler); I++) {
    for (J=0; J<length(Mset); J++) {
      F = tk_sm1emu.mul(Mset[J],Euler[I],Vall);
      Fn= tk_sm1emu.reduction([F,Toric,Vall,W]);
      Fn= Fn[0]/Fn[1];
      G = cons(Fn,G);
    }
  }
  G=reverse(G);
  R = newvect(length(G));
  for (I=0; I<length(G); I++) R[I]=G[I];
  /* G から行列を作る. 右辺は R. */
  Supp = get_support(G,Vd);
  alert(["Support=%a, Std=%a \n",Supp,Std]);
  Supp2 = base_set_minus(Supp,Std);
  /* Supp2 を 縦の index とする行列を作る */
  Disc_Supp2=Supp2; 
  Mat = newmat(length(G),length(Supp2));
  alert(["size=%a\n",size(Mat)]);
  for (I=0; I<length(G); I++) {
    for (J=0; J<length(Supp2); J++) {
       Mat[I][J] = mcoef(G[I],Supp2[J],Vd);
       R[I] = R[I] - Mat[I][J]*Supp2[J];
    }
  }
  for (I=0; I<length(G); I++) R[I]=-R[I];
  /* 右辺を RM*Std なる行列表示にする. 1 の係数も OK. */
  RM = newmat(length(G),length(Std));
  for (I=0; I<length(G); I++) {
    for (J=0; J<length(Std); J++) {
       RM[I][J] = mcoef(R[I],Std[J],Vd);
    }
  }
  /* Mat*Supp2-RM*Std=G=0? */
  /* mycheck(Mat,RM,Supp2,Std,G) ;*/
  print_time("get_mat2",T0);
  return [Mat,RM,Supp2,Toric];
}

def get_mat(A,W,Std,Mset) {
  return get_mat2(A,W,Std,Mset)[0];
}

def mycheck(Mat,RM,Supp2,Std,G) {
  B=Mat*newvect(length(Supp2),Supp2)-RM*newvect(length(Std),Std);
  N=length(B);
  for (I=0; I<N; I++) {
    if (B[I]-G[I]!=0) error("mycheck error");
  }
}

def test3() {
  A=[[1,1,1,1],[0,1,2,3]];
  W=[[dx1,1],[dx2,1],[dx3,1],[dx4,1]];
  /* return get_mat(A,W,[1,dx3,dx4],0);*/
  return get_mat(A,W,[1,dx3,dx4],[1,dx2,dx3,dx4]);
}

def test3b() {
  A=[[1,1,0,0],
     [0,0,1,1],
     [1,0,1,0],
     [0,1,0,1]];
  W=[[dx1,1],[dx2,1],[dx3,1],[dx4,1]];
  return get_mat2(A,W,[1,dx4],[1,dx4,dx3]);
}


def test4() {
 /* from ud-c11.rr */
 A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
  W=[[dx1,1],[dx2,1],[dx3,1],[dx4,1],[dx5,1],[dx6,1],[dx7,1],[dx8,1]];
  /* return get_mat(A,W,[1,dx5,dx6,dx7,dx8,dx8^2],0);  orange3m 24x31, rank is 24 */
  Mset=[1,dx5,dx6,dx7,dx8,dx8^2,dx1,dx2,dx3,dx4];  /* 40x38, but rank is 34 */
  Mset=[1,dx5,dx6,dx7,dx8,dx8^2];
  return get_mat(A,W,[1,dx5,dx6,dx7,dx8,dx8^2],Mset);
}

def test5() {
  /* This std is buggy. 2013-10-06 */
 /* from ud-c11.rr */
  A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; /* use rev lex */
  /* Mset=[1,dx5,dx6,dx7,dx8,dx6*dx7];   24x32 rank=24 */
  Mset=[1,dx5,dx6,dx7,dx8,dx6*dx7,dx1,dx2,dx3,dx4];  /* 40x39, rank=34 */
  return get_mat(A,W,[1,dx5,dx6,dx7,dx8,dx6*dx7],Mset);
}
/*
R=test5();
matrix_rank(R);
*/

def test6() {
 /* from ud-c11.rr */
  A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; /* use rev lex */
  Mset=[1,dx5,dx6,dx7,dx8, 
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8];
           /* 176*93, rank=93  */
  Disc_R=get_mat(A,W,[1,dx5,dx6,dx7,dx8,dx8^2],Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4,x5,x6,x7,x8];
  Vb=[b_1,b_2,b_3,b_4];
  /* load cbase.rr */
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return matrix_rank(base_replace(Disc_R,R1));
}
def test6c() {  /* confluent test6. cf. Notes/c11.tex */
 /* from ud-c11.rr */
  A = [
     [1,0,0,1,1,0,1],
     [0,1,0,1,0,1,1],
     [0,0,1,0,1,1,1]];
  printf("Std=%a\n",cbase(A));
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
  Mset=[1,dx5,dx6,dx7, 
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
                                           dx5*dx5,dx5*dx6,dx5*dx7,
                                                   dx6*dx6,dx6*dx7,
                                                           dx7*dx7];
  /* 108x58, rank=58 */
  Disc_R=get_mat(A,W,[1,dx7,dx6,dx5,dx4,dx7^2],Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4,x5,x6,x7];
  Vb=[b_1,b_2,b_3];
  /* load cbase.rr */
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return matrix_rank(base_replace(Disc_R,R1));
}

/* 乱数で選んだベクトルで non-sigular submatrix を探す.
--> これはうまくいかない. やはり一次独立なものを足していくのがいいんだろう. */
def ns_submat(Mat) {
  if (type(Mat) == 4) Mat = matrix_list_to_matrix(Mat);
  M=size(Mat)[0]; N=size(Mat)[1];
  /* Choose N rows from M rows, N<=M. The result should be non-singular mat. */
  Idx=newvect(N);
  while (1) {
    for (I=0; I<N; I++) Idx[I]=-1;
    J=0;
    while (J<N) {
      R=random() % M;
      if (!base_memberq(R,Idx)) {Idx[J]=R; J++;}
    }
    printf("Idx=%a\n",Idx);
    Smat = matrix_submatrix(Mat,Idx);
    if (matrix_rank(Smat) == N) break;
  }
  return [Smat,Idx];
}

def test7() {
  /* 00,01,10,11,12,21,22 */
  A=[
     [1,1,0,0,0,0,0],
     [0,0,1,1,1,0,0],
     [0,0,0,0,0,1,1],
     [1,0,1,0,0,0,0],
     [0,1,0,1,0,1,0]];
  Std=cbase(A);
  printf("Std=%a\n",Std); /* [], 4,7,47 rank=4. */
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
  Mset=[1,dx1,dx2,dx3,dx4,dx5,dx6,dx7];
  /* Mset=[1,dx4,dx7,dx1];   not good. */
  Disc_R=get_mat(A,W,[1,dx4,dx7,dx4*dx7],Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4,x5,x6,x7];
  Vb=[b_1,b_2,b_3,b_4,b_5];
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return [matrix_rank(base_replace(Disc_R,R1)),Std];
}

def test8() {
  A=[
     [1,1,0,0],
     [0,0,1,1],
     [1,0,1,0]];
  Std=cbase(A);
  printf("Std=%a\n",Std); /* [], 4 rank=2. */
  W=[[dx1,1,dx2,1,dx3,1,dx4,1]]; /* use rev lex */
  Mset=[1,dx4,dx2];  /* [1,dx4,dx3]; also works */
  Disc_R=get_mat(A,W,[1,dx4],Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4];
  Vb=[b_1,b_2,b_3];
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return [matrix_rank(base_replace(Disc_R,R1)),Std];
}

/* 2014-01-30, 18:07, see also photo */
def test9() {
  B=[
     [x10,x11,  0,    0,  0,   0],
     [    0,x11,x01,  0,  0,   0],
     [    0,    0,x01,x10,0,   0],
     [    0,    0,   0,x10,x00,0],
     [    0,    0,   0,   0,x00,x01],
     [x10,    0,    0,   0,   0,x00]]; /* by toric reduction, it is not x01 */
  return det(matrix_list_to_matrix(B));
}

def test10() {
  A=[
     [1,1,1,0,0,0],
     [0,0,0,1,1,1],
     [1,0,0,1,0,0],
     [0,1,0,0,1,0]
   ];
  Std=cbase(A);
  printf("Std=%a\n",Std); /* [], 5,6 rank=3. */
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1]]; /* use rev lex */
  Mset=[1,dx5,dx6,dx4];
  Disc_R=get_mat(A,W,Std,Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4,x5,x6];
  Vb=[b_1,b_2,b_3,b_4];
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return [matrix_rank(base_replace(Disc_R,R1)),Std];
}


/*
MatData = get_mat2(A,W,StdMon,Mset);
Eqn = get_eqn(MatData);
*/
def get_eqn(MatData) {
    T0=time();
    M0=MatData[0];
    M1=MatData[1];
    T=base_var_list(tt_,1,size(M0)[1]);
    S=base_var_list(ss_,1,size(M1)[1]);
    L = vtol(M0*ltov(T)-M1*ltov(S));
    print_time("get_eqn",T0);
    return [L,T,S];
}

def get_eqn2(MatData,Xall,Param) {
    T0=time();
    Eqn_LTS = get_eqn(MatData);
    L  = Eqn_LTS[0];
    TT = Eqn_LTS[1];
    SS = Eqn_LTS[2];
    L  = base_replace(L,assoc(Xall, Param));
    if(getopt(solve)==yes) {
        L = poly_solve_linear(L,TT);
    }
    print_time("get_eqn2",T0);
    return [L,TT,SS];
}


/* 例: ベクトル値関数 f(t; x1,x2) = (t^2+x1,-x1-t*x2)
   FuncArgs = [ ltov([t^2+x1, -x1-x2*t]), [ [t], [x1,x2] ] ]
   Vals = [ [3/2], [-2, 1.5] ]
*/
def call_func(FuncArgs,Vals) {
    F    = FuncArgs[0];
    Args = FuncArgs[1];
    N = length(Args); /* == length(Vals) */
    if(N>length(Vals)) {
        error("call_func: invalid arguments.\n");
        return 0;
    }
    for(I=0; I<N; I++) {
        V = isvect(Vals[I])? vtol(Vals[I]): Vals[I];
        F = base_replace(F,assoc(Args[I],V));
    }
    return F;
}

/* 
例: ベクトル値関数 f(a; x1,x2) = (a^2+x1+b1,-x1-a*x2+b2)
   ただし、(b1,b2) は連立方程式 
   2*x1*b1+t*b2 -1    = 0,  
   (3*t+1)*b1-x2*b2+3 = 0 
   の解とする。(t,x1,x2がパラメータ)

   Eqn = [ [2*x1*b1+t*b2-1, (3*t+1)*b1-x2*b2+3], [b1,b2], [t,x1,x2] ]
   FuncArgs = [ ltov([t^2+x1+b1, -x1-t*x2+b2]), [ [t], [x1,x2] ], Eqn ]
   Vals = [ [3/2], [-2, 1.5] ]
*/
def call_func_eqn(FuncArgs,Vals) {
    F    = FuncArgs[0];
    Args = FuncArgs[1];
    Eqn  = FuncArgs[2];
    Eq   = Eqn[0]; /* 線形方程式 Eq(S,X) = 0 ここで S はパラメータ */
    X    = Eqn[1];
    S    = Eqn[2]; /* 明示的に使わない.  S と同じものが Args に含まれるようにしておく */
    N    = length(Args); /* == length(Vals) */

    /* パラメータへの値の設定 */
    if(N>length(Vals)) {
        error("call_func: invalid arguments.\n");
        return 0;
    }
    for(I=0; I<N; I++) {
        V   = isvect(Vals[I])? vtol(Vals[I]): Vals[I];
        Rel = assoc(Args[I],V);
        F   = base_replace(F, Rel);
        Eq  = base_replace(Eq,Rel);
    }
    /* Eq(X)=0 を X について解く */
    Sol = poly_solve_linear(Eq,X);
    alert(["call_func_eqn: X=%a\nSol=%a\n\n",X,map('car',Sol)]);
    F = base_replace(F,Sol);
    return F;
}

def float2rat(F,N) {
    Dn=10^N;
    Nm=rint(F*Dn);
    return Nm/Dn;
}

def factor_prime(F) {
    if(islist(F)) {
        F = base_flatten(map(factor_prime, F));
        return oh_base.uniq(qsort(F));
    }
    return map('car',cdr(fctr(F)));
}

def factor_mul(F) {
    if(islist(F)) {
        G=car(F);
        for(F=cdr(F); F!=[]; F=cdr(F)) {
            G=lcm(G,car(F));
        }
        F=G;
    }
    return cdr(fctr(F));
}

/* from test6c */
def test19 () {  /* confluent test6. cf. Notes/c11.tex */
    /* from ud-c11.rr */
    A = [
        [1,0,0,1,1,0,1],
        [0,1,0,1,0,1,1],
        [0,0,1,0,1,1,1]];
//  printf("Std=%a\n",cbase(A));
    W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
    Mset=[1,dx5,dx6,dx7,
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
          dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
          dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
          dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
          dx5*dx5,dx5*dx6,dx5*dx7,
          dx6*dx6,dx6*dx7,
          dx7*dx7];
    V=[x1,x2,x3,x4,x5,x6,x7];
    Vb=[b_1,b_2,b_3];
    Vall = append(V,Vb);

    /* 108x58, rank=58 */
    StdMon = [1,dx7,dx6,dx5,dx4,dx7^2];
    DV=[dx1,dx2,dx3,dx4,dx5,dx6,dx7];
    Disc_R2=get_mat2(A,W,StdMon,Mset);
    Disc_R=Disc_R2[0];
    MatData=Disc_R2;

    Vall = append(V,Vb);
    Dir = [-10/11,-13/10,-8/7,(-41/43)*z,(-10/12)*z,(-25/23)*z,(-37/39)*z];
    DzDir = map(diff,Dir,z);
    Bdat = [-15/10, -26/10, -37/10];
    Pall = append(Dir, Bdat);
    Sol = get_eqn2(Disc_R2,Vall,Pall | solve=yes);
    TT = Sol[1];
    SS = Sol[2];

    Toric=mytoric(A,W)[1];
    Table = mk_table(DV,StdMon,Disc_R2[2],Toric,Vall,W,SS,TT);

    NV= length(DV);
    NM = length(StdMon);
    Pf = newvect(NV);
    for(I=0; I<NV; I++) {
        Pf[I] = DV[I]*ltov(StdMon);
        Pf[I] = mapat(oh_base.assoc_match,1,Table,Pf[I]);
    }

    Pf=vtol(Pf);
    P = 0;
    for(I=0; I<NV; I++) {
        P += DzDir[I]*Pf[I];
    }
    P = base_replace(P,Sol[0]);
    Func=[P,[[z],SS]];

#if 1
    /* an initial value at Z=0.001 */
//  InitValFloat=[ 1.833962, 18.984250, 11.719908, 9.602990, 5.922814, 565.608369];
    InitValFloat=[ 1.834885668779896312, 
                   18.96517485446140242, 
                   11.70294822085786770, 
                   9.609467131879854119, 
                   5.920492560166507569, 
                   564.0635393469870808 ];    /* 同じ場所．漸近展開による. */
    InitVal=map(float2rat,InitValFloat,6);
    Z = 1/10^3;
    H = 1/10^6;
    Zs = Z;
	Ze = 1/10;
#endif

#if 0
    /* an initial value at Z=0.1 */
    InitValFloat=[0.457392904554, 1.305954410928, 1.533103031020, 1.067058892481, 0.595251972063, 7.940707579700];
    InitVal=map(float2rat,InitValFloat,12);
    Z = 1/10;
    H = 1/10^4;
    Zs = Z;
	Ze = 25/100;
#endif

    DD = vtol(map(dn,Func[0]));
    Sing = factor_mul(DD);
    printf("Sing=%a\n\n",factor_mul(DD));
    /* 
       Sing=[
	   [z,3],
	   [5863*z-6364,1],
	   [11375*z-13616,1],
	   [30750*z-36593,1],
       [8203069875000*z^3-21363737113875*z^2+16469565786088*z-3170864832832,1]];
     */
    for(L=newvect(length(Sing)),I=0; I<length(Sing); I++) {
        L[I]=pari(roots, Sing[I][0]);
    }
    L=base_flatten(L);
    printf("SingPt=%a\n\n",L);
    /* 
       SingPt=[
       0,
       1.0854511342316220365000852805730854511,
       1.1970109890109890109890109890109890109,
       1.1900162601626016260162601626016260162,
       0.28859221237897573162896079748555733032,
       1.1221912832930888237338607023425237366,
       1.1935752918818449497661958243111942918];
    */

    InitVal=InitValFloat;
    Graph = runge_kutta_linear2(Func,Zs,InitVal,Ze,H);
    return Graph;
}

/* from test6c */
def test20 () {  /* confluent test6. cf. Notes/c11.tex */
    /* from ud-c11.rr */
    A = [
        [1,0,0,1,1,0,1],
        [0,1,0,1,0,1,1],
        [0,0,1,0,1,1,1]];
//  printf("Std=%a\n",cbase(A));
    W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
    Mset=[1,dx5,dx6,dx7,
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
          dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
          dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
          dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
          dx5*dx5,dx5*dx6,dx5*dx7,
          dx6*dx6,dx6*dx7,
          dx7*dx7];
    V=[x1,x2,x3,x4,x5,x6,x7];
    Vb=[b_1,b_2,b_3];
    Vall = append(V,Vb);

    /* 108x58, rank=58 */
    StdMon = [1,dx7,dx6,dx5,dx4,dx7^2];
    DV=[dx1,dx2,dx3,dx4,dx5,dx6,dx7];
    Disc_R2=get_mat2(A,W,StdMon,Mset);
    Disc_R=Disc_R2[0];
    MatData=Disc_R2;

    Vall = append(V,Vb);
    Dir = [-10/11,-13/10,-8/7,(-41/43)*z,(-10/12)*z,(-25/23)*z,(-37/39)*z];
    DzDir = map(diff,Dir,z);
    Bdat = [-15/10, -26/10, -37/10];
    Pall = append(Dir, Bdat);
    Eqn = get_eqn2(Disc_R2,Vall,Pall);
    TT = Eqn[1];
    SS = Eqn[2];

    Toric=mytoric(A,W)[1];
    Table = mk_table(DV,StdMon,Disc_R2[2],Toric,Vall,W,SS,TT);

    NV= length(DV);
    NM = length(StdMon);
    Pf = newvect(NV);
    for(I=0; I<NV; I++) {
        Pf[I] = DV[I]*ltov(StdMon);
        Pf[I] = mapat(oh_base.assoc_match,1,Table,Pf[I]);
    }
    Pf=vtol(Pf);
    P = 0;
    for(I=0; I<NV; I++) {
        P += DzDir[I]*Pf[I];
    }
    Func=[P,[[z],SS],Eqn];

#if 1
    /* an initial value at Z=0.001 */
//  InitValFloat=[ 1.833962, 18.984250, 11.719908, 9.602990, 5.922814, 565.608369];
    InitValFloat=[ 1.834885668779896312, 
                   18.96517485446140242, 
                   11.70294822085786770, 
                   9.609467131879854119, 
                   5.920492560166507569, 
                   564.0635393469870808 ];    /* 同じ場所．漸近展開による. */
    InitVal=map(float2rat,InitValFloat,6);
    Z = 1/10^3;
    H = 1/10^6;
    Zs = Z;
	Ze = 1/10;
#endif

#if 0
    /* an initial value at Z=0.1 */
    InitValFloat=[0.457392904554, 1.305954410928, 1.533103031020, 1.067058892481, 0.595251972063, 7.940707579700];
    InitVal=map(float2rat,InitValFloat,12);
    Z = 1/10;
    H = 1/10^4;
    Zs = Z;
	Ze = 25/100;
#endif

//  return map(deval,call_func_eqn(Func,[[Z],InitVal]));
    Graph = runge_kutta_linear2(Func,Zs,InitVal,Ze,H | callf=call_func_eqn );
    return Graph;
}

def mk_table(Dop,StdMon,MonTT,Toric,Vall,W,SS,TT) {
    T0=time();
    L = base_flatten(matc(Dop)*matr(StdMon));
    L = oh_base.uniq(qsort(L));

    /* L の各要素を StdMon, MonTT で表わす.
       そのためにまずは TT, SS で表わす. */
    if((Pos=base_position(1,StdMon))<0) {
        printf("invalid argument. (StdMon=%a).\n",StdMon);
        return []; /* error */
    }
    MM = append(MonTT, base_prune(1, StdMon));
    RR = append(TT, base_prune(SS[Pos], SS));

//    Use_sm1=tk_sm1emu.control();
//    tk_sm1emu.control(|use_sm1=1);
    L = base_set_minus(L,MM);
    Lred = ltov(L);
    N = length(Lred);
    for(I=0; I<N; I++) {
        Red = tk_sm1emu.reduction([Lred[I],Toric,Vall,W]);
        C   = Red[0]/Red[1];
        if((Pos = base_position(C,MM))>=0) {
            Lred[I] = RR[Pos];
        }else if ((Pos = base_position(-C,MM))>=0) {
            Lred[I] = -RR[Pos];
        }else {
            printf("invalid data: try to increase msize.\n");
        }
    }
//    tk_sm1emu.control(|use_sm1=Use_sm1);
    Lred = vtol(Lred);

    MM = append(MM,L);
    RR = append(RR,Lred);
    Assoc = assoc(MM,RR);
    print_time("mk_table",T0);
    return Assoc;
}

def mk_table2(Dop,StdMon,MonTT,Toric,Vall,W,SS,TT,DV) {
    T0=time();
    L = base_flatten(matc(Dop)*matr(StdMon));
    L = oh_base.uniq(qsort(L));

    /* L の各要素を StdMon, MonTT で表わす.
       そのためにまずは TT, SS で表わす. */
    if((Pos=base_position(1,StdMon))<0) {
        printf("invalid argument. (StdMon=%a).\n",StdMon);
        return []; /* error */
    }
    MM = append(MonTT, base_prune(1, StdMon));
    RR = append(TT, base_prune(SS[Pos], SS));

//    Use_sm1=tk_sm1emu.control();
//    tk_sm1emu.control(|use_sm1=1);
    L = base_set_minus(L,MM);
    Lred = ltov(L);
    N = length(Lred);
    for(I=0; I<N; I++) {
        Red = tk_sm1emu.reduction([Lred[I],Toric,Vall,W]);
        C   = Red[0]/Red[1];
        Coef = mapat(mcoef,1,C,MM,DV);
        Lred[I] = C + matrix_inner_product(Coef,ltov(RR)-ltov(MM));
    }
//    tk_sm1emu.control(|use_sm1=Use_sm1);
    Lred = vtol(Lred);

    MM = append(MM,L);
    RR = append(RR,Lred);
    Assoc = assoc(MM,RR);
    print_time("mk_table2",T0);
    return Assoc;
}

def normalize(F) {
    return dp_hc(dp_ptod(F,vars(F)))<0? -F: F;
}

def number_sign(X) {
    return (X==0)? 0: (X<0)? -1: 1;
}

def runge_kutta_linear2(FuncArgs,Xs,Ys,Xe,H) {
	Rk_deval = _getopt(deval,deval);
    if (type(Ys)==type([])) {
        Ys = ltov(Ys);
    }
    CALL = _getopt(callf,call_func);
    N  = rint(number_abs((Xe-Xs)/H));
    H  = number_sign(Xe-Xs)*H;
    H2 = H/2;
    Ans = [[Xs,Ys]];
    alert(["%a %a\n", (*Rk_deval)(Xs), 'map'(Rk_deval, Ys)]);
    for(Y=Ys,X=Xs,I=0; I<N; I++) {
        Y1 = (*CALL)(FuncArgs, [[X],   Y]); 
        Y2 = (*CALL)(FuncArgs, [[X+H2],Y+H2*Y1]); 
        Y3 = (*CALL)(FuncArgs, [[X+H2],Y+H2*Y2]); 
        Y4 = (*CALL)(FuncArgs, [[X+H], Y+ H*Y3]); 
/*
        printf("Y1: %a %a\nY2: %a %a\nY3: %a %a\nY4: %a %a\n", 
               (*Rk_deval)(X),    'map'(Rk_deval, Y1),
               (*Rk_deval)(X+H2), 'map'(Rk_deval, Y2),
               (*Rk_deval)(X+H2), 'map'(Rk_deval, Y3),
               (*Rk_deval)(X+H),  'map'(Rk_deval, Y4));
*/
        Y += (H/6)*(Y1+2*(Y2+Y3)+Y4);
        X += H; 
        alert(["%a %a\n", (*Rk_deval)(X), 'map'(Rk_deval, Y)]);
        Ans = cons([X,Y],Ans);
    }
    alert("\n");
    return reverse(Ans);
}

def rk_eval_norm_euclidean(V) {
    N = length(V);
    Norm = 0;
    for(I=0; I<N; I++) {
        Norm += V[I]*V[I];
    }
    return oh_number.deval(Norm^(1/2));
}

def rk_eval_norm_max(V) {
    return oh_base.max(map(oh_number.abs, V));
}

/* W has no zero entry */
def vector_ratio(V,W) {
    N = length(V);
    R = newvect(N);
    for(I=0; I<N; I++) {
        R[I] = V[I]/W[I];
    }
    return R;
}

//  ErrTol = [absolute error tolerance, relative error tolerance]
def rk_error(Y1,Y2,K,Ctrl) {
//  NormF=rk_eval_norm_max;
    NormF=rk_eval_norm_euclidean;
    Y = map(oh_number.abs,Y1-Y2);
    K = map(oh_number.abs,K);
    Scale = rk_scale(Y,K,Ctrl);
    Ratio = vector_ratio(Y,Scale);
    return (*NormF)(Ratio);
}

// Y,K are non-negative vectors
def rk_scale(Y,K,Ctrl) {
    R = Ctrl[1]*(Ctrl[2]*Y + Ctrl[3]*K);
    N = length(R);
    for(I=0; I<N; I++) {
        R[I] += Ctrl[0];
    }
    return R;
}

/* see GSL 1.15 reference manual, section 26.3 */
def rk_step_controller(Ctrl) {
    /* [absolute error tolerance, relative error tolerance, coef. of |y|, coef. of |y'|] */
    DefaultCtrl = [1/10^9,1/10^9,1,0];  // default
    if (islist(Ctrl)) {
        N = length(Ctrl);
        if(N==4) {
            return Ctrl;
        }else if (N==2) {
            return append(Ctrl,[1,0]);
        }else if (N==3 || N==1) {
            return append(Ctrl,vtol(newvect(4-N)));
        }
    }
    return DefaultCtrl;
}

def rk_step45(Call,FuncArgs,X,Y,H,Ctrl,Eval) {
    /* see Numerical Recipes 3rd ed., section 17.2 (pp.910--921) */
    /* Dormand-Prince 4(5) parameters for embedded Runge-Kutta */
    C  = [0,0,1/5,3/10,4/5,8/9,1,1];
    B5 = [0, 35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0];
    B4 = [0, 5179/57600, 0, 7571/16695, 393/640, -92097/339200, 187/2100, 1/40];
    A2 = [0,1/5];
    A3 = [0,3/40,9/40];
    A4 = [0,44/45,-56/15,32/9];
    A5 = [0,19372/6561,-25360/2187,64448/6561,-212/729];
    A6 = [0,9017/3168,-355/33,46732/5247,49/176,-5103/18656];
//  A7 = B5;

    K1 = H*(*Call)(FuncArgs, [[X],   Y]); 
    K2 = H*(*Call)(FuncArgs, [[X+C[2]*H], Y+A2[1]*K1]); 
    K3 = H*(*Call)(FuncArgs, [[X+C[3]*H], Y+A3[1]*K1+A3[2]*K2]); 
    K4 = H*(*Call)(FuncArgs, [[X+C[4]*H], Y+A4[1]*K1+A4[2]*K2+A4[3]*K3]); 
    K5 = H*(*Call)(FuncArgs, [[X+C[5]*H], Y+A5[1]*K1+A5[2]*K2+A5[3]*K3+A5[4]*K4]); 
    K6 = H*(*Call)(FuncArgs, [[X+C[6]*H], Y+A6[1]*K1+A6[2]*K2+A6[3]*K3+A6[4]*K4+A6[5]*K5]); 
    Y4 = Y + B4[1]*K1 + B4[2]*K2 + B4[3]*K3 + B4[4]*K4 + B4[5]*K5 + B4[6]*K6; // embedded 4th RK
    Y5 = Y + B5[1]*K1 + B5[2]*K2 + B5[3]*K3 + B5[4]*K4 + B5[5]*K5 + B5[6]*K6;

    Error = (*Eval)(rk_error(Y5,Y4,K1,Ctrl));

    return [Y5,Error];
}

/* 5th order Runge-Kutta method with adaptive stepsize control */
/* see Numerical Recipes 3rd ed., section 17.2 (pp.910--921) */
def runge_kutta_linear3(FuncArgs,Xs,Ys,Xe,H) {
    Eval = _getopt(deval,oh_number.deval);
    Safety = 9/10;

    Ctrl = rk_step_controller(getopt(ctrl));
    alert(["ErrorController=%a\n",Ctrl]);

    if (type(Ys)==type([])) {
        Ys = ltov(Ys);
    }

    Sign = number_sign(Xe-Xs);
    CALL = _getopt(callf,call_func);
    H  = Sign*number_abs(H);

    X = Xs; Y = Ys;
    Ans = [[X,Y]];
    alert(["\n%a %a\n", (*Eval)(X), 'map'(Eval, Y)]);
    if (X==Xe) {
        alert("\n");
        return Ans;
    }

    while(1) {
        X1 = X; Y1 = Y;
        R = rk_step45(CALL,FuncArgs,X,Y,H,Ctrl,Eval);
        Y5 = R[0]; Error = R[1];
        alert(["Error = %a\n", Error]);
        if (Error>1) { // Retry because the error is too large.
            E5 = (*Eval)(Error^(-1/5));
            H2 = H*Safety*E5;
            alert(["(retry) log10(H): %a => %a\n", dlog(H)/dlog(10), dlog(H2)/dlog(10)]);
            H  = H2;
            continue;
        }
        X += H; Y = Y5;
        if (Error <= 1/2) { // Enlarging the stepsize because of too small.
            E5 = (*Eval)(Error^(-1/5));
            H2 = H*Safety*E5;
            alert(["(next) log10(H): %a => %a\n", dlog(H)/dlog(10), dlog(H2)/dlog(10)]);
            H  = H2;
        }
        if ( Sign*(Xe-X) <= 0 ) {
            break;
        }
        alert(["%a %a\n", (*Eval)(X), 'map'(Eval, Y)]);
        Ans = cons([X,Y],Ans);
    }
    if ( Xe != X ) { // retry last step
        H = Xe - X; /* abs(Xe-X1) < abs(LastH) */
        R = rk_step45(CALL,FuncArgs,X1,Y1,H,Ctrl,Eval);
        X += H; Y  = R[0];
    }
    alert(["%a %a\n\n", (*Eval)(X), 'map'(Eval, Y)]);
    Ans = cons([X,Y],Ans);
    return reverse(Ans);
}

// ctrl("real_digit",16);
// test19()$
// test20()$

/* 
初期値 (Z=0.001)
InitValFloat=[ 
1.834885668779896312, 
18.96517485446140242, 
11.70294822085786770, 
9.609467131879854119, 
5.920492560166507569, 
564.0635393469870808 ];    // 同じ場所．漸近展開による.

計算結果 (Z=0.00108)
[
1.83134313847,
18.8799005805,
11.6666045147,
9.57611084253,
5.89871455232,
559.320556772 ]

// from Takayama
z=0.00108 の時の値は
1.83134313331868557399
error bound は0.0000000089279079861514485316

(snip)

漸近級数で計算すると, 最後だけ,
558.654942661977
です。２桁は数値積分と一致してますね.

error bound = 8.927907986e-09

A=1.83134313331868557399;
B=1.83134313847;

dabs(A-B);
5.151314486e-09

*/

def hgm_ahg_test_mset(A,W,Mset) {
    StdMon=reverse(cbase(A));
    printf("StdMon=%a\n",StdMon);

    Row = length(A); Col = length(A[0]);
    V  = base_var_list(x,1,Col);
    DV = add_d(V);
    Vb = base_var_list(b_,1,Row);

    if(W==[] || W==0) { /* use rev lex order */
        W = [base_flatten(assoc(DV,[1]))];
    }

    R=get_mat2(A,W,StdMon,Mset)[0];
    printf("size of R is %a\n",size(R));

    Rule=genrule_p(append(V,Vb));
    return [matrix_rank(base_replace(R,Rule)),StdMon];
}

def hgm_ahg(A,W,Mset,StdMon,Line,B,InitVal,Start,End,H) {
	Mode=getopt(mode);
	if(type(Mode)<0) {
		Mode=0;
	}
    if(qsort(StdMon) != qsort(reverse(cbase(A)))) { /* error! */
        return 0;
    }
    Row = length(A); Col = length(A[0]);
    V  = base_var_list(x,1,Col);
    DV = add_d(V);
    Vb = base_var_list(b_,1,Row);
    Vall = append(V,Vb);

    if(W==[] || W==0) { /* use rev lex order */
        W = [base_flatten(assoc(DV,[1]))];
    }
    if(Mset==[] || Mset==0) {
        Mset = reverse(p_terms((1+oh_base.sum(DV))^2,DV,0));
    }

    Disc_R2=get_mat2(A,W,StdMon,Mset);
    Disc_R=Disc_R2[0];
    MatData=Disc_R2;

	if(Mode==1) {
		Eqn = get_eqn2(Disc_R2,Vall,append(Line, B) | solve=yes);
	}else {
		Eqn = get_eqn2(Disc_R2,Vall,append(Line, B));
	}
    TT = Eqn[1];
    SS = Eqn[2];

    Toric=mytoric(A,W)[1];
    Table = mk_table(DV,StdMon,Disc_R2[2],Toric,Vall,W,SS,TT);

    Z = base_prune(0,map(var,Line))[0];  
    for(P=0,I=0; I<Col; I++) {
        Dir = diff(Line[I],Z);
        if(Dir!=0) {
            PfI = mapat(oh_base.assoc_match,1,Table,DV[I]*ltov(StdMon));
            P += Dir*PfI;
        }
    }
	if(Mode==1) {
		P = base_replace(P,Eqn[0]);
		Func=[P,[[Z],SS]];
//		return runge_kutta_linear2(Func,Start,InitVal,End,H);
		return runge_kutta_linear3(Func,Start,InitVal,End,H | deval=oh_number.deval);
	}
    Func=[P,[[Z],SS],Eqn];
//  return runge_kutta_linear2(Func,Start,InitVal,End,H | callf=call_func_eqn, deval=oh_number.deval );
    return runge_kutta_linear3(Func,Start,InitVal,End,H | callf=call_func_eqn, deval=oh_number.deval );
}

/* Sylvester like method */
/* DPoly: V,DV の多項式 */
def hgm_ahg_sylvester_generic(A,StdMon,X,Beta,DPolyList) {
#if 0
    if(qsort(StdMon) != qsort(reverse(cbase(A)))) { /* error! */
        return 0;
    }
#endif
    Row = length(A); Col = length(A[0]);
    V  = base_var_list(x,1,Col);
    DV = add_d(V);
    Vb = base_var_list(b_,1,Row);
    Vall = append(V,Vb);
    Pall = append(X,Beta);

    W=getopt(w);
    Mset=getopt(mset);
    Msize=getopt(msize);

    if(type(W)<0 || W==[] || W==0) { /* use rev lex order */
        W = [base_flatten(assoc(DV,[1]))];
    }
    if(type(Mset)<0 || Mset==[] || Mset==0) {
        if(type(Msize)<0 || Msize<2) {
            Msize=2;
        }
        Mset = reverse(p_terms((1+oh_base.sum(DV))^Msize,DV,0));
    }

    Disc_R2=get_mat2(A,W,StdMon,Mset);
    Disc_R=Disc_R2[0];
    MatData=Disc_R2;
    Toric=MatData[3];
    Eqn = get_eqn2(MatData,Vall,Pall | solve=yes);
    TT = Eqn[1];
    SS = Eqn[2];
    Table = mk_table2(DPolyList,StdMon,Disc_R2[2],Toric,Vall,W,SS,TT,DV);
    N = length(SS);
    E = matrix_identity_matrix(N);
    RelS = newvect(N);
    for(I=0; I<N; I++) {
        RelS[I] = assoc(SS,vtol(E[I]));
    }
    RelS = vtol(RelS);

	NL=length(DPolyList);
	MatDPoly=newvect(NL);
	for(I=0; I<NL; I++) {
		DK = mapat(oh_base.assoc_match,1,Table,DPolyList[I]*ltov(StdMon));
		DK = base_replace(DK,Eqn[0]);
		MatDPoly[I] = call(matc,mapat(base_replace,1,DK,RelS));
	}
    return vtol(MatDPoly);
}

/* Sylvester like method による A-hg のパッフィアンの導出 */
//def hgm_ahg_pfaffian(A,W,Mset,StdMon,X,Beta) {
def hgm_ahg_pfaffian(A,StdMon,X,Beta) {
    T0=time();
#if 0
    if(qsort(StdMon) != qsort(reverse(cbase(A)))) { /* error! */
        return 0;
    }
#endif

    Row = length(A); Col = length(A[0]);
    V  = base_var_list(x,1,Col);
    DV = add_d(V);
    Vb = base_var_list(b_,1,Row);
    Vall = append(V,Vb);
    Pall = append(X,Beta);

    W=getopt(w);
    Mset=getopt(mset);
    Msize=getopt(msize);

    if(type(W)<0 || W==[] || W==0) { /* use rev lex order */
        W = [base_flatten(assoc(DV,[1]))];
    }
    if(type(Mset)<0 || Mset==[] || Mset==0) {
        if(type(Msize)<0 || Msize<2) {
            Msize=2;
        }
        Mset = reverse(p_terms((1+oh_base.sum(DV))^Msize,DV,0));
    }

    Disc_R2=get_mat2(A,W,StdMon,Mset);
    Disc_R=Disc_R2[0];
    MatData=Disc_R2;
    Toric=MatData[3];
    Eqn = get_eqn2(MatData,Vall,Pall | solve=yes);
    TT = Eqn[1];
    SS = Eqn[2];
    Table = mk_table(DV,StdMon,Disc_R2[2],Toric,Vall,W,SS,TT);

    N = length(SS);
    E = matrix_identity_matrix(N);
    RelS = newvect(N);
    for(I=0; I<N; I++) {
        RelS[I] = assoc(SS,vtol(E[I]));
    }
    RelS = vtol(RelS);
    Pf = newvect(Col);
    for(K=0; K<Col; K++) {
        DK = mapat(oh_base.assoc_match,1,Table,DV[K]*ltov(StdMon));
        DK = base_replace(DK,Eqn[0]);
        Pf[K] = call(matc,mapat(base_replace,1,DK,RelS)); // V[K] に関するパッフィアン
    }
    Pf = vtol(Pf);
    print_time("hgm_ahg_pfaffian",T0);
    return Pf;
}

def remove_const(L) {
  L2=[];
  for (I=0; I<length(L); I++) {
    if (type(L[I]) >= 2) L2=cons(L[I],L2);
  }
  return(reverse(L2));
}
def find_maxstep(F,V,B,AI,Count) {
    T0=time();
    if(Count<=0) return 0;
    Rel=assoc(V,B);
    /* 両端だけ確認 */
    // G=map('car',cdr(fctr(F))); /* 一次式に分解 */
    G = remove_const(F);
    G0=map(oh_number.sign,base_replace_n(G,Rel));
    C=vtol(ltov(B)-(Count-1)*AI);
    Rel2=assoc(V,C);
    G1=map(oh_number.sign,base_replace_n(G,Rel2));
    if(G0==G1) { /* F の全ての因子の符号が一定: 0 を通らない。 */
        print_time("find_maxstep",T0 | opt=1);
        return Count;
    }

    /* 途中で 0 になる可能性がある場合: 本来は２分探索と組合せるべき */
    for(I=0; I<Count; I++) {
        F0=base_replace_n(F,Rel);
        if(F0==0) {
            print_time("find_maxstep",T0 | opt=[2,I,Count]);
            return I;
        }
        B=vtol(ltov(B)-AI);
        Rel=assoc(V,B);
    }
    print_time("find_maxstep",T0 | opt=3);
    return I;
}

def find_path(A,B) {
    Geom=(type(getopt(bfct_geometric))>0);
    T0=time();
    Col=length(A[0]);
    Row=length(A);
    for(W=[],I=0; I<Col; I++) {
        W=cons(1,W);
    } /* W=[1,1,...,1] */
    T1=time();
    U = tk_hgpoly.optip(A,B,W); /* 特異点を考えない、原点までの経路を表わす。 */
    print_time("find_path: tk_hgpoly.optip",T1);
    AA=matrix_list_to_matrix(A);
    AI=mapat(mat_col,1,AA,oh_base.range(0,Col-1)); /* 列ベクトルの集合 */
    S=base_var_list(b_,1,Row);
    Blist=[]; 
    Geom=1;
    for (I=0; I<Col; I++) {
        Bf = hg_bfct(A,I | geometric=Geom)[0]; /* b-関数 */
        Blist = cons(Bf,Blist);
    }
    Blist=reverse(Blist); /* 全方向に対する b-関数のリスト */

    U=ltov(U);
    Path=[];
    while(1) {
        Pos=-1; Count=0;
        for(I=0; I<Col; I++) {
            T = U[I]>0? find_maxstep(Blist[I],S,B,AI[I],U[I]): 0;
            if(T>Count) {
                Count=T; Pos=I;
            }
        }
        if(Pos==-1) { /* どの方向にも進めない。U にない方向を探すべき? */
            break;
        }
        Path=cons([Pos,Count],Path);
        U[Pos]-=Count;
        B=vtol(ltov(B)-Count*AI[Pos]);
    }
    Path=reverse(Path);
    print_time("find_path",T0);
    return [Path,B];
}

def apply_stdmon_poly(StdMon,F,V,DV) {
    yang.define_ring(["partial",V]);
    S=map(dp_ptod,StdMon,DV);
    DF=map(yang.action,S,F);
    yang.pop_ring();
    return DF;
}

/* B,X: 具体的な値 */
def hgm_ahg_evaluation_contiguity(A,B,X) {
    T0=time();
    Mode=getopt(base);
    if(type(Mode)<0) {
        Mode=0;
    }
    Col = length(A[0]);
    Row = length(A);
    Path = find_path(A,B | option_list=getopt());  /* 経路を表わす */
	alert(["Path for %a: %a\n",B,Path]);
	
    StdMon=reverse(cbase(A));
    V = base_var_list(x,1,Col);
    DV= add_d(V);
	Beta=Path[1];
	
	if (Beta==vtol(newvect(Row))) { 
		InitVal = base_replace(StdMon,assoc(DV,[0])); /* パラメータ [0,0,...,0] における超幾何多項式とその微分 */
	}else {
		HG = tk_hgpoly.hgpolyk(A,Beta); /* 超幾何多項式: 分散表現多項式 */
		HG = dp_dtop(HG,V);
		InitVal = apply_stdmon_poly(StdMon,HG,V,DV);
		InitVal = base_replace(InitVal,assoc(V,X));
	}

	Val = InitVal;
    At = matrix_transpose(A);
    Z = n;

	for(Path=reverse(Path[0]); Path!=[]; Path=cdr(Path)) {
		C=car(Path);
		Dir=C[0]; /* A の第 C[0] 列*/
		Line = [Dir, Beta, Z];
		Val = hgm_ahg_contiguity(A,StdMon,Line,X,Val,0,C[1] | option_list=getopt());
		Beta = vtol(ltov(Beta) + C[1]*At[C[0]]);
	}
	alert(["Beta=%a\n",Beta]);
    NC = matrix_inner_product(Val,InitVal);
    print_time("hgm_ahg_evaluation_contiguity",T0);
    return Mode? [NC,Val,StdMon]: NC;
}

def hgm_ahg_contiguity0(A,StdMon,Line,X0,InitVal,Start,End) {
    Mode=getopt(pf);
    if(type(Mode)<0) {
        Mode=0;
    }
    MatA = matrix_list_to_matrix(A);

    // Line == [ContiDir, Beta, Z];  e.g. [0, [1,31,11,6,7], n]
    ContiDir = Line[0]; Beta = Line[1]; Z = Line[2];
    BetaZ = vtol(ltov(Beta) + mat_col(MatA,ContiDir)*Z);

    Pf  = hgm_ahg_pfaffian(A,StdMon,X0,BetaZ | option_list=getopt());
    PfZ = Pf[ContiDir]; // ContiDir 方向に減少する差分パッフィアン
    if (ForPaper) {
       alert(["PfZ = %a\n in ForPaper_data1\n",PfZ]);
       ForPaper_data1=PfZ;
    }
    R=1;
    if (End == Start) return(InitVal); // By N.T.
    /* By N.T.  Strategy_N */
    if (!Strategy_N) {
      for(I=Start+1; I<=End; I++) {
        R = R*base_replace(PfZ, [[Z,I]]);
      }
      Ri = matrix_inverse(R); // ContiDir 方向に Start から End まで増加する
      Val = vtol(Ri*ltov(InitVal)); // 正規化定数
      if (Mode) {
        Pf = base_replace(Pf, [[Z,End]]); // Z==End における Pfaffian
        return [Val, Pf];
      }
    }else{
      alert("Strategy_N=1\n");
      Val = matrix_list_to_matrix(InitVal);
      for(I=Start+1; I<=End; I++) {
        Val = matrix_inverse(base_replace_n(PfZ, [[Z,I]]))*Val;
      }
      if (Mode) {
        debug("It is not implemented.");
      }
    }
    return Val;
}

def hgm_ahg_contiguity(A,StdMon,Line,X0,InitVal,Start,End) {
    T0=time();
    MatA = matrix_list_to_matrix(A);

    // Line == [ContiDir, Beta, Z];  e.g. [0, [1,31,11,6,7], n]
    ContiDir = Line[0]; Beta = Line[1]; Z = Line[2];
    BetaZ = vtol(ltov(Beta) + mat_col(MatA,ContiDir)*Z);

    Pf  = hgm_ahg_pfaffian(A,StdMon,X0,BetaZ | option_list=getopt());
    PfZ = Pf[ContiDir]; // ContiDir 方向に減少する差分パッフィアン
    if (ForPaper) {
		alert(["PfZ = %a\n in ForPaper_data1\n",PfZ]);
		ForPaper_data1=PfZ;
    }
    Val = ltov(InitVal);
    if(End > Start) { // 増加方向
        for(I=Start+1; I<=End; I++) {
            Val = matrix_inverse(base_replace_n(PfZ, [[Z,I]]))*Val;
        }
    }else if(End < Start) { // 減少方向
        for(I=Start; I>End; I--) {
            Val = base_replace_n(PfZ, [[Z,I]])*Val;
        }
    }
    print_time("hgm_ahg_contiguity",T0);
    return Val;
}

def hgm_ahg_expected_value_contiguity0(A,StdMon,Line,X,InitVal,InitPt,TargetPt,Item) {
    Opts = cons(["base",1],getopt());
    R = hgm_ahg_contiguity(A,StdMon,Line,X,InitVal,InitPt,TargetPt | option_list=Opts);
    Val = ltov(R[0]);
    Pf = R[1];    // Pfaffian 行列のリスト
    NC = Val[0]; // 正規化定数
    Nm = X[Item]*(Pf[Item]*Val)[0]; 
    EV = Nm/NC; // TargetPt における Item の期待値 (Item は変数の番号)
    return EV;
}

def mk_table_euler_to_pd(Deg) {
    A=[[0],[0,1]];
    for(J=2; J<=Deg; J++) {
        S=A[J-1];
        T=newvect(J+1);
        T[1]=1;
        T[J]=1;
        for(I=2; I<J; I++) {
            T[I] = S[I-1]+I*S[I];
        }
        A=append(A,[vtol(T)]);
    }
    return A;
}

def array_to_poly(Coef,X) {
    N=length(Coef);
    P=0;
    for(I=0; I<N; I++) {
        P+=Coef[I]*X^I;
    }
    return P;
}

/* replace variables by euler operators */
/* V: variables, DV: partial diff operators */
def poly_to_operator(P,V) {
    Order=dp_ord();
    dp_ord(0);
    N=length(V);
    Deg=oh_base.max(mapat(deg,1,P,V));
    DV=add_d(V);
    Tbl=mk_table_euler_to_pd(Deg);
    R=0;
    for(P=dp_ptod(P,V); P!=0; P=dp_rest(P)) {
        C=dp_hc(P);
        Exp=dp_etov(P);
        M=1;
        for(I=0; I<N; I++) {
            if(Exp[I]>0) {
                M *= array_to_poly(Tbl[Exp[I]],V[I]*DV[I]);
            }
        }
        R+=C*M;
    }
    R=dp_ptod(R,DV);
    dp_ord(Order);
    return R;
}

def test_poly_to_operator() {
    V=[x,y];
    P=x^2-2*x*y+y^2;
    DP=poly_to_operator(P,V);
    printf("poly_to_operator:\n  %a ->\n  %a\n",P,DP);
}

def hgm_ahg_contiguity_down(A,B,X,StdMon,Val,E) {
    T0=time();
    Val=ltov(Val);
    Opts = cons(["base",1],getopt());
    AA=matrix_list_to_matrix(A);
    Col=length(A[0]);
    if(ltov(E)==newvect(Col)) {
        print_time("hgm_ahg_contiguity_down",T0);
        return Val;
    }
    U=0;
    for(J=0; J<Col; J++) {
        U += E[J]*mat_col(AA,J);
    }
    BB = vtol(ltov(B)-U);
    alert(["BB=%a\n",BB]);
    Feasible=tk_hgpoly.feasible(A,BB);
    if(Feasible==0) {
        alert("not feasible\n");
        print_time("hgm_ahg_contiguity_down",T0);
        return 0;
    }
    if(_getopt(no_use_initval,0)) {
        // do not use initial value
        NCVal = hgm_ahg_evaluation_contiguity(A,BB,X | option_list=Opts);
        Val = NCVal[1];
		if(StdMon!=NCVal[2]) error("invalid stdmon!");
        print_time("hgm_ahg_contiguity_down",T0);
		return Val;
    }

    for(J=0; J<Col; J++) {
        if(E[J]!=0) {
            Line=[J,B,n];
            alert(["Line=%a\n",Line]);
            Val = hgm_ahg_contiguity(A,StdMon,Line,X,Val,0,-E[J] | option_list=Opts);
            B=vtol(ltov(B)-E[J]*mat_col(AA,J));
        }
    }
    print_time("hgm_ahg_contiguity_down",T0);
    return Val;
}

def hgm_ahg_expected_values_contiguity(A,B,X,RandomVars) {
    T0=time();
    Opts = cons(["base",1],getopt());
    NCVal= hgm_ahg_evaluation_contiguity(A,B,X | option_list=Opts);
    NC = NCVal[0]; Val = NCVal[1]; StdMon = NCVal[2];
    AA=matrix_list_to_matrix(A);
    Col = length(A[0]);
    V  = base_var_list(x,1,Col);
    DV = add_d(V);
    Pos = base_replace(StdMon,assoc(DV,[0])); /* StdMon のうち、1 の位置を表わすベクトル */
    N=length(RandomVars);
    EV=newvect(N);
    InitVal=ltov(Val);
    for(I=0; I<N; I++) {
        EVal=0;
        DP = base_replace(poly_to_operator(RandomVars[I],V),assoc(V,X));
        for( ; DP!=0; DP=dp_rest(DP)) {
            HC=dp_hc(DP);
            E=dp_etov(DP);
            EVal += HC*hgm_ahg_contiguity_down(A,B,X,StdMon,InitVal,E | option_list=Opts);
        }
        EV[I] = (EVal==0)? 0: (1/NC)*matrix_inner_product(EVal,Pos);
    }
    EV=vtol(EV);
    print_time("hgm_ahg_expected_values_contiguity",T0 | opt=B);
    return EV;
}

def hgm_ahg_expected_values_contiguity_generic(A,B,X,RandomVars) {
    T0=time();
    Opts = getopt();
    if(a_is_non_negative(A)) {
        alert("A is non-negative.\n");
        EV=hgm_ahg_expected_values_contiguity(A,B,X,RandomVars | option_list=Opts);
    }else {
    ACH=translation_of_a(A);
    NewA=ACH[0];
    NewB=translation_of_beta(B,ACH);
    alert(["NewA=%a\nCH=%a\nNewB=%a\n",NewA,cdr(ACH),NewB]);
        EV=hgm_ahg_expected_values_contiguity(NewA,NewB,X,RandomVars | option_list=Opts);
    }
    print_time("hgm_ahg_expected_values_contiguity_generic",T0);
    return EV;
}

/* 行列 A の成分が非負か */
def a_is_non_negative(A) {
    if(ismat(A)) {
        S=size(A); Row=S[0]; Col=S[1];
    }else {
        Row=length(A); Col=length(A[0]);
    }
    for(I=0; I<Row; I++) {
        for(J=0; J<Col; J++) {
            if(A[I][J]<0) {
                return 0;
            }
        }
    }
    return 1;
}

/* 
A の 任意の列ベクトル a=(a_1,..., a_d) に対して、
h(a) = h_1a_1 + ... + h_d a_d = 1 となる
超平面 h を与える (h_1,...,h_d) を返す
*/
def find_hyperplane(A) {
    S=size(A);
    Row=S[0];
    Col=S[1];
    for(C=[],I=Row; I>0; I--) {
        C=cons(strtov(sprintf("%a%a","x",I)),C);
    }
    Col=size(A)[1];
    T=newvect(Col);
    for(I=0; I<Col; I++) {
        T[I]=1;
    }
    Sol=poly_solve_linear(vtol(ltov(C)*A-T),C);
    if(length(Sol)!=length(C)) {
        return 0; /* 超平面が存在しない */
    }
    H=base_replace(C,Sol);
    return H;
}

/*
グレブナー道場1章補題1.5.10 の方法によって、トーリックイデアルを不変とする
配置行列の変換を与える。
返り値: [A,C,H]
A: 新しい配置行列
C: 各列に加えた非負整数ベクトル
H: もとの配置行列について、超平面を定めるベクトル
 */
def translation_of_a(A) {
    AM=matrix_list_to_matrix(A);
    S=size(AM);
    Row=S[0];
    Col=S[1];
    C=newvect(Row);
    H=find_hyperplane(AM);
    if(H==0) return 0;
    for(I=0; I<Row; I++) {
        C[I]=-oh_base.min(cons(0,A[I]));
    }
    if(C!=newvect(Row)) { /* A が負の要素を含む */
        T=matrix_inner_product(H,C);
        if(T==-1) {
            /* H に直交しない単位ベクトルを C に加える */
            for(I=0; I<Row && H[I]==0; I++) {
            }
            C[I]++;
        }
        CC=newvect(Col);
        for(J=0; J<Col; J++) {
            CC[J] = C;
        }
        AM=AM+call(matc,CC);
        A=matrix_matrix_to_list(AM);
    }
    return [A,C,H];
}

def translation_of_beta(B,ACH) {
    C=ACH[1];
    H=ACH[2];
    return vtol(ltov(B)+matrix_inner_product(H,B)*C);
}

def test100 () {
    /* from ud-c11.rr */
    A = [[1,0,0,1,1,0,1],
         [0,1,0,1,0,1,1],
         [0,0,1,0,1,1,1]];
    Row = length(A); Col = length(A[0]);
    W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
    Mset=[1,dx5,dx6,dx7,
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
          dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
          dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
          dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
          dx5*dx5,dx5*dx6,dx5*dx7,
          dx6*dx6,dx6*dx7,
          dx7*dx7];

    StdMon = [1,dx7,dx6,dx5,dx4,dx7^2];
    Line = [-10/11,-13/10,-8/7,(-41/43)*z,(-10/12)*z,(-25/23)*z,(-37/39)*z];
    Bdat = [-15/10, -26/10, -37/10];

#if 1
    /* an initial value at Z=0.001 */
    InitValFloat=[ 1.834885668779896312, 
                   18.96517485446140242, 
                   11.70294822085786770, 
                   9.609467131879854119, 
                   5.920492560166507569, 
                   564.0635393469870808 ];    /* 同じ場所．漸近展開による. */
    InitVal=map(float2rat,InitValFloat,6);
    Start = 1/10^3;
    End = 1/10;
    H = 1/10^6;
#endif

#if 0
    /* an initial value at Z=0.1 */
    InitValFloat=[0.457392904554, 1.305954410928, 1.533103031020, 1.067058892481, 0.595251972063, 7.940707579700];
    InitVal=map(float2rat,InitValFloat,12);
    Start = 1/10;
    End = 25/100;
    H = 1/10^4;
#endif
    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H);
    F = reverse(G)[0];
    return [deval(F[0]),map(deval,F[1])];
}

def test6d() {
    A = [[1,0,0,1,1,0,1],
         [0,1,0,1,0,1,1],
         [0,0,1,0,1,1,1]];
    W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
    Mset=[1,dx5,dx6,dx7, 
            dx1,dx2,dx3,dx4,
            dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
                    dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
                             dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
                                     dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
                                             dx5*dx5,dx5*dx6,dx5*dx7,
                                                     dx6*dx6,dx6*dx7,
                                                             dx7*dx7];
    return hgm_ahg_test_mset(A,W,Mset);
}

/* F_D from h-mle/FD/Prog/fdpf.rr check(10)  */
def test110() {
    A = [[1,1,1,1,0,0,0,0],
       [1,0,0,0,1,0,0,0],
       [0,1,0,0,0,1,0,0],
       [0,0,1,0,0,0,1,0],
       [0,0,0,1,0,0,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; */
    W=[];
    Mset=[1,dx5,dx6,dx7,dx8, 
            dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8,
                                                                   dx8*dx8];

    StdMon=[1,dx8,dx7,dx6];
    Dir = [0,1/2,1/3,1/4,0,0,0,0];
	Pt0 = [1,1/20,1/10,3/20,1,1,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1/2,-19/14,-1/3,-1/5,-1/11];

    /* an initial value at Z=0 by check7(10) */
    InitValFloat= [ 1.19505025171429995935011756799039243029388647110495690231,
					-0.171909712765026133647462174136326715493035759705424405645,
					-0.325127216579630777012789631518989535279864106544409154292,
					-0.465226174525471104850159503487993942789075081411665529643];
    InitVal=map(float2rat,InitValFloat,6);
    Start = 0;
    End = 1/10;
	H = 1/10^5;
	TargetValFloat = [1.30653474406446941281514923953551188142993976219689097489,
					  -0.198372479159747173559323964725234816747543096711018280293,
					  -0.386432833081859751387869841763599069918640617829089346345,
					  -0.584424284968205792783937496766437194841036114282518073142];

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H);
    F = reverse(G)[0];
    Val = [deval(F[0]),map(deval,F[1])];
	printf("Val=%a\n  atZ=%a\n\n", Val[1],Val[0]);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

def test111() {
	Deval=oh_number.deval;
    A = [[1,1,1,1,0,0,0,0],
       [1,0,0,0,1,0,0,0],
       [0,1,0,0,0,1,0,0],
       [0,0,1,0,0,0,1,0],
       [0,0,0,1,0,0,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; */
    W=[];
    Mset=[1,dx5,dx6,dx7,dx8, 
            dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8,
                                                                   dx8*dx8];

    StdMon=[1,dx8,dx7,dx6];
    Dir = [0,1/2,1/3,1/4,0,0,0,0];
	Pt0 = [1,1/20,1/10,3/20,1,1,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1/2,-19/14,-1/3,-1/5,-1/11];

    /* an initial value at Z=0 by check7(30) */
    InitValFloat= [ 1.19505025186078973856324535516282809960832446191213484050,
				   -0.171909714259269817594145743377544836183663976613720245516,
				   -0.325127216734109713804903925455918486964102689556102294155,
				   -0.465226174603649105888797335558491584759624199217577452861];
	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^12;
//	End = Start+10*H;
	printf("H=%a\n",H);
	TargetValFloat = [1.30653474526512361790567548176126429002582614030996144986,
					  -0.198372489487087915397232216954501730234040987864606539446,
					  -0.386432835651982983362135481308333777740853851309581833048,
					  -0.584424286257640845566056905386694872409875592930997773923];
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
	printf("TargetVal=%a\n", TargetValFloat);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

def test112() {
	Deval=oh_number.deval;
    A = [[1,1,1,1,0,0,0,0],
       [1,0,0,0,1,0,0,0],
       [0,1,0,0,0,1,0,0],
       [0,0,1,0,0,0,1,0],
       [0,0,0,1,0,0,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; */
    W=[];
    Mset=[1,dx5,dx6,dx7,dx8, 
            dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8,
                                                                   dx8*dx8];

    StdMon=[1,dx8,dx7,dx6];
    Dir = [0,1/2,1/3,1/4,0,0,0,0];
	Pt0 = [1,1/20,1/10,3/20,1,1,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1/2,-19/14,-1/3,-1/5,-1/11];

    /* an initial value at Z=0 */
	/* see ndata1.txt */
	InitValFloat= [ 1.1950502518607810772538534319502477092478,
					-0.171909714259135548490788881793,
					-0.325127216734103016669951013427,
					-0.465226174603644620219989884764 ];
	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^8;
	End = Start+10*H;
	printf("H=%a\n",H);

	TargetValFloat = [ 1.1950503579873959974893288926466220932073,
					   -0.171909739138021515928791442706,
					   -0.325127273921048994509468169298,
					   -0.465226283864086289370886598026];
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
	printf("TargetVal=%a\n", TargetValFloat);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

def test113() {
	Deval=oh_number.deval;
    A = [[1,1,1,1,0,0,0,0],
       [1,0,0,0,1,0,0,0],
       [0,1,0,0,0,1,0,0],
       [0,0,1,0,0,0,1,0],
       [0,0,0,1,0,0,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; */
    W=[];
    Mset=[1,dx5,dx6,dx7,dx8, 
            dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8,
                                                                   dx8*dx8];

    StdMon=[1,dx8,dx7,dx6];
    Dir = [0,1/2,1/3,1/4,0,0,0,0];
	Pt0 = [1,1/20,1/10,3/20,1,1,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1/2,-19/14,-1/3,-1/5,-1/11];

    /* an initial value at Z=0 */
	/* see ndata2.txt */
	InitValFloat= [ 1.19505025186078955712664300572235872118970085222390413439421,
					-0.1719097142592666327962706769863140069355848346631,
					-0.3251272167341095821098734547768632291192167493124,
					-0.4652261746036490124174695015314618553310166347622];
	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^12;
	End = Start+10*H;
	printf("H=%a\n",H);

	TargetValFloat = [ 1.19505025187140221810829638857678563859063685884558977316613,
					   -0.1719097142617545212428381118370425765918726605528,
					   -0.3251272167398282763191847367312434734359033864699,
					   -0.4652261746145750556601430254764766400183269585405 ];
	// TargetValFloat = [1.30653474526512361790567548176126429002582614030996144986,
	// 				  -0.198372489487087915397232216954501730234040987864606539446,
	// 				  -0.386432835651982983362135481308333777740853851309581833048,
	// 				  -0.584424286257640845566056905386694872409875592930997773923];
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
	printf("TargetVal=%a\n", TargetValFloat);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

// Gauss HGF
def test200() {
	Deval=oh_number.deval;
    A = [[1,1,0,0],
       [1,0,1,0],
		 [0,1,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1]]; */
    W=[];
    Mset=[1,dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,
                  dx2*dx2, dx2*dx3,dx2*dx4,
                           dx3*dx3,dx3*dx4,
  		                           dx4*dx4];

    StdMon=[1,dx4];
    Dir = [0,1/2,0,0];
	Pt0 = [1,1/20,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1,-1,-1];

    /* an initial value at Z=0 (see ndata3.txt) */
    InitValFloat= [ 13797052631578947368421/13107200000000000000000, -7261606648199445983379/6553600000000000000000];
	// [1.05263157894736842105262756347656249999999999999999999999,-1.10803324099722991689743041992187499999999999999999999999];

	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^12;
	End = 10*H;
	printf("H=%a\n",H);
/*
	Fexact = 1/(x4*x1-x2*x3);
	Fexact2 = [ Fexact, diff(Fexact,x4) ]; // diff(Fexact,x4) == -x1 * Fexact^2 
	TargetValFloat = base_replace(Fexact2,assoc([x1,x2,x3,x4],subst(Line,z,End)));
*/
	TargetValFloat = [ 1379705263165156343490337664965729145605074732345285572275499892485660074802556007951592383292376799714275667111022503488080118437736000623258800003275800000017080000000085600000000370000000001/1310720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -726160664827588394809749236270349809456652910757778242833184281533675898114679524301441522168100618712503509959130283259920748021944004264109200024126200000134520000000714400000003230000000009/655360000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
	// [1.05263157895290858725764287183054286621480921352026792318, -1.10803324100889342469749334147697419655861345025295752385]; 
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
	printf("TargetVal=%a\n", TargetValFloat);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

// Gauss HGF
def test201() {
	Deval=oh_number.deval;
    A = [[1,1,0,0],
       [1,0,1,0],
		 [0,1,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1]]; */
    W=[];
    Mset=[1,dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,
                  dx2*dx2, dx2*dx3,dx2*dx4,
                           dx3*dx3,dx3*dx4,
  		                           dx4*dx4];

    StdMon=[1,dx4];
    Dir = [0,1/2,0,0];
	Pt0 = [1,1/20,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1,-1,-1];


	Fexact = 1/(x4*x1-x2*x3);
	Fexact2 = [ Fexact, diff(Fexact,x4) ]; // diff(Fexact,x4) == -x1 * Fexact^2 
	Fexact3 = base_replace(Fexact2,assoc([x1,x2,x3,x4],Line)); // a function of z

    /* an initial value at Z=0 (see ndata3.txt) */
    InitValFloat= [ 13797052631578947368421/13107200000000000000000, -7261606648199445983379/6553600000000000000000];
	// [1.05263157894736842105262756347656249999999999999999999999,-1.10803324099722991689743041992187499999999999999999999999];

//	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End   = 1/10;
	H     = 1/10^3;
	printf("H=%a\n",H);
	TargetValFloat = base_replace(Fexact3,[[z,End]]);

	// TargetValFloat = [ 1379705263165156343490337664965729145605074732345285572275499892485660074802556007951592383292376799714275667111022503488080118437736000623258800003275800000017080000000085600000000370000000001/1310720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -726160664827588394809749236270349809456652910757778242833184281533675898114679524301441522168100618712503509959130283259920748021944004264109200024126200000134520000000714400000003230000000009/655360000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
	// [1.05263157895290858725764287183054286621480921352026792318, -1.10803324100889342469749334147697419655861345025295752385]; 
//	TargetValFloat = 'map'(Deval,TargetValFloat);

//  G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H); // Runge-Kuttta with rational numbers
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
//	printf("TargetVal=%a\n", TargetValFloat);
	printf("TargetVal=%a\n", 'map'(Deval,TargetValFloat));
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

// Quadratic Equation
def test300() {
	Deval=oh_number.deval;
    A = [[1,1,1],
		 [0,1,2]];
/*  W=[[dx1,1,dx2,1,dx3,1]]; */
    W=[];
    Mset=[1,dx1,dx2,dx3,
            dx1*dx1,dx1*dx2, dx1*dx3,
                    dx2*dx2, dx2*dx3,
                             dx3*dx3];

    StdMon= [1,dx3];
    Dir   = [1,1,0];
	Pt0   = [2,-3,1];
    Line  = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat  = [0,-1];

	Fexact  = (-x2+((-4*x3*x1+x2^2)^(1/2)))/(2*x3);
	Fexact2 = [ Fexact, diff(Fexact,x3) ]; // diff(Fexact,x4) == -x1 * Fexact^2 
	Fexact3 = base_replace(Fexact2,assoc([x1,x2,x3],Line)); // a function of z

    /* an initial value at Z=0 (see ndata4.txt) */
//    InitValFloat= [ 13797052631578947368421/13107200000000000000000, -7261606648199445983379/6553600000000000000000];
	// [1.05263157894736842105262756347656249999999999999999999999,-1.10803324099722991689743041992187499999999999999999999999];

//	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
//  InitVal=InitValFloat;
    Start = 0;
//  End = 1/10;
	H = 1/10^12;
//	H = 1/10^4;
//	H = 1/10^3;
    End = Start + 10*H;
	printf("H=%a\n",H);
	InitVal        = base_replace(Fexact3,[[z,Start]]);
//	TargetValFloat = base_replace(Fexact3,[[z,End]]);

	// TargetValFloat = [ 1379705263165156343490337664965729145605074732345285572275499892485660074802556007951592383292376799714275667111022503488080118437736000623258800003275800000017080000000085600000000370000000001/1310720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -726160664827588394809749236270349809456652910757778242833184281533675898114679524301441522168100618712503509959130283259920748021944004264109200024126200000134520000000714400000003230000000009/655360000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
	// [1.05263157895290858725764287183054286621480921352026792318, -1.10803324100889342469749334147697419655861345025295752385]; 
//	TargetValFloat = 'map'(Deval,TargetValFloat);

	TargetValFloat = [ 1.9999999999699999999993999999999699999998735990802, -4.0000000000800000000073000000006170000004276327526];

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
//	printf("TargetVal=%a\n", TargetValFloat);
	printf("TargetVal=%a\n", 'map'(Deval,TargetValFloat));
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

def my_abs(A) {
	return (A<0)? -A: A;
}

def test301() {
	Deval=oh_number.deval;
    A = [[1,1,1],
		 [0,1,2]];
/*  W=[[dx1,1,dx2,1,dx3,1]]; */
    W=[];
    Mset=[1,dx1,dx2,dx3,
            dx1*dx1,dx1*dx2, dx1*dx3,
                    dx2*dx2, dx2*dx3,
                             dx3*dx3];

    StdMon= [1,dx3];
    Dir   = [1,1,0];
	Pt0   = [2,-3,1];
    Line  = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat  = [0,-1];

	Fexact  = (-x2+((-4*x3*x1+x2^2)^(1/2)))/(2*x3);
	Fexact2 = [ Fexact, diff(Fexact,x3) ]; // diff(Fexact,x4) == -x1 * Fexact^2 
	Fexact3 = base_replace(Fexact2,assoc([x1,x2,x3],Line)); // a function of z

    /* an initial value at Z=0 (see ndata4.txt) */
//    InitValFloat= [ 13797052631578947368421/13107200000000000000000, -7261606648199445983379/6553600000000000000000];
	// [1.05263157894736842105262756347656249999999999999999999999,-1.10803324099722991689743041992187499999999999999999999999];

//	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
//  InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^4;
//  End = Start + 10*H;
	printf("H=%a\n",H);
	InitVal        = base_replace(Fexact3,[[z,Start]]);
	InitVal        = 'map'(Deval,InitVal);
	TargetValFloat = base_replace(Fexact3,[[z,End]]);
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
//	printf("TargetVal=%a\n", TargetValFloat);
	printf("TargetVal=%a\n", 'map'(Deval,TargetValFloat));
	Error = vtol(Val[1]-ltov(TargetValFloat));
	Error = map(number_abs,Error);
	printf("Error=%a\n",Error);
	return Val;
}

// tk_fd.rr との比較
def test_fd_conti() {
    A = [[1,1,1,1,0,0,0,0],
         [0,0,0,0,1,1,1,1],
         [1,0,0,0,1,0,0,0],
         [0,1,0,0,0,1,0,0],
         [0,0,1,0,0,0,1,0]];
    StdMon=[1,dx6,dx7,dx8];
    B= [-6, -7, -8];
    C = 11; 
    AA = -1;
    Beta = [ -AA, C-1-B[0]-B[1]-B[2], C-AA-1, -B[0], -B[1]];

    ContiDir = [1,0,0,0,0,0,0,0]; /* 後で仕様変更の予定 */
    ContiDir = 0; /* A の第 ContiDir 列, ここでは、[1,0,1,0,0] */
    Z = n;
    X0 = [1,1/2,1/3,2/3,1,1,1,1];

    F3= 1/530941398220800000;
    F0=((x1*x5^10*x6^6+6/11*x2*x5^11*x6^5)*x7^7+7/11*x3*x5^11*x6^6*x7^6)*x8^8+8/11*x4*x5^11*x6^6*x7^7*x8^7;
    FD=F3*F0;
    // 多項式 FD は tk_fd.rr で 
    // F=tk_fd.fdah(-1,[-6,-7,-8],11,[[x1,x2,x3,x4],[x5,x6,x7,x8]] | approx=2);
    // FD=F[0]*F[3];
    // として得られるもの。

    F = [FD, diff(FD,x6), diff(FD,x7), diff(FD,x8)];
    X = [x1,x2,x3,x4,x5,x6,x7,x8];
    InitVal = base_replace(F, assoc(X,X0));
    printf("InitVal=%a\n",InitVal);
    TargetVal = 20619719775296069983/1485016175797062568226097734422134899343360000000000;
    // tk_fd.rr で A==-20 のときに得られる関数値(比較のため)

    Line = [ContiDir, Beta, Z];
//  printf("Line=%a\n",Line);

    Val = hgm_ahg_contiguity(A,StdMon,Line,X0,InitVal,0,19);
    printf("Val = %a\n", Val);
    printf("Check: %a\n", Val[0]==TargetVal? "true": "false");
    return Val;
}

def test_fd_conti2() {
    A = [[1,1,1,1,0,0,0,0],
         [0,0,0,0,1,1,1,1],
         [1,0,0,0,1,0,0,0],
         [0,1,0,0,0,1,0,0],
         [0,0,1,0,0,0,1,0]];
    StdMon=[1,dx6,dx7,dx8];
    Beta = [20,31,30,6,7]; /* Target */
    X0 = [1,1/2,1/3,2/3,1,1,1,1];
    printf("at X=%a\n",X0);
    TargetVal = 20619719775296069983/1485016175797062568226097734422134899343360000000000;
    printf("TargetVal=%a\n",TargetVal);
    // tk_fd.rr で AA==-20 (Beta = [20,31,30,6,7]) のときに得られる関数値(比較のため)

    Val =hgm_ahg_evaluation_contiguity(A,Beta,X0);
    printf("Val = %a\n", Val);
    printf("Check: %a\n", Val==TargetVal? "true": "false");
    return Val;
}

def test_fd_conti3() {
    A = [[1,1,1,1,0,0,0,0],
         [0,0,0,0,1,1,1,1],
         [1,0,0,0,1,0,0,0],
         [0,1,0,0,0,1,0,0],
         [0,0,1,0,0,0,1,0]];
    StdMon=[1,dx6,dx7,dx8];
    Beta = [3,12,6,3,3]; /* Target: FD の A=-3,B=[-3,-3,-3],C=4に対応? */
    X0 = [1,1/2,1/3,1/4,1,1,1,1];
    printf("at X=%a\n",X0);
    RandomVars = [x5,x6,x7,x8];
    TargetVals = [721230/173593,430653/173593,458271/173593,67566/24799];
    printf("TargetVals=%a\n",TargetVals);

	Val = hgm_ahg_expected_values_contiguity(A,Beta,X0,RandomVars);
	printf("RandomVars: %a\n", RandomVars);
	printf("Val = %a\n", Val);
	printf("Check: %a\n", Val==TargetVals? "true": "false");
    return Val;
}

def test_fd_conti4() {
	/* see result of tk_fd.abc2ahg(-3,[-2,-4],3); */
	A=[[0,0,0,1,1,1],
	   [1,0,0,1,0,0],
	   [0,1,0,0,1,0],
	   [0,0,1,0,0,1]];
	Beta=[8,5,2,4]; /* Target: FD の A=-3,B=[-2,-4],C=3に対応 */
	X0=[1,1/2,1/3,1,1,1];
    StdMon=[1,dx6,dx5];
    printf("at X=%a\n",X0);
    RandomVars = [x4,x4*x5];
    TargetVals = [15200/4939,22480/4939];
    printf("TargetVals=%a\n",TargetVals);


    /* 
	   F=tk_fd.fdah(-3,[-2,-4],3,[[x1,x2,x3],[x4,x5,x6]])[0];
	   F=(x1^3*x4^2*x5^2+2*x1^2*x2*x4^3*x5+1/2*x1*x2^2*x4^4)*x6^4+(4*x1^2*x3*x4^3*x5^2+4*x1*x2*x3*x4^4*x5)*x6^3+3*x1*x3^2*x4^4*x5^2*x6^2;
    */
	
	Val = hgm_ahg_expected_values_contiguity(A,Beta,X0,RandomVars);
	printf("RandomVars: %a\n", RandomVars);
	printf("Val = %a\n", Val);
	printf("Check: %a\n", Val==TargetVals? "true": "false");
    return Val;
}

// hgpoly.rr / check21(), check21b() も参照のこと。
def test_c111_conti() {
    At=[[1,0,0],[0,1,0],[0,0,1],[1,1,0],[1,0,1],[0,1,1],[1,1,1]];
    A=matrix_matrix_to_list(matrix_transpose(At));
    // A = [[1,0,0,1,1,0,1],[0,1,0,1,0,1,1],[0,0,1,0,1,1,1]]
    StdMon=[1,dx4,dx5,dx6,dx7,dx7^2];
    Beta = [1,1,1];
    ContiDir = 6; /* A の第 ContiDir 列, ここでは、[1,1,1] */
    Z = n;
    X  = [x1,x2,x3,x4,x5,x6,x7];
    X0 = [1,1/2,1/3,2/3,1,1,1];

    // hgpoly.rr / check21b()[0]
    F0=(x3*x1+x5)*x2+x6*x1+x4*x3+x7;
    F1=(1/13824*x3^4*x2^4+1/864*x6*x3^3*x2^3+1/192*x6^2*x3^2*x2^2+1/144*x6^3*x3*x2+1/576*x6^4)*x1^4+(1/864*x5*x3^3*x2^4+(1/864*x4*x3^4+1/216*x7*x3^3+1/72*x6*x5*x3^2)*x2^3+(1/72*x6*x4*x3^3+1/24*x7*x6*x3^2+1/24*x6^2*x5*x3)*x2^2+(1/24*x6^2*x4*x3^2+1/12*x7*x6^2*x3+1/36*x6^3*x5)*x2+1/36*x6^3*x4*x3+1/36*x7*x6^3)*x1^3+(1/192*x5^2*x3^2*x2^4+(1/72*x5*x4*x3^3+1/24*x7*x5*x3^2+1/24*x6*x5^2*x3)*x2^3+(1/192*x4^2*x3^4+1/24*x7*x4*x3^3+(1/8*x6*x5*x4+1/16*x7^2)*x3^2+1/4*x7*x6*x5*x3+1/16*x6^2*x5^2)*x2^2+(1/24*x6*x4^2*x3^3+1/4*x7*x6*x4*x3^2+(1/4*x6^2*x5*x4+1/4*x7^2*x6)*x3+1/4*x7*x6^2*x5)*x2+1/16*x6^2*x4^2*x3^2+1/4*x7*x6^2*x4*x3+1/12*x6^3*x5*x4+1/8*x7^2*x6^2)*x1^2+(1/144*x5^3*x3*x2^4+(1/24*x5^2*x4*x3^2+1/12*x7*x5^2*x3+1/36*x6*x5^3)*x2^3+(1/24*x5*x4^2*x3^3+1/4*x7*x5*x4*x3^2+(1/4*x6*x5^2*x4+1/4*x7^2*x5)*x3+1/4*x7*x6*x5^2)*x2^2+(1/144*x4^3*x3^4+1/12*x7*x4^2*x3^3+(1/4*x6*x5*x4^2+1/4*x7^2*x4)*x3^2+(x7*x6*x5*x4+1/6*x7^3)*x3+1/4*x6^2*x5^2*x4+1/2*x7^2*x6*x5)*x2+1/36*x6*x4^3*x3^3+1/4*x7*x6*x4^2*x3^2+(1/4*x6^2*x5*x4^2+1/2*x7^2*x6*x4)*x3+1/2*x7*x6^2*x5*x4+1/6*x7^3*x6)*x1+1/576*x5^4*x2^4+(1/36*x5^3*x4*x3+1/36*x7*x5^3)*x2^3+(1/16*x5^2*x4^2*x3^2+1/4*x7*x5^2*x4*x3+1/12*x6*x5^3*x4+1/8*x7^2*x5^2)*x2^2+(1/36*x5*x4^3*x3^3+1/4*x7*x5*x4^2*x3^2+(1/4*x6*x5^2*x4^2+1/2*x7^2*x5*x4)*x3+1/2*x7*x6*x5^2*x4+1/6*x7^3*x5)*x2+1/576*x4^4*x3^4+1/36*x7*x4^3*x3^3+(1/12*x6*x5*x4^3+1/8*x7^2*x4^2)*x3^2+(1/2*x7*x6*x5*x4^2+1/6*x7^3*x4)*x3+1/8*x6^2*x5^2*x4^2+1/2*x7^2*x6*x5*x4+1/24*x7^4;

    F = [F0, diff(F0,x4), diff(F0,x5), diff(F0,x6), diff(F0,x7), diff(F0,x7,x7)];
    printf("F=%a\n",F);
    InitVal = base_replace(F, assoc(X,X0));
    TargetVal = base_replace(F1, assoc(X,X0));
    printf("InitVal=%a\n",InitVal);

    Line = [ContiDir, Beta, Z];
//  printf("Line=%a\n",Line);

    Val = hgm_ahg_contiguity(A,StdMon,Line,X0,InitVal,0,3);
    printf("Val = %a\n", Val);
    printf("Check: %a\n", Val[0]==TargetVal? "true": "false");
    return Val;
}

// hgpoly.rr / check21(), check21b() も参照のこと。
def test_c111_ev() {
    At=[[1,0,0],[0,1,0],[0,0,1],[1,1,0],[1,0,1],[0,1,1],[1,1,1]];
    A=matrix_matrix_to_list(matrix_transpose(At));
    // A = [[1,0,0,1,1,0,1],[0,1,0,1,0,1,1],[0,0,1,0,1,1,1]]
    StdMon=[1,dx4,dx5,dx6,dx7,dx7^2];
    Beta = [1,1,1];
    ContiDir = 6; /* A の第 ContiDir 列, ここでは、[1,1,1] */
    Z = n;
    X  = [x1,x2,x3,x4,x5,x6,x7];
    X0 = [1,1/2,1/3,2/3,1,1,1];

    // hgpoly.rr / check21b()[0]
    F0=(x3*x1+x5)*x2+x6*x1+x4*x3+x7;
    F1=(1/13824*x3^4*x2^4+1/864*x6*x3^3*x2^3+1/192*x6^2*x3^2*x2^2+1/144*x6^3*x3*x2+1/576*x6^4)*x1^4+(1/864*x5*x3^3*x2^4+(1/864*x4*x3^4+1/216*x7*x3^3+1/72*x6*x5*x3^2)*x2^3+(1/72*x6*x4*x3^3+1/24*x7*x6*x3^2+1/24*x6^2*x5*x3)*x2^2+(1/24*x6^2*x4*x3^2+1/12*x7*x6^2*x3+1/36*x6^3*x5)*x2+1/36*x6^3*x4*x3+1/36*x7*x6^3)*x1^3+(1/192*x5^2*x3^2*x2^4+(1/72*x5*x4*x3^3+1/24*x7*x5*x3^2+1/24*x6*x5^2*x3)*x2^3+(1/192*x4^2*x3^4+1/24*x7*x4*x3^3+(1/8*x6*x5*x4+1/16*x7^2)*x3^2+1/4*x7*x6*x5*x3+1/16*x6^2*x5^2)*x2^2+(1/24*x6*x4^2*x3^3+1/4*x7*x6*x4*x3^2+(1/4*x6^2*x5*x4+1/4*x7^2*x6)*x3+1/4*x7*x6^2*x5)*x2+1/16*x6^2*x4^2*x3^2+1/4*x7*x6^2*x4*x3+1/12*x6^3*x5*x4+1/8*x7^2*x6^2)*x1^2+(1/144*x5^3*x3*x2^4+(1/24*x5^2*x4*x3^2+1/12*x7*x5^2*x3+1/36*x6*x5^3)*x2^3+(1/24*x5*x4^2*x3^3+1/4*x7*x5*x4*x3^2+(1/4*x6*x5^2*x4+1/4*x7^2*x5)*x3+1/4*x7*x6*x5^2)*x2^2+(1/144*x4^3*x3^4+1/12*x7*x4^2*x3^3+(1/4*x6*x5*x4^2+1/4*x7^2*x4)*x3^2+(x7*x6*x5*x4+1/6*x7^3)*x3+1/4*x6^2*x5^2*x4+1/2*x7^2*x6*x5)*x2+1/36*x6*x4^3*x3^3+1/4*x7*x6*x4^2*x3^2+(1/4*x6^2*x5*x4^2+1/2*x7^2*x6*x4)*x3+1/2*x7*x6^2*x5*x4+1/6*x7^3*x6)*x1+1/576*x5^4*x2^4+(1/36*x5^3*x4*x3+1/36*x7*x5^3)*x2^3+(1/16*x5^2*x4^2*x3^2+1/4*x7*x5^2*x4*x3+1/12*x6*x5^3*x4+1/8*x7^2*x5^2)*x2^2+(1/36*x5*x4^3*x3^3+1/4*x7*x5*x4^2*x3^2+(1/4*x6*x5^2*x4^2+1/2*x7^2*x5*x4)*x3+1/2*x7*x6*x5^2*x4+1/6*x7^3*x5)*x2+1/576*x4^4*x3^4+1/36*x7*x4^3*x3^3+(1/12*x6*x5*x4^3+1/8*x7^2*x4^2)*x3^2+(1/2*x7*x6*x5*x4^2+1/6*x7^3*x4)*x3+1/8*x6^2*x5^2*x4^2+1/2*x7^2*x6*x5*x4+1/24*x7^4;

    F = [F0, diff(F0,x4), diff(F0,x5), diff(F0,x6), diff(F0,x7), diff(F0,x7,x7)];
    printf("F=%a\n",F);
    InitVal = base_replace(F, assoc(X,X0));
    TargetVal = base_replace(F1, assoc(X,X0));
    printf("InitVal=%a\n",InitVal);

    Line = [ContiDir, Beta, Z];
//  printf("Line=%a\n",Line);

    Item=2;
    Val = hgm_ahg_expected_value_contiguity0(A,StdMon,Line,X0,InitVal,0,3,Item);
    printf("EV = %a = %a\n", Val, deval(Val));
    return Val;
}

/* How to use test functions.

setprec(30);              // specifying precision for pari's floating point number
pari(allocatemem,10^7);   // alocating  stack memory for pari
ctrl("real_digit",16);
load("ot_hgm_ahg.rr");
test112();
test113();
test200();
test201();
test301();

test_c111c_conti();
test_fd_conti();
 */

/*-----------------*/
/* 2015.01.16 N.T. */
/*-----------------*/
/* configuration matrix case, 2015.01.16 */
def test_c111c_conti() {
  A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
    StdMon=[1,dx5,dx6,dx7,dx8,dx8^2];
    Beta = [3,2,1,1];
    ContiDir = 7; /* A の第 ContiDir 列, ここでは、[1,1,1,1] */
    Z = n;
    X  = [x1,x2,x3,x4,x5,x6,x7,x8];
    X_  = [x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8];
    X0 = [1,1/2,1/3,2/3,1,1,1,1];

    F0=base_replace(tk_hgpoly.hgpoly(A,Beta)[0],assoc(X_,X));

    F = [F0, diff(F0,x5), diff(F0,x6), diff(F0,x7), diff(F0,x8), diff(F0,x8,x8)];
    printf("F=%a\n",F);
    InitVal = base_replace(F, assoc(X,X0));
    printf("InitVal=%a\n",InitVal);

    Line = [ContiDir, Beta, Z];
//  printf("Line=%a\n",Line);

    for (I=0; I<100; I += 10) {
      T0=time();
      Val = hgm_ahg_contiguity(A,StdMon,Line,X0,InitVal,0,I); 
      printf("Step=%a, Val = %a\n", I,Val);
      T1=time();
      printf("CPU=%a, GC=%a, Total=%a\n",T1[0]-T0[0],T1[1]-T0[1],T1[0]-T0[0]+T1[1]-T0[1]);
    }
    return Val;
}

/* 2015.01.17 */
def test_gauss_conti() {
  A = [[1,1,1,1],
       [0,1,0,1],
       [0,0,1,1]];
  StdMon=[1,dx4];
  Beta = [3,2,1];
    ContiDir = 3; /* A の第 ContiDir 列, ここでは、[1,1,1] */
    Beta1=[2,1,0];
    Z = k;
    X  = [x1,x2,x3,x4];
    X_  = [x_1,x_2,x_3,x_4];
    X0 = [1,1,1/2,1];

    Z0=tk_hgpoly.hgpoly(A,Beta)[0];
    F0=base_replace(Z0,assoc(X_,X));
    Z1=base_replace(tk_hgpoly.hgpoly(A,Beta1)[0],assoc(X_,X));

    F = [F0, diff(F0,x4)];
    F1 = [Z1,diff(Z1,x4)];
    printf("F=%a, F1=%a\n",F,F1);
    InitVal = base_replace(F, assoc(X,X0));
    printf("InitVal=%a\n",InitVal);

    Line = [ContiDir, Beta, Z];

    ForPaper=1;
    Val = hgm_ahg_contiguity(A,StdMon,Line,X0,InitVal,0,I); 
    printf("Step=%a, Val = %a\n", I,Val);

    R=newvect(2,base_replace(F1,assoc(X,X0)))-
      base_replace(ForPaper_data1,[[k,0]])*newvect(2,InitVal);
    return R;
}

/* 2015.01.19 
  test_c111c_conti2(|check=NN) is OK for NN=1; NN=2.
  test_c111c_conti2(|check=10,start=10); 
  test_c111c_conti2(|check=10,start=10,p=[1,1,1,1,1,1,1,100]); -> singular
  test_c111c_conti2(|check=10,start=10,p=[1,1/2,1/3,2/3,1,1,1,100]); 
%%Note: 22-my-note-a-hg2-so-moment.pdf
*/
def test_c111c_conti2() {
    if (type(getopt(check))>=0) Check=getopt(check);
    else Check=0;
    if (type(getopt(start))>=0) Start=getopt(start);
    else Start=0;
    if (type(getopt(p))>=0) X0=getopt(p);
    else X0=[1,1/2,1/3,2/3,1,1,1,1];
  A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
    StdMon=[1,dx5,dx6,dx7,dx8,dx8^2];
    Beta = [3,2,1,1];
    ContiDir = 7; /* A の第 ContiDir 列, ここでは、[1,1,1,1] */
    Z = n;
    X  = [x1,x2,x3,x4,x5,x6,x7,x8];
    X_  = [x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8];
   
    F0=base_replace(tk_hgpoly.hgpoly(A,Beta)[0],assoc(X_,X));

    F = [F0, diff(F0,x5), diff(F0,x6), diff(F0,x7), diff(F0,x8), diff(F0,x8,x8)];
    printf("F=%a\n",F);
    InitVal = base_replace(F, assoc(X,X0));
    printf("InitVal=%a\n",InitVal);

    Line = [ContiDir, Beta, Z];
    if (Check) {
      Step = 1; NN=Check;
    }else {
      Step = 10; NN=100;
    }

    Zvalues=[]; Data=[];
    for (I=Start; I<=NN; I += Step) {
      T0=time();
      Val = hgm_ahg_contiguity(A,StdMon,Line,X0,InitVal,0,I); 
      printf("Step=%a, Val = %a\n", I,Val);
      NewBeta = [3+I,2+I,1+I,1+I];
      Line2 = [0, NewBeta, Z]; /* ContiDir=[1,0,0,0] */ 
      Val = hgm_ahg_contiguity(A,StdMon,Line2,X0,Val,0,2*I); 
      /* Value at [3,2,1,1] + [3*I,I,I,I] */
      T1=time();
      Ttime = T1[0]-T0[0]+T1[1]-T0[1];
      printf("I=%a, CPU=%a, GC=%a, Total=%a\n",I,T1[0]-T0[0],T1[1]-T0[1],Ttime);
      printf("Value=%a\n",Val);
      Zvalues=cons(Val[0],Zvalues);
      Data=cons([I,Ttime],Data);
    }
    ForPaper_data2=[reverse(Zvalues),reverse(Data)];
    if (Check) {
      printf("I=%a, Val=%a\n", I-1,Val);
      for (J=1; J<5; J++){
        printf("E_%a=Val[%a]/Val[0]=%a=%a\n",J+4,J,X0[J+3]*Val[J]/Val[0],deval(X0[J+3]*Val[J]/Val[0]));
      }
      if (Start > 0) return(Val);
      Beta = vtol(newvect(4,Beta)+newvect(4,[NN*3,NN,NN,NN]));
      F0=base_replace(tk_hgpoly.hgpoly(A,Beta)[0],assoc(X_,X));
      F = [F0, diff(F0,x5), diff(F0,x6), diff(F0,x7), diff(F0,x8), diff(F0,x8,x8)];
      printf("F=%a\n",F);
      Val2 = base_replace(F, assoc(X,X0));
      printf("If the return value is zero, the result is OK.\n");
      return(newvect(6,Val)-newvect(6,Val2));
    }
    return Val;
}

/* contingency table 2015.01.23. cf. A-hg/Prog/hgpoly.rr */
#define OT_IDX(I,J) (R*I+J)
def ot_esum(L) {
  return base_sum(L,0,0,length(L)-1);
}
def contingency2(Q,R) {
  A=[];
  N=Q*R;
  for (J=0; J<Q; J++) {
      L = newvect(N);
      for (K=0; K<R; K++) L[OT_IDX(J,K)] = 1;
      if (ot_esum(L) > 1) A=cons(vtol(L),A);
   }
   for (K=0; K<R; K++) {
      L = newvect(N);
      for (J=0; J<Q; J++) L[OT_IDX(J,K)] = 1;
      if (ot_esum(L)>1) A=cons(vtol(L),A);
   }
   return cdr(reverse(A));
}

def test433() {
  A = contingency2(3,3);
  printf("Std=%a\n",Std=cbase(A));
  V=[x1,x2,x3,x4,x5,x6,x7,x8,x9];
  DV=[dx1,dx2,dx3,dx4,dx5,dx6,dx7,dx8,dx9];
  Vb=[b_1,b_2,b_3,b_4,b_5];
  One=newvect(9); for (I=0; I<9; I++) One[I]=1; 
  One=vtol(One);
  W=[assoc(DV,One)];
  Mset=append([1],DV);
  Disc_R=get_mat(A,W,Std,Mset);
  printf("size of R is %a\n",size(Disc_R));
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return matrix_rank(base_replace(Disc_R,R1));
}
def test434() {
  A = contingency2(3,4);
  printf("Std=%a\n",Std=cbase(A));
  V=[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12];
  DV=[dx1,dx2,dx3,dx4,dx5,dx6,dx7,dx8,dx9,dx10,dx11,dx12];
  Vb=[b_1,b_2,b_3,b_4,b_5,b_6];
  One=newvect(12); for (I=0; I<12; I++) One[I]=1; 
  One=vtol(One);
  W=[assoc(DV,One)];
  Mset=append([1],DV);
  Disc_R=get_mat(A,W,Std,Mset);
  printf("size of R is %a\n",size(Disc_R));
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return matrix_rank(base_replace(Disc_R,R1));
}

def test_33_conti() {
    if (type(getopt(start))>=0) Start=getopt(start);
    else Start=0;
    if (type(getopt(step))>=0) Step=getopt(step);
    else Step=1;
    if (type(getopt(nn))>=0) NN=getopt(nn);
    else NN=1;
    if (type(getopt(p))>=0) X0=getopt(p);
    else X0=[1,1/2,1/3,
             1,2/3,1/5,
             1,1,1];

    printf("Options: start=%a, nn=%a, step=%a\n",Start,NN,Step); 
    A=contingency2(3,3);
    StdMon=reverse(cbase(A));
    printf("StdMon=%a\n",StdMon);
    Beta = [3,3,3,2,2];
    ContiDir = 7; /* A の第 ContiDir 列, ここでは、[0,1,0,1,0] */
    Z = n;
    X  = [x1,x2,x3,x4,x5,x6,x7,x8,x9];
    X_  = [x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9];
   
    // F0=base_replace(tk_hgpoly.hgpoly(A,Beta)[0],assoc(X_,X));
    // より早い hgpoly を作成すべき. ker の基底を用いる.
    F0=((1/4*x1*x4^2*x5+1/12*x2*x4^3)*x8+(1/4*x1*x4*x5^2+1/4*x2*x4^2*x5)*x7)*x9^2+((1/4*x1*x4^2*x6+1/12*x3*x4^3)*x8^2+((x1*x4*x5+1/2*x2*x4^2)*x6+1/2*x3*x4^2*x5)*x7*x8+((1/4*x1*x5^2+1/2*x2*x4*x5)*x6+1/4*x3*x4*x5^2)*x7^2)*x9+(1/4*x1*x4*x6^2+1/4*x3*x4^2*x6)*x7*x8^2+((1/4*x1*x5+1/4*x2*x4)*x6^2+1/2*x3*x4*x5*x6)*x7^2*x8+(1/12*x2*x5*x6^2+1/12*x3*x5^2*x6)*x7^3;
    printf("F0=%a\n",F0);

    // F = [F0, diff(F0,x5), diff(F0,x6), diff(F0,x7), diff(F0,x8), diff(F0,x8,x8)];
    F = map(odiff_act,StdMon,F0,X);
    printf("F=%a\n",F);
    InitVal = base_replace(F, assoc(X,X0));
    printf("InitVal=%a\n",InitVal);

    Line = [ContiDir, Beta, Z];

    Zvalues=[]; Data=[];
    for (I=Start; I<=NN; I += Step) {
      T0=time();
      Val = hgm_ahg_contiguity(A,StdMon,Line,X0,InitVal,0,I); 
      printf("Step=%a, Val = %a\n", I,Val);
      T1=time();
      Ttime = T1[0]-T0[0]+T1[1]-T0[1];
      printf("I=%a, CPU=%a, GC=%a, Total=%a\n",I,T1[0]-T0[0],T1[1]-T0[1],Ttime);
      printf("Value=%a\n",Val);
      Zvalues=cons(Val[0],Zvalues);
      Data=cons([I,Ttime],Data);
    }
    ForPaper_data2=[reverse(Zvalues),reverse(Data)];
    printf("Options: start=%a, nn=%a, step=%a\n",Start,NN,Step); 
    return Val;
}

/* 2015.02.02.
    下記は変. 意外とむつかしい. 直接計算した方が簡単.
 */
def test_222_conti() {
    if (type(getopt(start))>=0) Start=getopt(start);
    else Start=0;
    if (type(getopt(step))>=0) Step=getopt(step);
    else Step=1;
    if (type(getopt(nn))>=0) NN=getopt(nn);
    else NN=1;
    if (type(getopt(p))>=0) X0=getopt(p);
    else X0=[1,1/2,1/3,
             1,2/3,1/5,
             1,1,1];

    printf("Options: start=%a, nn=%a, step=%a\n",Start,NN,Step); 
    A=tk_hgpoly.contingency3(2,2,2);  // この A は 余分な行あり.
    // StdMon=reverse(cbase(A));  // 1 を戻す. 余分な行があるため.
    StdMon=[dx2*dx3*dx5*dx8];  // mytoric(A,0); よりの手動.
    printf("StdMon=%a\n",StdMon);
    Data=[19,132,0,9,11,52,6,97];  /* Dinwoodie, Matsusevich, Mosteig, 2004 p.293 Example 3.2 */
    Beta=matrix_list_to_matrix(A)*newvect(length(Data),Data);
    Beta = vtol(Beta);
    return(Beta);
    ContiDir = 4; 
   /* A の第 ContiDir 列, ここでは、[0,0,1,0,0,0,1,0,1,0,0,0] 
        これでいいのか? まだ途中. Todo, 分解が必要だと思う.
   */
    Z = n;
    X  = [x1,x2,x3,x4,x5,x6,x7,x8];
    X_  = [x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8];
   
    F0=base_replace(tk_hgpoly.hgpoly(A,Beta)[0],assoc(X_,X));
    printf("F0=%a\n",F0);

    // F = [F0, diff(F0,x5), diff(F0,x6), diff(F0,x7), diff(F0,x8), diff(F0,x8,x8)];
    F = map(odiff_act,StdMon,F0,X);
    printf("F=%a\n",F);
    InitVal = base_replace(F, assoc(X,X0));
    printf("InitVal=%a\n",InitVal);

    Line = [ContiDir, Beta, Z];

    Zvalues=[]; Data=[];
    for (I=Start; I<=NN; I += Step) {
      T0=time();
      Val = hgm_ahg_contiguity(A,StdMon,Line,X0,InitVal,0,I); 
      printf("Step=%a, Val = %a\n", I,Val);
      T1=time();
      Ttime = T1[0]-T0[0]+T1[1]-T0[1];
      printf("I=%a, CPU=%a, GC=%a, Total=%a\n",I,T1[0]-T0[0],T1[1]-T0[1],Ttime);
      printf("Value=%a\n",Val);
      Zvalues=cons(Val[0],Zvalues);
      Data=cons([I,Ttime],Data);
    }
    ForPaper_data2=[reverse(Zvalues),reverse(Data)];
    printf("Options: start=%a, nn=%a, step=%a\n",Start,NN,Step); 
    return Val;
}

/* 2015.02.21 */
def myAddD(X) {
  return(eval_str("d"+rtostr(X)));
}
/*
hypergeometric bfunction defined by Mutsumi Saito
for the direction Idx = 0,1,2, ...
 */
def hg_bfct(A,Idx) {
  T0=time();
  if (type(getopt(geometric)) > 0) {
    return( [hg_bfct_geom(A,Idx | option_list=getopt())] );
  }
  D = length(A);
  N = length(A[0]);
  Svec = newvect(D);
  DSvec = newvect(D);
  for (I=0; I<D; I++) {
    Svec[I] = util_v(b,[I+1]);
    DSvec[I] = util_v(db,[I+1]);
  }
  MSvec = vtol(-Svec); Svec=vtol(Svec);
  DSvec = vtol(DSvec);
  H = tk_sm1emu.gkz([A,MSvec]);
  V = H[1];
  DV = map(myAddD,V);
  VV = append(V,Svec);
  DVV = append(DV,DSvec);
  W = newvect(2*(N+D));
  for (I=0; I<2*(N+D); I++) W[I]=1;
  for (I=N; I<(N+D); I++) W[I]=0;
  M = poly_weight_to_omatrix(vtol(W),append(VV,DVV));
  alert(["hg_bfct: M=%a\n",M]);
  B = nd_weyl_gr(cons(DV[Idx],H[0]),append(VV,DVV),0,M);
  alert(["hg_bfct: B=%a\n",B]);
  Bf = poly_elimination_ideal(B,Svec | grobner_basis=1);
  T0=print_time("hg_bfct",T0);
  return(map(fctr_flatly,Bf));
}
/*
G=tk_sm1emu.gkz([ [[1,1,1],[0,1,2]], [-s1,-s2]]);
M=poly_weight_to_omatrix([1,1,1,0,0,1,1,1,1,1],[x1,x2,x3,s1,s2,dx1,dx2,dx3,ds1,ds2]);
[ 1 1 1 0 0 1 1 1 1 1 ]
[ 1 1 1 1 1 1 1 1 1 1 ]
[ 0 0 0 0 0 0 0 0 0 -1 ]
[ 0 0 0 0 0 0 0 0 -1 0 ]
[ 0 0 0 0 0 0 0 -1 0 0 ]
[ 0 0 0 0 0 0 -1 0 0 0 ]
[ 0 0 0 0 0 -1 0 0 0 0 ]
[ 0 0 0 0 -1 0 0 0 0 0 ]
[ 0 0 0 -1 0 0 0 0 0 0 ]
[ 0 0 -1 0 0 0 0 0 0 0 ]
[ 0 -1 0 0 0 0 0 0 0 0 ]
[ -1 0 0 0 0 0 0 0 0 0 ]
[2361] B=nd_weyl_gr(cons(dx1,G[0]),[x1,x2,x3,s1,s2,dx1,dx2,dx3,ds1,ds2],0,M);
[-4*s1^2+(4*s2+2)*s1-s2^2-s2,dx1,2*dx2*s1-dx2*s2-dx2,dx3*x3+s1-s2,dx2^2,dx2*x2-2*s1+s2]
[2362] B[0];
-4*s1^2+(4*s2+2)*s1-s2^2-s2
[2363] fctr(B[0]);
[[-1,1],[2*s1-s2,1],[2*s1-s2-1,1]]
 */

def testbfct111() {
  A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
  Blist=[];
  for (I=0; I<length(A[0]); I++) {
    Bf = hg_bfct(A,I);
    printf("%a : bfct=%a\n",I,Bf);
    Blist = cons(Bf,Blist);
  }
  return(reverse(Blist));
}

/* 2015.05.18.  b-function by geometry. */
def make_primitive(Facet,Ap) {
  N = length(Ap);
  Facet = matrix_list_to_matrix(Facet);
  Dn = 1;
  for (I=0; I<length(Facet); I++) {
    Dn = Dn*dn(Facet[I])/gcd(Dn,dn(Facet[I]));
  }
  Facet = Dn*Facet;
  // return(Facet);
  Sign=0;
  for (I=0; I<N; I++) {
    V = matrix_inner_product(Facet,Ap[I]);
    if (V < 0) Sign=1;
  }
  if (Sign) Facet = -Facet;
  D = 0;
  for (I=0; I<N; I++) {
    H = matrix_inner_product(Facet,Ap[I]);
    D = gcd(H,D); 
  }
  return(vtol(Facet/D));
}

def hg_bfct_geom(A,Idx) {
  T0=time();
  if (type(getopt(facet_only)) > 0) Facet_only=1; else Facet_only=0;
  stop_on_windows();
  if (!Start_pm) {
    polymake.start(|oohg_curl=1);
    Start_pm=1;
  }
  Ap = matrix_matrix_to_list(matrix_transpose(A));
  F = polymake.polymake("FACETS","POINTS",Ap);
  F = map(make_primitive,F,Ap);
/* 
  hg_bfct_geom([[1,1,1,1],[0,1,2,3]],0);
*/
  F2=[];  
  HT=[]; /* Height */
  for (I=0; I<length(F); I++) {
    FV = F[I];
    if ((V=matrix_inner_product(F[I],Ap[Idx])) != 0) {
      if (V < 0) { FV = newvect(length(FV),FV); FV = -FV; FV = vtol(FV); V=-V;}
      F2 = cons(FV,F2); 
      HT = cons(V,HT);
    }
  }
  // printf("HT=%a\n",HT);
  /* F2 is a factor of hg-b-function */
  V = newvect(length(F2[0]));
  for (I=0; I<length(V); I++) V[I] = util_v("b",[I+1]);
  Bf = [];
  for (I=0; I<length(F2); I++) {
    if (Facet_only) Bf = cons(matrix_inner_product(V,F2[I]),Bf);
    else {
      for (J=0; J<HT[I]; J++) {
        Bf = cons(matrix_inner_product(V,F2[I])-J,Bf);
      }
    }
  }
  T0=print_time("hg_bfct_geom",T0);
  return(Bf);
}

def fctr_flatly(F) {
  F = fctr(F);
  L = [];
  for (I=0; I<length(F); I++) {
    for (J=0; J<F[I][1]; J++) {
      L = cons(F[I][0],L);
    }
  }
  return(reverse(L));
}

def test325() {
    Digit=ctrl("real_digit");
    ctrl("real_digit",30);

    A= [[1,1,1,1,1,0,0,0,0,0],
        [1,0,0,0,0,1,0,0,0,1],
        [0,1,0,0,0,1,1,0,0,0],
        [0,0,1,0,0,0,1,1,0,0],
        [0,0,0,1,0,0,0,1,1,0],
        [0,0,0,0,1,0,0,0,1,1]];
    U= [23,21,20,34,30,42,11,10,20,29];
    B=vtol(matrix_list_to_matrix(A)*ltov(U));
    SumU = oh_base.sum(U);
    X = vtol((1/SumU)*ltov(U));
    R = [x1,x2,x3,x4,x5,x6,x7,x8,x9,x10];
    printf("A=%a\nU=%a\nB=%a\nX=%a\n",A,U,B,X);

    // Do not omit msize=3
    EV=hgm_ahg_expected_values_contiguity(A,B,X,R|msize=3);
    N=length(EV); Err=newvect(N);
    for(I=0; I<N; I++) {
        Err[I]=deval(number_abs((U[I]-EV[I])/U[I]));
    }
    Err=vtol(Err);
    printf("Err=%a\n",Err);
    Err=oh_base.max(Err);
    printf("MaxErr=%a\n",Err);
    ctrl("real_digit",Digit);
    return Err;
}

def test_f9() {
    Digit=ctrl("real_digit");
    ctrl("real_digit",30);
    T0=time();
    B=[[-1,-1,-1, 1,1,1, 0,0,0],
       [-1,-1,-1, 0,0,0, 1,1,1]];
    A=matrix_kernel(B)[1];
    printf("A=%a\n",A);
    U=ltov([80,40,25,62,28,109,35,43,34]);
    Beta=vtol(matrix_list_to_matrix(A)*U);
    printf("U=%a\nBeta=%a\n",vtol(U),Beta);
    SumU = oh_base.sum(U);
    X0 = vtol((1/SumU)*U); /* 経験オッズ */
    R = [x1,x2,x3,x4,x5,x6,x7,x8,x9];
    printf("at (%a=%a)\n",R,X0);

    R = [x3]; U = [U[2]];
//  Do not omit msize=4
    EV=hgm_ahg_expected_values_contiguity_generic(A,Beta,X0,R|msize=4);
    printf("EV(%a)=%a\n",R,EV);
    N=length(EV); Err=newvect(N);
    for(I=0; I<N; I++) {
        Err[I]=deval(number_abs((U[I]-EV[I])/U[I]));
    }
    Err=vtol(Err);
    printf("Err=%a\n",Err);
    Err=oh_base.max(Err);
    printf("MaxErr=%a\n",Err);
    print_time("test_f9",T0);
    ctrl("real_digit",Digit);
    return Err;
}

def test_fQ3() {
    Digit=ctrl("real_digit");
    ctrl("real_digit",30);

    B=[[-1,-1,-1, 1,1,1, 0,0,0, 0,0,0],
       [-1,-1,-1, 0,0,0, 1,1,1, 0,0,0],
       [-1,-1,-1, 0,0,0, 0,0,0, 1,1,1]];
    A=matrix_kernel(B)[1];
    printf("A=%a\n",A);
    U=ltov([80,40,25,62,28,109,35,43,34,70,22,41]);
    Beta=vtol(matrix_list_to_matrix(A)*U);
    printf("Beta=%a\n",Beta);
    SumU = oh_base.sum(U);
    X0 = vtol((1/SumU)*ltov(U)); /* 経験オッズ */
    R = [x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12];
    printf("at (%a=%a)\n",R,X0);

//  Do not omit msize=4
    EV=hgm_ahg_expected_values_contiguity_generic(A,Beta,X0,R|msize=4);
    printf("EV(%a)=%a\n",R,EV);
    N=length(EV); Err=newvect(N);
    for(I=0; I<N; I++) {
        Err[I]=deval(number_abs((U[I]-EV[I])/U[I]));
    }
    Err=vtol(Err);
    printf("Err=%a\n",Err);
    Err=oh_base.max(Err);
    printf("MaxErr=%a\n",Err);
    ctrl("real_digit",Digit);
    return Err;
}

def test_f4() {
    Digit=ctrl("real_digit");
    ctrl("real_digit",30);
    B=[[-1,-1, 1,1, 0,0],
       [-1,-1, 0,0, 1,1]];
    A=matrix_kernel(B)[1];
    printf("A=%a\n",A);
    U=ltov([80,40,25,62,28,109]);
    Beta=vtol(matrix_list_to_matrix(A)*U);
    printf("Beta=%a\n",Beta);
    SumU = oh_base.sum(U);
    X0 = vtol((1/SumU)*ltov(U)); /* 経験オッズ */
    R = [x1,x2,x3,x4,x5,x6];
    printf("at (%a=%a)\n",R,X0);

    EV=hgm_ahg_expected_values_contiguity_generic(A,Beta,X0,R);
    printf("EV(%a)=%a\n",R,EV);
    N=length(EV); Err=newvect(N);
    for(I=0; I<N; I++) {
        Err[I]=deval(number_abs((U[I]-EV[I])/U[I]));
    }
    Err=vtol(Err);
    printf("Err=%a\n",Err);
    Err=oh_base.max(Err);
    printf("MaxErr=%a\n",Err);
    ctrl("real_digit",Digit);
    return Err;
}

def test_fc3() {
    T0=time();
    B=[[-1,-1, 1,1, 0,0, 0,0],
       [-1,-1, 0,0, 1,1, 0,0],
       [-1,-1, 0,0, 0,0, 1,1]];
    A=matrix_kernel(B)[1];
    printf("A=%a\n",A);
    Col=length(A[0]);
    U=ltov([80,40,25,62,28,51,17,30]);
    Beta=vtol(matrix_list_to_matrix(A)*U);
    printf("Beta=%a\n",Beta);
    SumU = oh_base.sum(U);
    X0 = vtol((1/SumU)*ltov(U)); /* 経験オッズ */
    R  = base_var_list(x,1,Col);
    printf("at (%a=%a)\n",R,X0);

    R = [x3]; U = [U[2]];
    EV=hgm_ahg_expected_values_contiguity_generic(A,Beta,X0,R|msize=3);
    printf("EV(%a)=%a\n",R,EV);
    N=length(EV); Err=newvect(N);
    for(I=0; I<N; I++) {
        Err[I]=deval(number_abs((U[I]-EV[I])/U[I]));
    }
    Digit=ctrl("real_digit");
    ctrl("real_digit",30);
    Err=vtol(Err);
    printf("Err=%a\n",Err);
    Err=oh_base.max(Err);
    printf("MaxErr=%a\n",Err);
    print_time("test_f9",T0);
    ctrl("real_digit",Digit);
    return Err;
}

def test_fc4() {
    T0=time();
    B=[[-1,-1, 1,1, 0,0, 0,0, 0,0],
       [-1,-1, 0,0, 1,1, 0,0, 0,0],
       [-1,-1, 0,0, 0,0, 1,1, 0,0],
       [-1,-1, 0,0, 0,0, 0,0, 1,1]];
    A=matrix_kernel(B)[1];
    printf("A=%a\n",A);
    Col=length(A[0]);
    U=ltov([80,40,25,62,28,51,17,30,60,29]);
    Beta=vtol(matrix_list_to_matrix(A)*U);
    printf("Beta=%a\n",Beta);
    SumU = oh_base.sum(U);
    X0 = vtol((1/SumU)*ltov(U)); /* 経験オッズ */
    R  = base_var_list(x,1,Col);
    printf("at (%a=%a)\n",R,X0);

    R = [x3]; U = [U[2]];
    EV=hgm_ahg_expected_values_contiguity_generic(A,Beta,X0,R|msize=4);
    printf("EV(%a)=%a\n",R,EV);
    N=length(EV); Err=newvect(N);
    for(I=0; I<N; I++) {
        Err[I]=deval(number_abs((U[I]-EV[I])/U[I]));
    }
    Digit=ctrl("real_digit");
    ctrl("real_digit",30);
    Err=vtol(Err);
    printf("Err=%a\n",Err);
    Err=oh_base.max(Err);
    printf("MaxErr=%a\n",Err);
    print_time("test_f9",T0);
    ctrl("real_digit",Digit);
    return Err;
}

def  stop_on_windows() {
  if  (sysinfo()[0] == "windows") {
    error("Warning: sm1 server is not available on Windows. \n");
    return(1);
  }
  return(0);
}

def test_f9_hilbert() {
    B=[[-1,-1,-1, 1,1,1, 0,0,0],
       [-1,-1,-1, 0,0,0, 1,1,1]];
    A=matrix_kernel(B)[1];
    printf("A=%a\n",A);
    ACH=translation_of_a(A);
    A=ACH[0];
    S = newvect(length(A));
    for (I=0; I<length(A); I++) S[I] = -util_v(b,[I+1]);
    S = vtol(S);
    F=tk_sm1emu.gkz([A,S]);
    L=F[0]; V=F[1];  Dv=tk_sm1emu.add_d(V);

    yang.verbose();
    yang.define_ring(["partial",V]);
    L=map(dp_ptod,L,Dv);
    stop_on_windows();
    T0=time();
    G=yang.buchberger(L | sm1=1, hilbert=9);
    T1=time();
    printf("Time for the Hilbert driven Buchberger is %a\n",Btime=T1[0]-T0[0]);
    M = yang.stdmon(G);
    printf("Stdmon=%a\n",M);
    Base = map(dp_ptod,M,Dv);
    T0=time();
    Pf = yang.pfaffian(Base,G);
    ForPaper_data3 = Pf;
    T1=time();
    printf("Time to translate to the Pfaffian %a. Pfaffian is saved in ForPaper_data3.\n",Btime=T1[0]-T0[0]);
}

def test_f9_series() {
  B=[[-1,-1,-1, 1,1,1, 0,0,0],
     [-1,-1,-1, 0,0,0, 1,1,1]];
  A=matrix_kernel(B)[1];
  U=ltov([80,40,25,62,28,109,35,43,34]);
  Beta=vtol(matrix_list_to_matrix(A)*U);
  printf("A=%a\n",A);
  ACH=translation_of_a(A);
  A=ACH[0];
  NewB=translation_of_beta(Beta,ACH);
  printf("NewB=%a\n",NewB);
  T0=time();
  F=tk_hgpoly.hgpolyk(A,NewB);
  T1=time();
  printf("Time=%a\n",T1[0]-T0[0]);
  return(F);
}

/* No answer in 3 days. */
def test_fc4_series() {
    B=[[-1,-1, 1,1, 0,0, 0,0, 0,0],
       [-1,-1, 0,0, 1,1, 0,0, 0,0],
       [-1,-1, 0,0, 0,0, 1,1, 0,0],
       [-1,-1, 0,0, 0,0, 0,0, 1,1]];
  A=matrix_kernel(B)[1];
  U=ltov([80,40,25,62,28,51,17,30,60,29]);
  Beta=vtol(matrix_list_to_matrix(A)*U);
  printf("A=%a\n",A);
  ACH=translation_of_a(A);
  A=ACH[0];
  NewB=translation_of_beta(Beta,ACH);
  printf("NewB=%a\n",NewB);
  T0=time();
  F=tk_hgpoly.hgpolyk(A,NewB);
  T1=time();
  printf("Time=%a\n",T1[0]-T0[0]);
  bsave(F,"tmp-test_fc4_series.ab");
  return(0);
}

def test_fc4_series2() {
    B=[[-1,-1, 1,1, 0,0, 0,0, 0,0],
       [-1,-1, 0,0, 1,1, 0,0, 0,0],
       [-1,-1, 0,0, 0,0, 1,1, 0,0],
       [-1,-1, 0,0, 0,0, 0,0, 1,1]];
  A=matrix_kernel(B)[1];
  U=ltov([80,40,25,62,28,51,17,30,60,29]);
  Beta=vtol(matrix_list_to_matrix(A)*U);
  printf("A=%a, U=%a, Beta=%a\n",A,U,Beta);
  ACH=translation_of_a(A);
  A=ACH[0];
  NewB=translation_of_beta(Beta,ACH);
  printf("NewB=%a\n",NewB);
  SumU = oh_base.sum(U);
  X0 = vtol((1/SumU)*ltov(U)); 
  printf("X0=%a\n",X0);
  T0=time();
  F=tk_hgpoly.hgpolyk(A,NewB | x=X0);  //  deg option should also be given.
  T1=time();
  printf("Time=%a\n",T1[0]-T0[0]);
  bsave(F,"tmp-test_fc4_series2.ab");
  return(0);
}

/*
  2015.06.04
  tt.rr  import("ot-tmp.rr"); test_fc4_pf(); end$
  tt.sh   nohup asir <tt.rr >log-test_fc4_pf.txt &
  sh ./tt.sh 
*/
def test_fc4_pf() {
    B=[[-1,-1, 1,1, 0,0, 0,0, 0,0],
       [-1,-1, 0,0, 1,1, 0,0, 0,0],
       [-1,-1, 0,0, 0,0, 1,1, 0,0],
       [-1,-1, 0,0, 0,0, 0,0, 1,1]];
  A=matrix_kernel(B)[1];
  M=length(A);
  Beta = newvect(M);
  for (I=0; I<M; I++) Beta[I] = util_v(s,[I]);
  Beta = vtol(Beta);
  F=tk_sm1emu.gkz([A,Beta]);

//  F=tk_sm1emu.gkz([[[0,0,1,1],[1,0,1,0],[0,1,0,1]],[s_0,s_1,s_2]]); 

  L=F[0];
  V=F[1]; 
  DV=tk_sm1emu.add_d(V);
  dp_gr_flags(["Print",1]);
  W0 = newvect(2*length(V));
  for (I=length(V); I<2*length(V); I++) W0[I] = 1;
  W0 = vtol(W0);
  W = poly_weight_to_omatrix(W0,append(V,DV));
  T0=time();
  Gb = nd_weyl_gr(L,append(V,DV),0,W);
  T1=time();
  printf("Time=%a\n",T1[0]-T0[0]);
  bsave(Gb,"tmp-test_fc4_pf.ab");
  return(0);
}

/* 2015.06.11  */
def test_fc4_pf2() {
  G = bload("fc4_pf.ab");  // tmp-test-fc4_pf.ab is renamed to fc4_pf.ab
//    G = [dx10^5,dx4*dx10^3,dx6*dx10^3,dx8*dx10^3,dx4*dx8*dx10,dx6*dx8*dx10,dx4^2,dx4*dx6,dx6^2,dx8^2,dx1,dx2,dx3,dx5,dx7-2,dx9-1];  // test input.
    B=[[-1,-1, 1,1, 0,0, 0,0, 0,0],
       [-1,-1, 0,0, 1,1, 0,0, 0,0],
       [-1,-1, 0,0, 0,0, 1,1, 0,0],
       [-1,-1, 0,0, 0,0, 0,0, 1,1]];
  A=matrix_kernel(B)[1];
  M=length(A);
  print(A);
  Beta = newvect(M);
  for (I=0; I<M; I++) Beta[I] = util_v(s,[I]);
  Beta = vtol(Beta);
  F=tk_sm1emu.gkz([A,Beta]);
//  F=tk_sm1emu.gkz([[[0,0,1,1],[1,0,1,0],[0,1,0,1]],[s_0,s_1,s_2]]); 
  V=F[1]; 
  DV=tk_sm1emu.add_d(V);

  W0 = newvect(2*length(V));
  for (I=length(V); I<2*length(V); I++) W0[I] = 1;
  W0 = vtol(W0);
  W = poly_weight_to_omatrix(W0,append(V,DV));
  dp_ord(W);
  G2 = map(dp_ptod,G,append(V,DV));
  In = map(dp_ht,G2);
  In = map(dp_dtop,In,append(V,DV));
  One = newvect(length(V)); for (I=0; I<length(V); I++) One[I]=1;  One=vtol(One);
  InD = base_replace(In,assoc(V,One));
  InD = nd_gr(InD,DV,0,0);

  InD = map(dp_ptod,InD,DV);
  Std=dp_mbase(InD);

  yang.verbose();
  yang.define_ring(["partial",V]);
  Gy = map(dp_ptod,G,DV);
  T0=time();
  Pf=yang.pfaffian(Std,Gy);
  T1=time();
  printf("Time for the yang.pfaffian is %a\n",T1[0]-T0[0]);
  bsave(Pf,"tmp-test_fc4_pf2.ab");
  return(0);
}


def test_fc4b(N) {
    T0=time();
    B=[[-1,-1, 1,1, 0,0, 0,0, 0,0],
       [-1,-1, 0,0, 1,1, 0,0, 0,0],
       [-1,-1, 0,0, 0,0, 1,1, 0,0],
       [-1,-1, 0,0, 0,0, 0,0, 1,1]];
    A=matrix_kernel(B)[1];
    printf("A=%a\n",A);
    Col=length(A[0]);
    U=ltov([80+N,40+N,25,62,28,51,17,30,60,29]);
    Beta=vtol(matrix_list_to_matrix(A)*U);
    printf("Beta=%a\n",Beta);
    SumU = oh_base.sum(U);
    X0 = vtol((1/SumU)*ltov(U)); /* 経験オッズ */
    R  = base_var_list(x,1,Col);
    printf("at (%a=%a)\n",R,X0);

    R = [x3]; U = [U[2]];
    TT0=time();
    EV=hgm_ahg_expected_values_contiguity_generic(A,Beta,X0,R|msize=4);
    printf("EV(%a)=%a\n",R,EV);
    print_time("test_f9",T0);
    TT1=time();printf("Time=%a\n",TT1[0]-TT0[0]);
    return(0);
}
def try2c() {  
  for (N=200; N<=1000; N += 100) { printf("N=%a\n",N); test_fc4b(N); }
}
def try2d() {  
  for (N=100; N<=1000; N += 100) { printf("N=%a\n",N); test_fc4b(N); }
}

/* 2015.09.24 */
def sing_poly(A) {
  if (type(getopt(rank))>0) {
   Rank = getopt(rank);
  }else Rank=0;
  T = mytoric(A,0);
  Ee = T[0]; Et=T[1];
  Vx = T[2]; Vs=T[3];
  L = append(Ee,Et);
  Dv=tk_sm1emu.add_d(Vx);
  yang.verbose();
  yang.define_ring(["partial",Vx]);
  L=map(dp_ptod,L,Dv);
  T0=time();
  if (Rank > 0) {
    stop_on_windows();
    G=yang.buchberger(L | sm1=1, hilbert=Rank);
    T1=time();
    printf("Time for the Hilbert driven Buchberger is %a\n",Btime=T1[0]-T0[0]);
  }else{ 
    G=yang.buchberger(L);
    T1=time();
    printf("Time for the Buchberger is %a\n",Btime=T1[0]-T0[0]);
  }
  M = yang.stdmon(G);
  printf("Stdmon=%a\n",M);
  Base = map(dp_ptod,M,Dv);
  T0=time();
  Pf = yang.pfaffian(Base,G);
  Sing_poly_pf = Pf;
  T1=time();
  printf("Time to translate to the Pfaffian %a. Pf is in Sing_poly_pf\n",Btime=T1[0]-T0[0]);
  return(fctr(pf2sing_poly(Pf)));
}
/* 2015.09.25 */
def mylcm(F,G) {
  GCD = gcd(F,G);
  return(red(F/GCD)*G);
}
def pf2sing_poly(Pf) {
  N = length(Pf);
  R =size(Pf[0])[0];
  F = 1;
  for (I=0; I<N; I++) {
   P = Pf[I];
   for (J=0; J<R; J++) for (K=0; K<R; K++) {
     if (P[J][K] != 0) {
       G = dn(P[J][K]);
       F = mylcm(F,G);
     }
   }
  }
  return(F);
}
/*
 b_i's are not in
 sing_poly([[1,1,1,1],[0,1,2,3]]);
 sing_poly([[1,1,1,1],[0,1,0,1],[0,0,1,1]]);
 sing_poly([[0,0,1,1],[1,0,1,0],[0,1,0,1]]);
    The inverse matrix contains b_i's in the denominators.  cf. kyoto* /2x2.rr
    But, dn(Pf) does not contain them.
 sing_poly([[1,1,1,1,1,1],[1,0,0,-1,0,0,0],[0,1,0,0,-1,0],[0,0,1,0,0,-1]]);

 b_i's are in 
 sing_poly([[1,1,1,1],[0,1,3,4]]);
*/

end$
