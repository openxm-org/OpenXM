load("bfct");

/* source from lib/bfct generic_bfct */
/* generic b-fucntion に加えて F の <_(-W,W) についての GB を返す */ 
/* F : ideal, V : var list(x), DV : var list(dx), W : weight vect */
def generic_bfct_and_gr(F,V,DV,W)
{
	N = length(V);
	N2 = N*2;

	/* If W is a list, convert it to a vector */
	if ( type(W) == 4 )
		W = newvect(length(W),W);

	/* dp_weyl_set_weight とは...? */
	dp_weyl_set_weight(W);

	/* create a term order M in D<x,d> (DRL) */
	M = newmat(N2,N2);
	for ( J = 0; J < N2; J++ )
		M[0][J] = 1;
	for ( I = 1; I < N2; I++ )
		M[I][N2-I] = -1;
	
	VDV = append(V,DV);

	/* create a non-term order MW in D<x,d> */
	MW = newmat(N2+1,N2);
	for ( J = 0; J < N; J++ )
		MW[0][J] = -W[J];
	for ( ; J < N2; J++ )
		MW[0][J] = W[J-N];
	for ( I = 1; I <= N2; I++ )
		for ( J = 0; J < N2; J++ )
			MW[I][J] = M[I-1][J];

	/* create a homogenized term order MWH in D<x,d,h> */
	MWH = newmat(N2+2,N2+1);
	for ( J = 0; J <= N2; J++ )
		MWH[0][J] = 1;
	for ( I = 1; I <= N2+1; I++ )
		for ( J = 0; J < N2; J++ )
			MWH[I][J] = MW[I-1][J];

	/* homogenize F */
	VDVH = append(VDV,[h]);
	FH = map(dp_dtop,map(dp_homo,map(dp_ptod,F,VDV)),VDVH);
	
	/* compute a groebner basis of FH w.r.t. MWH */
	dp_gr_flags(["Top",1,"NoRA",1]);
	GH = dp_weyl_gr_main(FH,VDVH,0,1,11);
	dp_gr_flags(["Top",0,"NoRA",0]);

	/* dehomigenize GH */
	G = map(subst,GH,h,1);

	/* G is a groebner basis w.r.t. a non term order MW */
	/* take the initial part w.r.t. (-W,W) */
	GIN = map(initial_part,G,VDV,MW,W);

	/* GIN is a groebner basis w.r.t. a term order M */
	/* As -W+W=0, gr_(-W,W)(D<x,d>) = D<x,d> */
	
	/* find b(W1*x1*d1+...+WN*xN*dN) in Id(GIN) */
	for ( I = 0, T = 0; I < N; I++ )
		T += W[I]*V[I]*DV[I];
	B = weyl_minipoly(GIN,VDV,0,T); /* M represents DRL order */
	return [B, G];
}

/*
 * restriction module の計算([SST, Alg5.2.8])
 * Id : ideal
 * VL : var list (x)
 * DVL: var list (dx)
 * W  : weight vector
 *      VL と長さは同じ
 *      W[0], ..., W[M] が正で、それ以降の要素は 0 としておく
 */
def restriction(Id, VL, DVL, W)
{
	Result = generic_bfct_and_gr(Id, VL, DVL, W);
	BF = Result[0];
	GB = Result[1];

	/* BF の最大整数根 S0 を取り出す */
	L = fctr(BF);
	BFF = L;
	/* L の最初の要素は係数なので捨てる */
	L = cdr(L);
	N = length(L);
	S0 = [];
	for (I = 0; I < N; I++) {
		T = L[I][0];
		Root = -coef(T, 0, s) / coef(T, 1, s);
		if (dn(Root) == 1) {
			if (S0 == []) {
				S0 = Root;
			} else if (Root > S0) {
				S0 = Root;
			} 
		}
	}
	/* b-function が非負整数根を持たない場合([SST, Cor5.2.7]) */
	if (S0 == [] || S0 < 0) 
		return 0;
	print("generic bfct : " + rtostr(BFF), 1);
	print("S0 : " + rtostr(S0), 1);
	for (M = 0; M < length(W); M++) 
		if (W[M] <= 0)
			break;

	/* W の正の要素の部分だけとりだしたもの WW */
	WW = newvect(M);
	for (I = 0; I < M; I++)
		WW[I] = W[I];
	WW = vtol(WW);
	/* B_{S0} の生成 */
	Base = gen(WW, S0);
	print("B_{S0} length : " + rtostr(length(Base)),1); 

	V = newvect(length(W), W); 
	MinusW = vtol(-V);
	WVect = append(MinusW, W);
	VarL  = append(VL, DVL);
	NN = length(GB);
	OrderGB = newvect(NN);	
	for (I = 0; I < NN; I++) 
		OrderGB[I] = ord_w(GB[I], VarL, WVect); 
	Generator = [];
	for (I = 0; I < NN; I++) {
		/* 
		 * B_{S0 - OrderGB[I]} 
		 * i.e. WW[0]*I[0]+...+WW[M-1]*I[M-1] <= 
                 * S0 - OrderGB[I] なる (I[0],...,I[M-1]) の生成 
		 */
		B = gen(WW, S0 - OrderGB[I]);
		while (B != []) {
			Index = car(B);
			D = 1;
			for (J = 0; J < M; J++) 
				D *= DVL[J]^Index[J];
			P = weyl_mul(D, GB[I], VarL);
			for (J = 0; J < M; J++)
				P = subst(P, VL[J], 0);	
			if (P != 0)  
				Generator = cons(P, Generator);
			B = cdr(B);
		}
	}
	return [Generator, Base];
}

/* F は s の多項式 */
/* ただし F は Q 上 1 次式に因数分解できるものとする */
def max_int_root(F)
{
	L = fctr(F);
	/* L の最初の要素は係数なので捨てる */
	L = cdr(L);
	N = length(L);
	S0 = [];
	for (I = 0; I < N; I++) {
		T = L[I][0];
		Root = -coef(T, 0, s) / coef(T, 1, s);
		if (dn(Root) == 1) {
			if (S0 == []) {
				S0 = Root;
			} else if (Root > S0) {
				S0 = Root;
			} 
		}
	}
	return S0;
}

def test_max_int_root()
{
	print(max_int_root(3*(s+3)^2*(s+1)^3));
	print(max_int_root((s+1/2)*(s+1/3)*(s+3)^2*(s+1)^3));
	print(max_int_root((s+1/2)*(s+1/3)*(s+1/5)^2*(s+1/10)^3));
}

/* 
 * I[0]*W[0] + ... + I[M-1]*W[M-1] <= S0 なる 
 * [I[0], ..., I[M-1]] を返す
 */ 
def gen(W, S0)
{
	if (W == []) 
		return [[]];
	Weight = car(W);
	LL = [];
	for (I = 0; I <= S0 / Weight; I++) {
		L = gen(cdr(W), S0 - Weight * I);
		L = map(cons_rev, L, I); 
		LL = append(L, LL);
	}
	return LL;
}

/* map 適用のため */
def cons_rev(L, I)
{
	return cons(I, L);
}

def test_gen()
{
	print(gen([1],3));
	print(gen([1,1,1],3));
	print(gen([1,1,1],5));
	print(gen([1,2,3],5));
}

/* from localb.rr */
def ord_w(P, VL, W)
{
        if (P == 0) {
                print("ord_w(0)");
                return;
        }

        N = length(VL);
        DP = dp_ptod(P, VL);

        V = dp_etov(DP);
        DP = dp_rest(DP);       
        for (Max = 0, I = 0; I < N; I++)
                Max += V[I] * W[I];     
        while (DP != 0) {
                V = dp_etov(DP);
                DP = dp_rest(DP);       
                for (Weight = 0, I = 0; I < N; I++)
                        Weight += V[I] * W[I];  
                if (Max < Weight)
                        Max = Weight;
        }
        return Max;
}

/* from localb.rr */
def weyl_mul(P, Q, VL)
{
        DP = dp_ptod(P, VL);
        DQ = dp_ptod(Q, VL);
        return dp_dtop(dp_weyl_mul(DP, DQ), VL);
}

/* restriction のよい計算例はないか... */
def test_restriction()
{
	L = [x*dx-1, y*dy-1];
	print("restriction");
	R1 = restriction(L, [x,y], [dx,dy], [1,0]);
	print(R1);
	print("sm1.restriction");
	R2 = sm1.restriction(L, [x,y], [x]);
	print(R2);
}

def test_restriction2()
{
	/* from [SST, p202] */
	L = [dx^2, dy^2];
	print("restriction");
	R1 = restriction(L, [x,y], [dx,dy], [1,0]);
	print(R1);
	print("sm1.restriction");
	R2 = sm1.restriction(L, [x,y], [x]);
	print(R2);
}

def test_restriction3()
{
	/* Appell F_1 */
	L = [x*(1-x)*dx^2+y*(1-x)*dx*dy+(c-(a+b+1)*x)*dx-b*y*dy-a*b,
	     y*(1-y)*dy^2+x*(1-y)*dx*dy+(c-(a+bb+1)*y)*dy-bb*x*dx-a*bb];
	/* parameter つきでは無理なので特定の値で */
}

/*
 * restriction ideal の計算 [SST, Alg5.2.12] 
 * Id : D-ideal
 * VL : var list (x)
 * DVL: var list (dx)
 * W  : weight vector
 *      VL と長さは同じ
 *      W[0], ..., W[M] が正で、それ以降の要素は 0 としておく
 */
def restriction_ideal(Id, VL, DVL, W)
{
	L = restriction(Id, VL, DVL, W);
	print("restriction :");
	print(L);
	GG = restriction_ideal_internal(L, VL, DVL, W);
	return GG;
}

/* L : result of restriction */
def restriction_ideal_internal(L, VL, DVL, W)
{
	/* 
	 * restriction module の結果をベクトル表示に直す       
	 * Base と同じ順に dx^Base[I] の係数を I 成分に格納   
	 * restriction の結果の Base は最後の要素が [0,...,0]  
	 * だからベクトル表示した場合、最後の成分が 1 の係数  
	 */
	Gen = L[0];
	Base = L[1];

	M = 0;
	for (M = 0; M < length(W); M++)
		if (W[M] <= 0)
			break;

	N = length(Base);
	P = length(Gen);
	GenV = newvect(P);
	for (I = 0; I < P; I++) {
		T = Gen[I];
		V = newvect(N);
		for (J = 0; J < N; J++) {
			Exp = Base[J];
			/* T の dx_1^Exp[0] .. dx_M-1^Exp[M-1] の係数 を求める */
			C = T;
			for (K = 0; K < M; K++) {
				C = coef(C, Exp[K], DVL[K]);	
			}
			V[J] = C;	
		}
		GenV[I] = vtol(V);
	}	
	print("Generators :");
	print(GenV);
	
	NN = length(VL) - M;
	VLY = newvect(NN * 2);
	for (I = 0; I < NN; I++) {
		VLY[I] = VL[I + M];
		VLY[I + NN] = DVL[I + M];
		
	}
	VLY = vtol(VLY);
	GenV = vtol(GenV);
	/* GenV の要素はリストでないと nd_weyl_gr で internal error */
	G = nd_weyl_gr(GenV, VLY, 0, [1,0]);	
	print("GB :");
	print(G);

	/* G の元の中で、最後の成分(i.e. 1 の係数) のみ 0 でないものを取り出す */
	Len = length(G);
	GG = [];
	for (I = 0; I < Len; I++) {
		T = G[I];
		for (J = 0; J < N - 1; J++) 
			if (T[J] != 0) 
				break;
		if (J == N - 1 && T[N - 1] != 0) 
			GG = cons(T[N - 1], GG);		
	}
	print("GG :");
	print(GG);

	return GG;
}

def test_restriction_ideal_internal()
{
	L = restriction([x*dx-1,y*dy-1],VL=[x,y],DVL=[dx,dy],W=[1,0]);
	print(L);
	restriction_ideal_internal(L, VL, DVL, W);
}

def test_nd_weyl_gr()
{
	/* internal error 
	nd_weyl_gr([newvect(2,[1,x]),newvect(2,[x,y])], [x,y,dx,dy],0,[1,0]);
	*/

	/* invarid argument 
	nd_weyl_gr(newvect(2,[[1,x],[x,y]]), [x,y,dx,dy], 0, [1,0]);
	*/
	
	/* correct */
	nd_weyl_gr([[1,x],[x,y]],[x,y,dx,dy],0,[1,0]);
}

/* 微分作用素 P(x,dx) を Fourier 変換したものを返す */ 
/* i.e. x_i -> - dx_i, dx_i -> x_i                  */
def fourier_trans(P, VL, DVL)
{
	N = length(VL);
	VLL = append(VL, DVL);
	DP = dp_ptod(P, VLL);
	S = 0;
	VE = newvect(2 * N);
	while (DP != 0) {
		C = dp_hc(DP);
		V = dp_etov(DP);

		/* x^a -> (-1)^|a| dx^a に変換(dp で) */
		M = 0;	
		for (I = 0; I < N; I++) 
			VE[I] = 0;
		for (I = 0; I < N; I++) {
			VE[N + I] = V[I];
			M += V[I];	
		}
		DPD = dp_vtoe(VE);
		if (M % 2 == 1) 
			DPD = -DPD;

		/* dx^a -> x^a に変換 */
		for (I = 0; I < N; I++) 
			VE[I] = V[N + I];
		for (I = 0; I < N; I++) 
			VE[N + I] = 0;
		DPX = dp_vtoe(VE);

		T = C * dp_weyl_mul(DPD, DPX);
		S += T;
		DP = dp_rest(DP);
	}
	return dp_dtop(S, VLL);
}

def test_fourier_trans()
{
	print(fourier_trans(x*dx, [x], [dx]));
	print(fourier_trans(x^2*dx^2, [x], [dx]));
	print(fourier_trans(x*dx*y+1, [x], [dx]));
}

/* 微分作用素 P(x,dx) を Fourier 変換したものを返す */ 
/* i.e. x_i -> dx_i, dx_i -> - x_i                  */
def inv_fourier_trans(P, VL, DVL)
{
	N = length(VL);
	VLL = append(VL, DVL);
	DP = dp_ptod(P, VLL);
	S = 0;
	VE = newvect(2 * N);
	while (DP != 0) {
		C = dp_hc(DP);
		V = dp_etov(DP);

		/* x^a -> dx^a に変換(dp で) */
		M = 0;	
		for (I = 0; I < N; I++) 
			VE[I] = 0;
		for (I = 0; I < N; I++) 
			VE[N + I] = V[I];
		DPD = dp_vtoe(VE);

		/* dx^a -> (-1)^|a| x^a に変換 */
		for (I = 0; I < N; I++) {
			VE[I] = V[N + I];
			M += V[N + I];	
		}
		for (I = 0; I < N; I++) 
			VE[N + I] = 0;
		DPX = dp_vtoe(VE);
		if (M % 2 == 1) 
			DPX = -DPX;

		T = C * dp_weyl_mul(DPD, DPX);
		S += T;
		DP = dp_rest(DP);
	}
	return dp_dtop(S, VLL);
}

def test_inv_fourier_trans()
{
	print(inv_fourier_trans(fourier_trans(x^2*dx^2*y+x*dx*dy+y, [x], [dx]),[x],[dx]));
}

/*
 * integration module の計算([SST, Alg5.5.4])
 * Id : ideal
 * VL : var list (x)
 * DVL: var list (dx)
 * W  : weight vector
 *      VL と長さは同じ
 *      W[0], ..., W[M] が正で、それ以降の要素は 0 としておく
 */
def integration(Id, VL, DVL, W)
{
	for (M = 0; M < length(W); M++) 
		if (W[M] <= 0)
			break;
	VLM = newvect(M);
	DVLM = newvect(M);
	for (I = 0; I < M; I++) {
		VLM[I]  = VL[I];
		DVLM[I] = DVL[I];	
	}
	VLM = vtol(VLM);
	DVLM = vtol(DVLM);
	
	FId = map(fourier_trans, Id, VLM, DVLM);
	R = restriction(FId, VL, DVL, W);
	print("restriction of FId :");
	print(R); 
	Generator = map(inv_fourier_trans, R[0], VLM, DVLM);
	return [Generator, R[1]];
}

def test_integration()
{
	/* [SST, Ex5.5.2, 5.5.6] */
	/* integration of the annihilating ideal of 1/(t^2-x) w.r.t. t */
	Id = [2*t*dx+dt, t*dt+2*x*dx+2];
	print(integration(Id, [t,x],[dt,dx],[1,0]));
}

def test_integration2()
{
	/* [SST, Ex5.6.13] */
	/* integration of the annihilating ideal of e^(t^3-x*t) w.r.t. t */
	Id = [dt - (3*t^2-x), dx + t];
	print(integration(Id, [t,x],[dt,dx],[1,0]));
}

def test_integration3()
{
	/* [SST, Ex5.5.9]     */
	/* 計算が合わない??   */
	F = x^3+t1^3+t2^3;
	Ann = ann(F);
	Ann0 = map(subst, Ann, s, -2);
	Int = integration(Ann0, [t1,t2,x],[dt1,dt2,dx],[1,1,0]);
	return Int;
}

def test_integration4()
{
	/* [SST, Ex5.5.16]     */
	/* test_integration3 と同じイデアルだが、重みベクトルが異なる */
	F = x1^3+x2^3+x3^3;
	Ann = ann(F);
	Ann0 = map(subst, Ann, s, -2);
	Int = integration(Ann0, [x1,x2,x3],[dx1,dx2,dx3],[1,2,3]);
	return Int;
}

/*
 * integration ideal の計算 [SST, Alg5.5.4] 
 * Id : D-ideal
 * VL : var list (x)
 * DVL: var list (dx)
 * W  : weight vector
 *      VL と長さは同じ
 *      W[0], ..., W[M] が正で、それ以降の要素は 0 としておく
 */
def integration_ideal(Id, VL, DVL, W)
{
	L = integration(Id, VL, DVL, W);
	print("integration :");
	print(L);
	GG = integration_ideal_internal(L, VL, DVL, W);
	return GG;
}

/* L : result of integration */
def integration_ideal_internal(L, VL, DVL, W)
{
	/* 
	 * integration module の結果をベクトル表示に直す       
	 * Base と同じ順に x^Base[I] の係数を I 成分に格納   
	 * restriction の結果の Base は最後の要素が [0,...,0]  
	 * だからベクトル表示した場合、最後の成分が 1 の係数  
	 */
	Gen = L[0];
	Base = L[1];

	M = 0;
	for (M = 0; M < length(W); M++)
		if (W[M] <= 0)
			break;

	N = length(Base);
	P = length(Gen);
	GenV = newvect(P);
	for (I = 0; I < P; I++) {
		T = Gen[I];
		V = newvect(N);
		for (J = 0; J < N; J++) {
			Exp = Base[J];
			/* T の x_1^Exp[0] .. x_M-1^Exp[M-1] の係数 を求める */
			C = T;
			for (K = 0; K < M; K++) {
				C = coef(C, Exp[K], VL[K]);	
			}
			V[J] = C;	
		}
		GenV[I] = vtol(V);
	}	
	print("Generators :");
	print(GenV);
	
	NN = length(VL) - M;
	VLY = newvect(NN * 2);
	for (I = 0; I < NN; I++) {
		VLY[I] = VL[I + M];
		VLY[I + NN] = DVL[I + M];
		
	}
	VLY = vtol(VLY);
	GenV = vtol(GenV);
	/* GenV の要素はリストでないと nd_weyl_gr で internal error */
	G = nd_weyl_gr(GenV, VLY, 0, [1,0]);	
	print("GB :");
	print(G);

	/* G の元の中で、最後の成分(i.e. 1 の係数) のみ 0 でないものを取り出す */
	Len = length(G);
	GG = [];
	for (I = 0; I < Len; I++) {
		T = G[I];
		for (J = 0; J < N - 1; J++) 
			if (T[J] != 0) 
				break;
		if (J == N - 1 && T[N - 1] != 0) 
			GG = cons(T[N - 1], GG);		
	}
	print("GG :");
	print(GG);

	return GG;
}

def test_integration_ideal()
{
	/* [SST, Ex5.5.2, 5.5.6] */
	/* integration of the annihilating ideal of 1/(t^2-x) w.r.t. t */
	Id = [2*t*dx+dt, t*dt+2*x*dx+2];
	L = integration(Id, VL=[t,x],DVL=[dt,dx],W=[1,0]);
	print("integration module :");
	print(L);
	R = integration_ideal_internal(L, VL, DVL, W);
	print("integration ideal :");
	print(R);
}

def test_integration_ideal2()
{
	/* [SST, Ex5.5.7] */
	F = (x1+x2*t+x3*t^2+x4*t^3)*t^2;
	BF = bfct(F);
	print("BF :");
	print(BF); 
	Ann = ann(F);
	Ann0 = map(subst, Ann, s, -1/5);
	print("Ann(F^s)|s=(-1/5) :");
	print(Ann0);
	print("integration ideal :");
	Int = integration_ideal(Ann0, [t,x1,x2,x3,x4],[dt,dx1,dx2,dx3,dx4],[1,0,0,0,0]);
	print(Int);
}

end$
