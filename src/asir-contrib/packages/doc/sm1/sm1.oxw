/*$OpenXM: OpenXM/src/asir-contrib/packages/doc/sm1/sm1.oxw,v 1.9 2020/02/25 02:21:53 takayama Exp $ */

/*&C
@c DO NOT EDIT THIS FILE   
*/
/*&C
@node SM1 Functions,,, Top

*/
/*&ja
@chapter SM1 函数

この節では sm1 の ox サーバ @code{ox_sm1_forAsir}
とのインタフェース関数を解説する.
これらの関数はファイル  @file{sm1.rr} で定義されている.
@file{sm1.rr} は @file{$(OpenXM_HOME)/lib/asir-contrib} にある.
システム @code{sm1} は微分作用素環で計算するためのシステムである.
計算代数幾何のいろいろな不変量の計算が微分作用素の計算に帰着する.
@code{sm1} についての文書は @code{OpenXM/doc/kan96xx} にある.

なお, sm1 server windows 版はバイナリ配布していない.
cygwin 環境でソースコードからコンパイルし, OpenXM/misc/packages/Windows
に従い変更を加えると sm1 サーバはwindows でも動作する.

とこに断りがないかぎりこの節のすべての関数は,
有理数係数の式を入力としてうけつけない.
すべての多項式の係数は整数でないといけない.

@tex
空間
$X:={\bf C} \setminus \{ 0, 1 \} = {\bf C} \setminus V(x(x-1))$
のドラームコホモロジ群達の次元を計算してみよう.
$X$ は平面に二つの穴をあけた空間であるので, 点 $x=0$, $x=1$ のまわりを
まわる二つのループが1次元のホモロジー群の空間をはる.
したがって, 1次元ドラームコホモロジ群の次元は $2$ である.
@code{sm1} は $0$ 次元のコホモロジ群の次元および $1$ 次元のコホモロジ群の
次元を答える.
@end tex
*/
/*&en
@chapter SM1 Functions

This chapter describes  interface functions for
sm1 ox server @code{ox_sm1_forAsir}.
These interface functions are defined in the file @file{sm1.rr}.
The file @file{sm1.rr} is @*
at @file{$(OpenXM_HOME)/lib/asir/contrib-packages}.
The system @code{sm1} is a system to compute in the ring of differential
operators.
Many constructions of invariants 
in the computational algebraic geometry reduce
to constructions in the ring of differential operators.
Documents on @code{sm1} are in
the directory @code{OpenXM/doc/kan96xx}.

The sm1 server for windows is not distributed in the binary form. 
If you need to run it, compile it under the cygwin environment
following the Makefile in OpenXM/misc/packages/Windows.

All the coefficients of input polynomials should be
integers for most functions in this section.
Other functions accept rational numbers as inputs
and it will be explicitely noted in each explanation
of these functions.



@tex
Let us evaluate the dimensions of the de Rham cohomology groups
of 
$X:={\bf C} \setminus \{ 0, 1 \} = {\bf C} \setminus V(x(x-1))$.
The space $X$ is a two punctured plane, so two loops that encircles the
points $x=0$ and $x=1$ respectively spans the first homology group.
Hence, the dimension of the first de Rham cohomology group is $2$.
@code{sm1} answers the dimensions of the 0th and the first
cohomology groups.
@end tex
*/
/*&C
@example

[283] sm1.deRham([x*(x-1),[x]]);
[1,2]
@end example
*/
/*&C
@noindent
The author of @code{sm1} : Nobuki Takayama, @code{takayama@@math.sci.kobe-u.ac.jp} @*
The author of sm1 packages : Toshinori Oaku, @code{oaku@@twcu.ac.jp} @*
Reference: [SST] Saito, M., Sturmfels, B., Takayama, N., 
Grobner Deformations of Hypergeometric Differential Equations,
1999, Springer.
@url{http://www.math.kobe-u.ac.jp/KAN}
*/

/*&C
@menu
* ox_sm1_forAsir::
* sm1.start::
* sm1.sm1::
* sm1.push_int0::
* sm1.gb::
* sm1.deRham::
* sm1.hilbert::
* sm1.genericAnn::
* sm1.wTensor0::
* sm1.reduction::
* sm1.xml_tree_to_prefix_string::
* sm1.syz::
* sm1.mul::
* sm1.distraction::
* sm1.gkz::
* sm1.mgkz::
* sm1.appell1::
* sm1.appell4::
* sm1.rank::
* sm1.auto_reduce::
* sm1.slope::
* sm1.ahg::
* sm1.bfunction::
* sm1.generalized_bfunction::
* sm1.restriction::
* sm1.saturation::
@end menu
*/

/*&ja
@section @code{ox_sm1_forAsir} サーバ
*/ 
/*&en
@section @code{ox_sm1_forAsir} Server
*/ 

/*&en
@node ox_sm1_forAsir,,, SM1 Functions
@subsection @code{ox_sm1_forAsir}
@findex ox_sm1_forAsir
@table @t
@item ox_sm1_forAsir
::  @code{sm1} server for @code{asir}.
@end table
@itemize @bullet
@item
   @code{ox_sm1_forAsir} is the @code{sm1} server started from asir
    by the command @code{sm1.start}.
    In the standard setting,  @*
    @code{ox_sm1_forAsir} =
         @file{$(OpenXM_HOME)/lib/sm1/bin/ox_sm1}
       +
         @file{$(OpenXM_HOME)/lib/sm1/callsm1.sm1}   (macro file) @* 
       +
         @file{$(OpenXM_HOME)/lib/sm1/callsm1b.sm1}  (macro file) @*
   The macro files @file{callsm1.sm1} and @file{callsm1b.sm1} 
   are searched from
   current directory, @code{$(LOAD_SM1_PATH)}, 
   @code{$(OpenXM_HOME)/lib/sm1},
   @code{/usr/local/lib/sm1}
   in this order.
@item Note for programmers:  See the files
    @file{$(OpenXM_HOME)/src/kxx/oxserver00.c},
    @file{$(OpenXM_HOME)/src/kxx/sm1stackmachine.c}
to build your own server by reading @code{sm1} macros.
@end itemize
*/
/*&ja
@node ox_sm1_forAsir,,, SM1 Functions
@subsection @code{ox_sm1_forAsir}
@findex ox_sm1_forAsir
@table @t
@item ox_sm1_forAsir
::  @code{asir} のための @code{sm1} サーバ.
@end table
@itemize @bullet
@item
   サーバ @code{ox_sm1_forAsir} は @code{asir} よりコマンド
    @code{sm1.start} で起動される @code{sm1} サーバである.

    標準的設定では, @*
    @code{ox_sm1_forAsir} =
         @file{$(OpenXM_HOME)/lib/sm1/bin/ox_sm1}
       +
         @file{$(OpenXM_HOME)/lib/sm1/callsm1.sm1}   (macro file) @* 
       +
         @file{$(OpenXM_HOME)/lib/sm1/callsm1b.sm1}  (macro file) @*
  であり, これらのマクロファイルは, 一般には
   current directory, @code{$(LOAD_SM1_PATH)}, 
   @code{$(OpenXM_HOME)/lib/sm1},
   @code{/usr/local/lib/sm1}
    の順番でさがされる.
@item プログラマーのためのノート: 
@code{sm1} マクロを読み込んで自分独自のサーバを作るには
    次のファイルも見よ
    @file{$(OpenXM_HOME)/src/kxx/oxserver00.c},
    @file{$(OpenXM_HOME)/src/kxx/sm1stackmachine.c}
@end itemize
*/


/*&ja
@section 函数一覧
*/ 
/*&en
@section Functions
*/ 

/*&en
@c sort-sm1.start
@node sm1.start,,, SM1 Functions
@subsection @code{sm1.start}
@findex sm1.start
@table @t
@item sm1.start()
::  Start  @code{ox_sm1_forAsir} on the localhost.
@end table

@table @var
@item return
Integer
@end table

@itemize @bullet
@item Start @code{ox_sm1_forAsir} on the localhost.
    It returns the descriptor of @code{ox_sm1_forAsir}.
@item Set @code{Xm_noX = 1} to start @code{ox_sm1_forAsir} 
without a debug window.
@item You might have to set suitable orders of variable by the command
@code{ord}.  For example, 
when you are working in the
ring of differential operators on the variable @code{x} and @code{dx}
(@code{dx} stands for 
@tex $\partial/\partial x$ 
@end tex 
),
@code{sm1} server assumes that
the variable @code{dx} is collected to the right and the variable
@code{x} is collected to the left in the printed expression.
In the example below, you  must not use the variable @code{cc}
for computation in @code{sm1}.
@item The variables from @code{a} to @code{z} except @code{d} and @code{o}
and @code{x0}, ..., @code{x20}, @code{y0}, ..., @code{y20},
@code{z0}, ..., @code{z20} can be used as variables for ring of
differential operators in default. (cf. @code{Sm1_ord_list} in @code{sm1}).
@item The descriptor is stored in @code{static Sm1_proc}.
The descriptor can be obtained by the function
@code{sm1.get_Sm1_proc()}.
@end itemize
*/
/*&ja
@c sort-sm1.start
@node sm1.start,,, SM1 Functions
@subsection @code{sm1.start}
@findex sm1.start
@table @t
@item sm1.start()
::  localhost で  @code{ox_sm1_forAsir} をスタートする.
@end table

@table @var
@item return
整数
@end table

@itemize @bullet
@item localhost で @code{ox_sm1_forAsir} をスタートする.
サーバ @code{ox_sm1_forAsir} の識別番号を戻す.
@item @code{Xm_noX = 1} とおくとサーバ @code{ox_sm1_forAsir} をデバッグ用の
ウィンドウなしに起動できる.
@item コマンド @code{ord} を用いて変数順序を正しく設定しておく必要が
ある.
たとえば,
変数 @code{x} と @code{dx} 上の微分作用素環
(@code{dx} は 
@tex $\partial/\partial x$ 
@end tex 
に対応)
で計算しているとき,
@code{sm1} サーバは式を印刷したとき,
変数 @code{dx} は右側に集めれ変数
@code{x} は左側にあつめられていると仮定している.
次の例では, 変数 @code{cc} を @code{sm1} での計算のために用いてはいけない.
@item @code{a} より @code{z} のなかで,  @code{d} と @code{o} を除いたもの,
それから, @code{x0}, ..., @code{x20}, @code{y0}, ..., @code{y20},
@code{z0}, ..., @code{z20} は, デフォールトで微分作用素環の変数として
使える (cf. @code{Sm1_ord_list} in @code{sm1}).
@item 識別番号は @code{static Sm1_proc} に格納される.
この識別番号は関数 @code{sm1.get_Sm1_proc()} でとりだすことができる.
@end itemize
*/
/*&C
@example
[260] ord([da,a,db,b]);
[da,a,db,b,dx,dy,dz,x,y,z,dt,ds,t,s,u,v,w, 
......... omit ..................
]
[261] a*da;
a*da
[262] cc*dcc;
dcc*cc
[263] sm1.mul(da,a,[a]);     
a*da+1                  
[264] sm1.mul(a,da,[a]);
a*da
@end example
*/
/*&en
@table @t
@item Reference
    @code{ox_launch}, @code{sm1.push_int0}, @code{sm1.push_poly0},
    @code{ord}
@end table
*/
/*&ja
@table @t
@item 参照
    @code{ox_launch}, @code{sm1.push_int0}, @code{sm1.push_poly0},
    @code{ord}
@end table
*/



/*&en
@c sort-sm1
@node sm1.sm1,,, SM1 Functions
@subsection @code{sm1.sm1}
@findex sm1.sm1
@table @t
@item sm1.sm1(@var{p},@var{s})
::  ask the @code{sm1} server to execute the command string @var{s}.
@end table

@table @var
@item return
Void
@item p
Number
@item s
String
@end table

@itemize @bullet
@item  It asks the @code{sm1} server of the descriptor number @var{p}
to execute the command string @var{s}.
(In the next example, the descriptor number is 0.)
@end itemize
*/
/*&ja
@node sm1.sm1,,, SM1 Functions
@subsection @code{sm1.sm1}
@findex sm1.sm1
@table @t
@item sm1.sm1(@var{p},@var{s})
::  サーバ @code{sm1} にコマンド列 @var{s} を実行してくれるようにたのむ.
@end table

@table @var
@item return
なし
@item p
数
@item s
文字列
@end table

@itemize @bullet
@item  識別番号 @var{p} の @code{sm1} サーバに
コマンド列 @var{s} を実行してくれるように頼む.
 (次の例では, 識別番号 0)
@end itemize
*/
/*&C
@example
[261] sm1.sm1(0," ( (x-1)^2 ) . ");
0
[262] ox_pop_string(0);
x^2-2*x+1
[263] sm1.sm1(0," [(x*(x-1))  [(x)]] deRham ");
0
[264] ox_pop_string(0);
[1 , 2]
@end example
*/

/*&ja
@table @t
@item 参照
    @code{sm1.start}, @code{ox_push_int0}, @code{sm1.push_poly0}, @code{sm1.get_Sm1_proc()}. 
@end table
*/
/*&en
@table @t
@item Reference
    @code{sm1.start}, @code{ox_push_int0}, @code{sm1.push_poly0}, @code{sm1.get_Sm1_proc()}. 
@end table
*/


/*&en
@c sort-sm1.push_int0
@node sm1.push_int0,,, SM1 Functions
@subsection @code{sm1.push_int0}
@findex sm1.push_int0
@table @t
@item sm1.push_int0(@var{p},@var{f})
::   push the object @var{f} to the server with the descriptor number @var{p}.
@end table

@table @var
@item return
Void
@item p
Number
@item f
Object
@end table

@itemize @bullet
@item When @code{type(@var{f})} is 2 (recursive polynomial),
    @var{f} is converted to a string (type == 7) 
    and is sent to the server by @code{ox_push_cmo}.
@item When @code{type(@var{f})} is 0 (zero), 
     it is translated to the 32 bit integer zero
    on the server.  
    Note that @code{ox_push_cmo(@var{p},0)} sends @code{CMO_NULL} to the server.
In other words, the server does not get the 32 bit integer 0 nor
the bignum 0.
@item  @code{sm1} integers are classfied into the 32 bit integer and
the bignum.
When @code{type(@var{f})} is 1 (number), it is translated to the
32 bit integer on the server.
Note that @code{ox_push_cmo(@var{p},1234)} send the bignum 1234 to the
@code{sm1} server.
@item In other cases,  @code{ox_push_cmo} is called without data conversion.
@end itemize
*/
/*&ja
@c sort-sm1.push_int0
@node sm1.push_int0,,, SM1 Functions
@subsection @code{sm1.push_int0}
@findex sm1.push_int0
@table @t
@item sm1.push_int0(@var{p},@var{f})
::   オブジェクト @var{f} を識別子 @var{p} のサーバへ送る.
@end table

@table @var
@item return
なし
@item p
数
@item f
オブジェクト
@end table

@itemize @bullet
@item @code{type(@var{f})} が 2 (再帰多項式) のとき,
    @var{f} は文字列 (type == 7) に変換されて,
    @code{ox_push_cmo} を用いてサーバへ送られる.
@item @code{type(@var{f})} が 0 (zero) のときは, 
    サーバ上では, 32 bit 整数と解釈される.
    なお @code{ox_push_cmo(P,0)} はサーバに対して @code{CMO_NULL}
をおくるので, サーバ側では, 32 bit 整数を受け取るわけではない.
@item  @code{sm1} の整数は, 32 bit 整数と bignum にわけることができる.
@code{type(@var{f})} が 1 (数)のとき, この関数は 32 bit integer をサーバに
おくる.
@code{ox_push_cmo(@var{p},1234)} は bignum の 1234 を
@code{sm1} サーバにおくることに注意しよう.
@item その他の場合には  @code{ox_push_cmo} をデータ型の変換なしに呼び出す.
@end itemize
*/
/*&C
@example
[219] P=sm1.start();
0
[220] sm1.push_int0(P,x*dx+1);
0
[221] A=ox_pop_cmo(P);
x*dx+1
[223] type(A);
7   (string)
@end example

@example
[271] sm1.push_int0(0,[x*(x-1),[x]]);
0
[272] ox_execute_string(0," deRham ");
0
[273] ox_pop_cmo(0);
[1,2]
@end example
*/
/*&en
@table @t
@item Reference
    @code{ox_push_cmo}
@end table
*/
/*&ja
@table @t
@item Reference
    @code{ox_push_cmo}
@end table
*/



/*&en
@c sort-sm1.gb
@node sm1.gb,,, SM1 Functions
@subsection @code{sm1.gb}
@findex sm1.gb
@findex sm1.gb_d
@table @t
@item sm1.gb([@var{f},@var{v},@var{w}]|proc=@var{p},sorted=@var{q},dehomogenize=@var{r},needBack=@var{n},ring_var=@var{r})
::  computes the Grobner basis of @var{f} in the ring of differential
operators with the variable @var{v}.
@item sm1.gb_d([@var{f},@var{v},@var{w}]|proc=@var{p})
::  computes the Grobner basis of @var{f} in the ring of differential
operators with the variable @var{v}. 
The result will be returned as a list of distributed polynomials.
@end table

@table @var
@item return
List
@item p, q, r
Number
@item f, v, w
List
@end table

@itemize @bullet
@item
   It returns the Grobner basis of the set of polynomials @var{f} 
   in the ring of deferential operators with the variables @var{v}.
@item
   The weight vectors are given by @var{w}, which can be omitted.
    If @var{w} is not given, 
    the graded reverse lexicographic order will be used to compute Grobner basis.   
@item
   The return value of @code{sm1.gb}
    is the list of the Grobner basis of @var{f} and the initial
    terms (when @var{w} is not given) or initial ideal (when @var{w} is given).
@item
   @code{sm1.gb_d} returns the results by a list of distributed polynomials.
    Monomials in each distributed polynomial are ordered in the given order.
    The return value consists of
    [variable names, order matrix, grobner basis in districuted polynomials,
     initial monomials or initial polynomials].
@item
   When a non-term order is given, the Grobner basis is computed in 
   the homogenized Weyl algebra  (See Section 1.2 of the book of SST).
   The homogenization variable h is automatically added.
@item
   When the optional variable @var{q} is set, @code{sm1.gb} returns,
   as the third return value, a list of
   the Grobner basis and the initial ideal
   with sums of monomials sorted by the given order.
   Each polynomial is expressed as a string temporally for now.
   When the optional variable @var{r} is set to one,
   the polynomials are dehomogenized (,i.e., h is set to 1).
@item If you want to have a reduced basis or compute the initial form ideal exactly, 
execute sm1.auto_reduce(1) before executing this function.
@item When the needBack option @var{n} is 1, it returns the answer is a different format as [groebner basis,initial, gb,1,all,[groebner basis, backward transformation]]
@item The default value of ring_var is ring_var_for_asir. The server ox_sm1 saves the ring structure used to the global this ring_var. See also reduction.
@end itemize
*/
/*&ja
@c sort-sm1.gb
@node sm1.gb,,, SM1 Functions
@subsection @code{sm1.gb}
@findex sm1.gb
@findex sm1.gb_d
@table @t
@item sm1.gb([@var{f},@var{v},@var{w}]|proc=@var{p},sorted=@var{q},dehomogenize=@var{r},needBack=@var{n},ring_var=@var{r})
::  @var{v} 上の微分作用素環において @var{f} のグレブナ基底を計算する.
@item sm1.gb_d([@var{f},@var{v},@var{w}]|proc=@var{p})
::  @var{v} 上の微分作用素環において @var{f} のグレブナ基底を計算する. 結果を分散多項式のリストで戻す.
@end table

@table @var
@item return
リスト
@item p, q, r
数
@item f, v, w
リスト
@end table

@itemize @bullet
@item
   @var{v} 上の微分作用素環において @var{f} のグレブナ基底を計算する.
@item
   Weight ベクトル @var{w} は省略してよい.
   省略した場合, graded reverse lexicographic order をつかって
   ブレブナ基底を計算する.
@item
   @code{sm1.gb} の戻り値は @var{f} のグレブナ基底およびイニシャルモノミアル
  ( @var{w} がないとき ) または イニシァル多項式 ( @var{w} が与えらたとき)
  のリストである.
@item
   @code{sm1.gb_d} は結果を分散多項式のリストで戻す.
    多項式の中に現れるモノミアルはグレブナ基底を計算するときに与えらた順序でソートされている.
   戻り値は
    [変数名のリスト, 順序をきめる行列, グレブナ基底, イニシャルモノミアルまたはイニシァル多項式]
   である.
@item
   Term order でない順序が与えられた場合は, 同次化ワイル代数でグレブナ基底が計算される (SST の本の Section 1.2 を見よ).
同次化変数 @code{h} が結果に加わる.
@item オプショナル変数 @var{q} がセットされているときは,
    3 番目の戻り値として, グレブナ基底およびイニシァルのリストが
    与えられた順序でソートされたモノミアルの和として戻される.
    いまのところこの多項式は, 文字列で表現される.
    オプショナル変数 @var{r} がセットされているときは,
    戻り多項式は dehomogenize される (すなわち h に 1 が代入される).
@item Reduced グレブナー基底または in_w を計算したいときは, この関数の実行の前に
sm1.auto_reduce(1) を実行しておくこと.
@item needBack オプションが 1 の時は, 他の場合とは異なる形式
[groebner basis, initial, gb,1,all, [groebner basis, backward transformation]]
で答えを戻す. (sm1 の getAttribute を参照)
@item ring_var オプションの既定値は ring_var_for_asir である. sm1 はこの大域変数名で計算に用いた ring 構造体を保存する.  reduction を参照.
@end itemize
*/
/*&C
@example
[293] sm1.gb([[x*dx+y*dy-1,x*y*dx*dy-2],[x,y]]);
[[x*dx+y*dy-1,y^2*dy^2+2],[x*dx,y^2*dy^2]]
@end example
*/
/*&en
In the example above,
@tex the set $\{ x \partial_x + y \partial_y -1,
                 y^2 \partial_y^2+2\}$ 
is the Gr\"obner basis of the input with respect to the 
graded reverse lexicographic order such that
$ 1 \leq \partial_y \leq \partial_x \leq y \leq x \leq \cdots$.
The set $\{x \partial_x, y^2 \partial_y\}$ is the leading monomials
(the initial monominals) of the Gr\"obner basis.
@end tex
*/
/*&ja
上の例において,
@tex 集合 $\{ x \partial_x + y \partial_y -1,
                 y^2 \partial_y^2+2\}$ 
は
$ 1 \leq \partial_y \leq \partial_x \leq y \leq x \leq \cdots$
であるような
graded reverse lexicographic order に関するグレブナ基底である.
集合 $\{x \partial_x, y^2 \partial_y\}$ はグレブナ基底の各元に
対する leading monomial (initial monomial) である.
@end tex
*/
/*&C
@example
[294] sm1.gb([[dx^2+dy^2-4,dx*dy-1],[x,y],[[dx,50,dy,2,x,1]]]);
[[dx+dy^3-4*dy,-dy^4+4*dy^2-1],[dx,-dy^4]]
@end example
*/
/*&en
In the example above, two monomials 
@tex
$m = x^a y^b \partial_x^c \partial_y^d$ and 
$m' = x^{a'} y^{b'} \partial_x^{c'} \partial_y^{d'}$
are firstly compared by the weight vector 
{\tt (dx,dy,x,y) = (50,2,1,0)}
(i.e., $m$ is larger than $m'$ if $50c+2d+a > 50c'+2d'+a'$)
and when the comparison is tie, then these are 
compared by the reverse lexicographic order
(i.e., if $50c+2d+a = 50c'+2d'+a'$, then use the reverse lexicogrpahic order).
@end tex
*/
/*&ja
上の例において二つのモノミアル
@tex
$m = x^a y^b \partial_x^c \partial_y^d$ および
$m' = x^{a'} y^{b'} \partial_x^{c'} \partial_y^{d'}$
は最初に weight vector
{\tt (dx,dy,x,y) = (50,2,1,0)} を用いて比較される
(つまり $m$ は $50c+2d+a > 50c'+2d'+a'$ のとき
 $m'$ より大きい )
次にこの比較で勝負がつかないときは reverse lexicographic order で比較される
(つまり $50c+2d+a = 50c'+2d'+a'$ のとき reverse lexicographic order で比較
される).
@end tex
*/
/*&C
@example
[294] F=sm1.gb([[dx^2+dy^2-4,dx*dy-1],[x,y],[[dx,50,dy,2,x,1]]]|sorted=1);
      map(print,F[2][0])$
      map(print,F[2][1])$
@end example
*/
/*&C
@example
[595]
   sm1.gb([["dx*(x*dx +y*dy-2)-1","dy*(x*dx + y*dy -2)-1"],
             [x,y],[[dx,1,x,-1],[dy,1]]]);

[[x*dx^2+(y*dy-h^2)*dx-h^3,x*dy*dx+y*dy^2-h^2*dy-h^3,h^3*dx-h^3*dy],
 [x*dx^2+(y*dy-h^2)*dx,x*dy*dx+y*dy^2-h^2*dy-h^3,h^3*dx]]

[596]
   sm1.gb_d([["dx (x dx +y dy-2)-1","dy (x dx + y dy -2)-1"],
             "x,y",[[dx,1,x,-1],[dy,1]]]);
[[[e0,x,y,H,E,dx,dy,h],
 [[0,-1,0,0,0,1,0,0],[0,0,0,0,0,0,1,0],[1,0,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,0],[0,0,0,0,0,0,-1,0],[0,0,0,0,0,-1,0,0],
  [0,0,0,0,-1,0,0,0],[0,0,0,-1,0,0,0,0],[0,0,-1,0,0,0,0,0],
  [0,0,0,0,0,0,0,1]]],
[[(1)*<<0,0,1,0,0,1,1,0>>+(1)*<<0,1,0,0,0,2,0,0>>+(-1)*<<0,0,0,0,0,1,0,2>>+(-1)*
<<0,0,0,0,0,0,0,3>>,(1)*<<0,0,1,0,0,0,2,0>>+(1)*<<0,1,0,0,0,1,1,0>>+(-1)*<<0,0,0
,0,0,0,1,2>>+(-1)*<<0,0,0,0,0,0,0,3>>,(1)*<<0,0,0,0,0,1,0,3>>+(-1)*<<0,0,0,0,0,0
,1,3>>],
 [(1)*<<0,0,1,0,0,1,1,0>>+(1)*<<0,1,0,0,0,2,0,0>>+(-1)*<<0,0,0,0,0,1,0,2>>,(1)*<
<0,0,1,0,0,0,2,0>>+(1)*<<0,1,0,0,0,1,1,0>>+(-1)*<<0,0,0,0,0,0,1,2>>+(-1)*<<0,0,0
,0,0,0,0,3>>,(1)*<<0,0,0,0,0,1,0,3>>]]]
@end example
*/
/*&C
@example
[1834] sm1.gb([[dx^2-x,dx],[x]] | needBack=1);
[[dx,dx^2-x,1],[dx,dx^2,1],gb,1,all,[[dx,dx^2-x,1],[[0,1],[1,0],[-dx,dx^2-x]]]]
@end example
*/

/*&en
@table @t
@item Reference
    @code{sm1.auto_reduce}, @code{sm1.reduction}, @code{sm1.rat_to_p}
@end table
*/
/*&ja
@table @t
@item 参照
    @code{sm1.auto_reduce}, @code{sm1.reduction}, @code{sm1.rat_to_p}
@end table
*/



/*&en
@c sort-sm1.deRham
@node sm1.deRham,,, SM1 Functions
@subsection @code{sm1.deRham}
@findex sm1.deRham
@table @t
@item sm1.deRham([@var{f},@var{v}]|proc=@var{p})
::  ask the server to evaluate the dimensions of the de Rham cohomology  groups
of C^n - (the zero set of @var{f}=0).
@end table

@table @var
@item return
List
@item p
Number
@item f
String or polynomial
@item v
List
@end table

@itemize @bullet
@item  It returns the dimensions of the de Rham cohomology groups
    of X = C^n \ V(@var{f}).
   In other words,  it returns
      [dim H^0(X,C), dim H^1(X,C), dim H^2(X,C), ..., dim H^n(X,C)].
@item   @var{v} is a list of variables. n = @code{length(@var{v})}.
@item
   @code{sm1.deRham} requires huge computer resources.
    For example, @code{sm1.deRham(0,[x*y*z*(x+y+z-1)*(x-y),[x,y,z]])}
    is already very hard.
@item
 To efficiently analyze the roots of b-function, @code{ox_asir} should be used 
  from @code{ox_sm1_forAsir}.
    It is recommended to load the communication module for @code{ox_asir}
    by the command @*
   @code{sm1(0,"[(parse) (oxasir.sm1) pushfile] extension");}
 This command is automatically executed when @code{ox_sm1_forAsir} is started.
@item If you make an interruption to the function @code{sm1.deRham}
by @code{ox_reset(sm1.get_Sm1_proc());}, the server might get out of the standard
mode. So, it is strongly recommended to execute the command
@code{ox_shutdown(sm1.get_Sm1_proc());} to interrupt and restart the server.
@end itemize
*/
/*&ja
@c sort-sm1.deRham
@node sm1.deRham,,, SM1 Functions
@subsection @code{sm1.deRham}
@findex sm1.deRham
@table @t
@item sm1.deRham([@var{f},@var{v}]|proc=@var{p})
::  空間 C^n - (the zero set of @var{f}=0) のドラームコホモロジ群の次元を計算してくれるようにサーバに頼む.
@end table

@table @var
@item return
リスト
@item p
数
@item f
文字列 または 多項式
@item v
リスト
@end table

@itemize @bullet
@item この函数は空間 X = C^n \ V(@var{f}) のドラームコホモロジ群の次元を計算する.
   すなわち,
   [dim H^0(X,C), dim H^1(X,C), dim H^2(X,C), ..., dim H^n(X,C)]
   を戻す.
@item   @var{v} は変数のリスト. n = @code{length(@var{v})} である.
@item
   @code{sm1.deRham} は計算機の資源を大量に使用する.
    たとえば @code{sm1.deRham(0,[x*y*z*(x+y+z-1)*(x-y),[x,y,z]])}
   の計算すらすでに非常に大変である.
@item
  b-関数の根を効率よく解析するには, @code{ox_asir} が @code{ox_sm1_forAsir}
  より使用されるべきである.  コマンド @*
   @code{sm1(0,"[(parse) (oxasir.sm1) pushfile] extension");}
   を用いて, @code{ox_asir} との通信モジュールをあらかじめロードしておくとよい.
   このコマンドは @code{ox_asir_forAsir} のスタート時に自動的に実行されている.
@item
  @code{sm1.deRham} を @code{ox_reset(sm1.get_Sm1_proc());} で中断すると, 
  以後 sm1 サーバが非標準モードに入り予期しない動作をする場合
  があるので, コマンド @code{ox_shutdown(sm1.get_Sm1_proc());} で, @code{ox_sm1_forAsir}
  を一時 shutdown してリスタートした方が安全である.
@end itemize
*/
/*&C
@example
[332] sm1.deRham([x^3-y^2,[x,y]]);
[1,1,0]
[333] sm1.deRham([x*(x-1),[x]]);
[1,2]
@end example
*/
/*&en
@table @t
@item Reference
    @code{sm1.start}, @code{deRham} (sm1 command)
@item Algorithm:
    Oaku, Takayama, An algorithm for de Rham cohomology groups of the
    complement of an affine variety via D-module computation, 
    Journal of pure and applied algebra 139 (1999), 201--233.
@end table
*/
/*&ja
@table @t
@item 参照
    @code{sm1.start}, @code{deRham} (sm1 command)
@item Algorithm:
    Oaku, Takayama, An algorithm for de Rham cohomology groups of the
    complement of an affine variety via D-module computation, 
    Journal of pure and applied algebra 139 (1999), 201--233.
@end table
*/




/*&en
@c sort-sm1.hilbert
@node sm1.hilbert,,, SM1 Functions
@subsection @code{sm1.hilbert}
@findex sm1.hilbert
@findex hilbert_polynomial
@table @t
@item sm1.hilbert([@var{f},@var{v}]|proc=@var{p})
::  ask the server to compute the Hilbert polynomial for the set of polynomials @var{f}.
@item hilbert_polynomial(@var{f},@var{v})
::  ask the server to compute the Hilbert polynomial for the set of polynomials @var{f}.
@end table

@table @var
@item return
Polynomial
@item p
Number
@item f, v
List
@end table

@itemize @bullet
@item  It returns the Hilbert polynomial h(k) of the set of polynomials 
    @var{f}
    with respect to the set of variables @var{v}.
@item
    h(k) = dim_Q F_k/I \cap F_k  where F_k the set of polynomials of which
    degree is less than or equal to k and I is the ideal generated by the
    set of polynomials @var{f}.
@item
   Note for sm1.hilbert:
   For an efficient computation, it is preferable that 
   the set of polynomials @var{f} is a set of monomials.
   In fact, this function firstly compute a Grobner basis of @var{f}, and then
   compute the Hilbert polynomial of the initial monomials of the basis. 
   If the input @var{f} is already a Grobner
   basis, a Grobner basis is recomputed in this function, 
   which is a waste of time and Grobner basis computation in the ring of
   polynomials in @code{sm1} is  slower than in @code{asir}.
@end itemize
*/
/*&ja
@c sort-sm1.hilbert
@node sm1.hilbert,,, SM1 Functions
@subsection @code{sm1.hilbert}
@findex sm1.hilbert
@findex hilbert_polynomial
@table @t
@item sm1.hilbert([@var{f},@var{v}]|proc=@var{p})
:: 多項式の集合 @var{f} のヒルベルト多項式を計算する.
@item hilbert_polynomial(@var{f},@var{v})
:: 多項式の集合 @var{f} のヒルベルト多項式を計算する.
@end table

@table @var
@item return
多項式
@item p
数
@item f, v
リスト
@end table

@itemize @bullet
@item  多項式の集合 @var{f} の変数 @var{v} にかんするヒルベルト多項式 h(k)
   を計算する.
@item
    h(k) = dim_Q F_k/I \cap F_k  ここで F_k は次数が k 以下であるような
    多項式の集合である. I は多項式の集合 @var{f} で生成されるイデアルである.
@item
   sm1.hilbert にかんするノート:
   効率よく計算するには @var{f} はモノミアルの集合にした方がいい.
   実際, この函数はまず @var{f} のグレブナ基底を計算し, それからその initial 
   monomial 達のヒルベルト多項式を計算する. 
  したがって, 入力 @var{f} がすでにグレブナ基底だとこの函数のなかでもう一度
   グレブナ基底の計算がおこなわれる. これは時間の無駄であるし, @code{sm1} の
  多項式グレブナ基底計算は @code{asir} より遅い.
@end itemize
*/

/*&C
@example

[346] load("katsura")$
[351] A=hilbert_polynomial(katsura(5),[u0,u1,u2,u3,u4,u5]);
32

@end example

@example
[279] load("katsura")$
[280] A=gr(katsura(5),[u0,u1,u2,u3,u4,u5],0)$
[281] dp_ord();
0
[282] B=map(dp_ht,map(dp_ptod,A,[u0,u1,u2,u3,u4,u5]));
[(1)*<<1,0,0,0,0,0>>,(1)*<<0,0,0,2,0,0>>,(1)*<<0,0,1,1,0,0>>,(1)*<<0,0,2,0,0,0>>,
 (1)*<<0,1,1,0,0,0>>,(1)*<<0,2,0,0,0,0>>,(1)*<<0,0,0,1,1,1>>,(1)*<<0,0,0,1,2,0>>,
 (1)*<<0,0,1,0,2,0>>,(1)*<<0,1,0,0,2,0>>,(1)*<<0,1,0,1,1,0>>,(1)*<<0,0,0,0,2,2>>,
  (1)*<<0,0,1,0,1,2>>,(1)*<<0,1,0,0,1,2>>,(1)*<<0,1,0,1,0,2>>,(1)*<<0,0,0,0,3,1>>,
  (1)*<<0,0,0,0,4,0>>,(1)*<<0,0,0,0,1,4>>,(1)*<<0,0,0,1,0,4>>,(1)*<<0,0,1,0,0,4>>,
 (1)*<<0,1,0,0,0,4>>,(1)*<<0,0,0,0,0,6>>]
[283] C=map(dp_dtop,B,[u0,u1,u2,u3,u4,u5]);
[u0,u3^2,u3*u2,u2^2,u2*u1,u1^2,u5*u4*u3,u4^2*u3,u4^2*u2,u4^2*u1,u4*u3*u1,
 u5^2*u4^2,u5^2*u4*u2,u5^2*u4*u1,u5^2*u3*u1,u5*u4^3,u4^4,u5^4*u4,u5^4*u3,
 u5^4*u2,u5^4*u1,u5^6]
[284] sm1.hilbert([C,[u0,u1,u2,u3,u4,u5]]);
32
@end example
*/

/*&en
@table @t
@item Reference
    @code{sm1.start}, @code{sm1.gb}, @code{longname}
@end table
*/
/*&ja
@table @t
@item 参照
    @code{sm1.start}, @code{sm1.gb}, @code{longname}
@end table
*/


/*&en
@c sort-sm1.genericAnn
@node sm1.genericAnn,,, SM1 Functions
@subsection @code{sm1.genericAnn}
@findex sm1.genericAnn
@table @t
@item sm1.genericAnn([@var{f},@var{v}]|proc=@var{p})
::  It computes  the annihilating ideal for @var{f}^s.
    @var{v} is the list of variables.  Here, s is @var{v}[0] and
    @var{f} is a polynomial in the variables @code{rest}(@var{v}).
@end table

@table @var
@item return
List
@item p
Number
@item f
Polynomial
@item v
List
@end table

@itemize @bullet
@item  This function computes  the annihilating ideal for @var{f}^s.
    @var{v} is the list of variables.  Here, s is @var{v}[0] and
    @var{f} is a polynomial in the variables @code{rest}(@var{v}).
@end itemize
*/
/*&ja
@c sort-sm1.genericAnn
@node sm1.genericAnn,,, SM1 Functions
@subsection @code{sm1.genericAnn}
@findex sm1.genericAnn
@table @t
@item sm1.genericAnn([@var{f},@var{v}]|proc=@var{p})
::  @var{f}^s のみたす微分方程式全体をもとめる.
    @var{v} は変数のリストである.  ここで, s は @var{v}[0] であり,
    @var{f} は変数 @code{rest}(@var{v}) 上の多項式である.
@end table

@table @var
@item return
リスト
@item p
数
@item f
多項式
@item v
リスト
@end table

@itemize @bullet
@item この函数は,
  @var{f}^s のみたす微分方程式全体をもとめる.
    @var{v} は変数のリストである.  ここで, s は @var{v}[0] であり,
    @var{f} は変数 @code{rest}(@var{v}) 上の多項式である.
@end itemize
*/
/*&C
@example
[595] sm1.genericAnn([x^3+y^3+z^3,[s,x,y,z]]);
[-x*dx-y*dy-z*dz+3*s,z^2*dy-y^2*dz,z^2*dx-x^2*dz,y^2*dx-x^2*dy]
@end example
*/
/*&en
@table @t
@item Reference
    @code{sm1.start}
@end table
*/
/*&ja
@table @t
@item 参照
    @code{sm1.start}
@end table
*/



/*&en
@c sort-sm1.wTensor0
@node sm1.wTensor0,,, SM1 Functions
@subsection @code{sm1.wTensor0}
@findex sm1.wTensor0
@table @t
@item sm1.wTensor0([@var{f},@var{g},@var{v},@var{w}]|proc=@var{p})
::   It computes the D-module theoretic 0-th tensor product
    of @var{f} and @var{g}.
@end table

@table @var
@item return
List
@item p
Number
@item f, g, v, w
List
@end table

@itemize @bullet
@item 
   It returns the D-module theoretic 0-th tensor product
   of @var{f} and @var{g}.
@item
  @var{v} is a list of variables.
  @var{w} is a list of weights.  The integer @var{w}[i] is
  the weight of the variable @var{v}[i].
@item 
   @code{sm1.wTensor0} calls @code{wRestriction0} of @code{ox_sm1}, 
   which requires a generic weight
    vector @var{w} to compute the restriction.
    If @var{w} is not generic, the computation fails.
@item Let F and G be solutions of @var{f} and @var{g} respectively.
Intuitively speaking, the 0-th tensor product is a system of
differential equations which annihilates the function FG.
@item The answer is a submodule of a free module D^r in general even if
the inputs @var{f} and @var{g} are left ideals of D.
@end itemize
*/

/*&ja
@c sort-sm1.wTensor0
@node sm1.wTensor0,,, SM1 Functions
@subsection @code{sm1.wTensor0}
@findex sm1.wTensor0
@table @t
@item sm1.wTensor0([@var{f},@var{g},@var{v},@var{w}]|proc=@var{p})
::   @var{f} と @var{g} の D-module としての 0 次テンソル積を
計算する.
@end table

@table @var
@item return
リスト
@item p
数
@item f, g, v, w
リスト
@end table

@itemize @bullet
@item 
   @var{f} と @var{g} の
   D-加群としての 0 次テンソル積を計算する.
@item
  @var{v} は変数のリストである.
  @var{w} は weight のリストである.  
  整数 @var{w}[i] は変数 @var{v}[i] の weight である.
@item 
   @code{sm1.wTensor0} は @code{ox_sm1} の @code{wRestriction0}
   をよんでいる.
  @code{wRestriction0} は, generic な weight ベクトル @var{w}
  をもとにして制限を計算している.
  Weight ベクトル @var{w} が generic でないと計算がエラーで停止する.
@item F および G を @var{f} と  @var{g} それぞれの解とする.
直観的にいえば, 0 次のテンソル積は 関数 FG のみたす微分方程式系である.
@item 入力 @var{f}, @var{g} が D の左イデアルであっても,
一般に, 出力は自由加群 D^r の部分加群である.
@end itemize
*/
/*&C
@example
[258]  sm1.wTensor0([[x*dx -1, y*dy -4],[dx+dy,dx-dy^2],[x,y],[1,2]]);
[[-y*x*dx-y*x*dy+4*x+y],[5*x*dx^2+5*x*dx+2*y*dy^2+(-2*y-6)*dy+3],
 [-25*x*dx+(-5*y*x-2*y^2)*dy^2+((5*y+15)*x+2*y^2+16*y)*dy-20*x-8*y-15],
 [y^2*dy^2+(-y^2-8*y)*dy+4*y+20]]
@end example
*/



/*&en
@c sort-sm1.reduction
@node sm1.reduction,,, SM1 Functions
@subsection @code{sm1.reduction}
@findex sm1.reduction
@table @t
@item sm1.reduction([@var{f},@var{g},@var{v},@var{w}]|proc=@var{p})
@item sm1.reduction([@var{f},@var{g},@var{v}]|proc=@var{p})
@item sm1.reduction([@var{f},@var{g}]|proc=@var{p},ring_var=@var{r})
@item sm1.reduction_verbose([@var{f},@var{g},@var{v},@var{w}]|proc=@var{p})
::  
@end table

@table @var
@item return
List
@item f
Polynomial
@item g, v, w
List
@item p
Number  (the process number of ox_sm1)
@end table

@itemize @bullet
@item  It reduces @var{f} by the set of polynomial @var{g}
in the homogenized Weyl algebra; it applies the
division algorithm to @var{f}. The set of variables is @var{v} and
@var{w} is weight vectors to determine the order, which can be ommited.
@code{sm1.reduction_noH} is for the Weyl algebra.
@item The return value is of the form
[r,c0,[c1,...,cm],[g1,...gm]] where @var{g}=[g1, ..., gm] and
c0 f + c1 g1 + ... + cm gm = r.
r/c0 is the normal form.
@item The function reduction reduces reducible terms that appear
in lower order terms.
@item  The functions 
sm1.reduction_d(P,F,G) and sm1.reduction_noH_d(P,F,G)
are for distributed polynomials.
@item When the arguments are two, the function mod_reduction is called. It uses the ring
structure saved in the global variable ring_var in the ox_sm1 server.
@item The return value of reduction_verbose is of the form
[r,c0,[c1,...,cm],[g1,...gm],init,order] where init is the initial of r and order is the order structure used.
@end itemize
*/
/*&ja
@node sm1.reduction,,, SM1 Functions
@subsection @code{sm1.reduction}
@findex sm1.reduction
@table @t
@item sm1.reduction([@var{f},@var{g},@var{v},@var{w}]|proc=@var{p})
@item sm1.reduction([@var{f},@var{g},@var{v}]|proc=@var{p})
@item sm1.reduction([@var{f},@var{g}]|proc=@var{p},ring_var=@var{r})
@item sm1.reduction_verbose([@var{f},@var{g},@var{v},@var{w}]|proc=@var{p})
::  
@end table

@table @var
@item return
リスト
@item f
多項式
@item g, v, w
リスト
@item p
数  (ox_sm1 のプロセス番号)
@end table

@itemize @bullet
@item  この函数は @var{f} を homogenized ワイル代数において,
多項式集合 @var{g} で簡単化 (reduce) する; つまり,
この函数は, @var{f} に割算アルゴリズムを適用する.
変数集合は @var{v} で指定する.
@var{w} は順序を指定するための ウエイトベクトルであり,
省略してもよい.
@code{sm1.reduction_noH} は, Weyl algebra 用.
@item 戻り値は次の形をしている:
[r,c0,[c1,...,cm],g] ここで @var{g}=[g1, ..., gm] であり,
c0 f + c1 g1 + ... + cm gm = r
がなりたつ.
r/c0 が normal form である.
@item この函数は, 低次項にあらわれる reducible な項も簡単化する.
@item  函数
sm1.reduction_d(P,F,G) および sm1.reduction_noH_d(P,F,G)
は, 分散多項式用である.
@item 引数が２つの時は mod_reduction 関数が呼ばれる. これは ox_sm1 の大域変数 
ring_var 変数に保存された ring において簡約を行う. auto_reduce(1) が自動でセットされる.
gb を参照.
@item reduction_verbose の戻り値は
[r,c0,[c1,...,cm],[g1,...gm],init,order] ここで init は 順序 order による r の initial.
@end itemize
*/
/*&C
@example
[259] sm1.reduction([x^2+y^2-4,[y^4-4*y^2+1,x+y^3-4*y],[x,y]]);
[x^2+y^2-4,1,[0,0],[y^4-4*y^2+1,x+y^3-4*y]]
[260] sm1.reduction([x^2+y^2-4,[y^4-4*y^2+1,x+y^3-4*y],[x,y],[[x,1]]]);
[0,1,[-y^2+4,-x+y^3-4*y],[y^4-4*y^2+1,x+y^3-4*y]]

[1837] XM_debug=0$ S=sm1.syz([ [x^2-1,x^3-1,x^4-1],[x]])$                        
[1838] sm1.auto_reduce(1);
1
[1839] S0=sm1.gb([S[0],[x]]);
[[[-x^2-x-1,x+1,0],[x^2+1,0,-1]],[[0,x,0],[0,0,-1]]]
[1840] sm1.reduction([ [-x^4-x^3-x^2-x,x^3+x^2+x+1,-1], S0[0]]);
[[0,0,0],-1,[[x^2+1,0,0],[1,0,0]],[[-x^2-x-1,x+1,0],[x^2+1,0,-1]]]
@end example
*/

/*&C
@example
XM_debug=0$
sm1.auto_reduce(1)$
F=[x*y-1,x^2+y^2-4]$
Weight_vec=[[x,10,y,1]]$  
printf("\n\nsyz----\n")$
S=sm1.syz([F,[x,y],Weight_vec]);  // When Weight_vec is given, the TOP order is used.
// If the Weight_vec is not given, the POT order (e.g., (1,0,0)<(0,1,0)<(0,0,1)) with grlex is used.
Sgb=sm1.gb([S[0],[x,y],Weight_vec]);
R0=[x+y,x^2*y+x];
P=R0[0]*F[0]+R0[1]*F[1];
R=sm1.reduction_verbose([R0,Sgb[0],[x,y],Weight_vec]);

printf("\nMinimal representation=%a\n",R[0])$
printf("The initial of minimal rep=%a\n",R[4])$
printf("Order=%a\n",R[5][1][1])$
@end example
*/

/*&en
@table @t
@item Reference
    @code{sm1.start}, @code{d_true_nf}
@end table
*/
/*&ja
@table @t
@item 参照
    @code{sm1.start}, @code{d_true_nf}
@end table
*/


/*&en
@node sm1.xml_tree_to_prefix_string,,, SM1 Functions
@subsection @code{sm1.xml_tree_to_prefix_string}
@findex sm1.xml_tree_to_prefix_string
@table @t
@item sm1.xml_tree_to_prefix_string(@var{s}|proc=@var{p})
:: Translate OpenMath Tree Expression @var{s} in XML to a prefix notation.
@end table

@table @var
@item return
String
@item p
Number
@item s
String
@end table

@itemize @bullet
@item  It translate OpenMath Tree Expression @var{s} in XML to a prefix notation.
@item This function should be moved to om_* in a future.
@item @code{om_xml_to_cmo(OpenMath Tree Expression)} returns CMO_TREE.
asir has not yet understood this CMO.
@item @code{java} execution environment is required.
(For example, @code{/usr/local/jdk1.1.8/bin} should be in the 
command search path.)
@end itemize
*/
/*&ja
@node sm1.xml_tree_to_prefix_string,,, SM1 Functions
@subsection @code{sm1.xml_tree_to_prefix_string}
@findex sm1.xml_tree_to_prefix_string
@table @t
@item sm1.xml_tree_to_prefix_string(@var{s}|proc=@var{p})
:: XML で書かれた OpenMath の木表現 @var{s} を前置記法になおす.
@end table

@table @var
@item return
String
@item p
Number
@item s
String
@end table

@itemize @bullet
@item XML で書かれた OpenMath の木表現 @var{s} を前置記法になおす.
@item この函数は om_* に将来移すべきである.
@item @code{om_xml_to_cmo(OpenMath Tree Expression)} は CMO_TREE
を戻す. @code{asir} はこの CMO をまだサポートしていない.
@item @code{java} の実行環境が必要.
(たとえば, /usr/local/jdk1.1.8/bin をコマンドサーチパスに入れるなど.)
@end itemize
*/
/*&C
@example
[263] load("om");
1
[270] F=om_xml(x^4-1);
control: wait OX
Trying to connect to the server... Done.
<OMOBJ><OMA><OMS name="plus" cd="basic"/><OMA>
<OMS name="times" cd="basic"/><OMA>
<OMS name="power" cd="basic"/><OMV name="x"/><OMI>4</OMI></OMA>
<OMI>1</OMI></OMA><OMA><OMS name="times" cd="basic"/><OMA>
<OMS name="power" cd="basic"/><OMV name="x"/><OMI>0</OMI></OMA>
<OMI>-1</OMI></OMA></OMA></OMOBJ>
[271] sm1.xml_tree_to_prefix_string(F);
basic_plus(basic_times(basic_power(x,4),1),basic_times(basic_power(x,0),-1))
@end example
*/
/*&en
@table @t
@item Reference
    @code{om_*}, @code{OpenXM/src/OpenMath}, @code{eval_str}
@end table
*/
/*&ja
@table @t
@item 参照
    @code{om_*}, @code{OpenXM/src/OpenMath},  @code{eval_str}
@end table
*/




/*&en
@c sort-sm1.syz
@node sm1.syz,,, SM1 Functions
@subsection @code{sm1.syz}
@findex sm1.syz
@findex sm1.syz_d
@table @t
@item sm1.syz([@var{f},@var{v},@var{w}]|proc=@var{p})
::  computes the syzygy of @var{f} in the ring of differential
operators with the variable @var{v}.
@end table

@table @var
@item return
List
@item p
Number
@item f, v, w
List
@end table

@itemize @bullet
@item
The return values is of the form
[@var{s},[@var{g}, @var{m}, @var{t}]].
Here @var{s} is the syzygy of @var{f} in the ring of differential
operators with the variable @var{v}. 
@var{g} is a Groebner basis of @var{f} with the weight vector @var{w},
and @var{m} is a matrix that translates the input matrix @var{f} to the Gr\"obner
basis @var{g}.
@var{t} is the syzygy of the Gr\"obner basis @var{g}.
In summary, @var{g} = @var{m} @var{f} and
@var{s} @var{f} = 0 hold as matrices.
@item
   The weight vectors are given by @var{w}, which can be omitted.
    If @var{w} is not given, 
    the graded reverse lexicographic order will be used to compute Grobner basis.   
@item
   When a non-term order is given, the Grobner basis is computed in 
   the homogenized Weyl algebra  (See Section 1.2 of the book of SST).
   The homogenization variable h is automatically added.
@end itemize
*/
/*&ja
@c sort-sm1.syz
@node sm1.syz,,, SM1 Functions
@subsection @code{sm1.syz}
@findex sm1.syz
@findex sm1.syz_d
@table @t
@item sm1.syz([@var{f},@var{v},@var{w}]|proc=@var{p})
::  @var{v} 上の微分作用素環において @var{f} の syzygy を計算する.
@end table

@table @var
@item return
リスト
@item p
数
@item f, v, w
リスト
@end table

@itemize @bullet
@item
戻り値は次の形をしている:
[@var{s},[@var{g}, @var{m}, @var{t}]].
ここで @var{s} は @var{f} の @var{v} を変数とする微分作用素環における
syzygy である.
@var{g} は @var{f} の weight vector @var{w} に関するグレブナ基底である.
@var{m} は入力行列 @var{f} をグレブナ基底
@var{g} へ変換する行列である.
@var{t} はグレブナ基底 @var{g} の syzygy である.
まとめると, 次の等式がなりたつ:
@var{g} = @var{m} @var{f} ,
@var{s} @var{f} = 0.
@item
   Weight ベクトル @var{w} は省略してよい.
   省略した場合, graded reverse lexicographic order をつかって
   ブレブナ基底を計算する.
@item
   Term order でない順序が与えられた場合は, 同次化ワイル代数でグレブナ基底が計算される (SST の本の Section 1.2 を見よ).
同次化変数 @code{h} が結果に加わる.
@end itemize
*/
/*&C
@example
[293] sm1.syz([[x*dx+y*dy-1,x*y*dx*dy-2],[x,y]]);
[[[y*x*dy*dx-2,-x*dx-y*dy+1]],    generators of the syzygy
 [[[x*dx+y*dy-1],[y^2*dy^2+2]],   grobner basis
  [[1,0],[y*dy,-1]],              transformation matrix
 [[y*x*dy*dx-2,-x*dx-y*dy+1]]]]
@end example
*/
/*&C
@example
[294]sm1.syz([[x^2*dx^2+x*dx+y^2*dy^2+y*dy-4,x*y*dx*dy-1],[x,y],[[dx,-1,x,1]]]);
[[[y*x*dy*dx-1,-x^2*dx^2-x*dx-y^2*dy^2-y*dy+4]], generators of the syzygy
 [[[x^2*dx^2+h^2*x*dx+y^2*dy^2+h^2*y*dy-4*h^4],[y*x*dy*dx-h^4], GB
  [h^4*x*dx+y^3*dy^3+3*h^2*y^2*dy^2-3*h^4*y*dy]],
 [[1,0],[0,1],[y*dy,-x*dx]],     transformation matrix
 [[y*x*dy*dx-h^4,-x^2*dx^2-h^2*x*dx-y^2*dy^2-h^2*y*dy+4*h^4]]]]
@end example
*/



/*&en
@node sm1.mul,,, SM1 Functions
@subsection @code{sm1.mul}
@findex sm1.mul
@table @t
@item sm1.mul(@var{f},@var{g},@var{v}|proc=@var{p})
::  ask the sm1 server to multiply @var{f} and @var{g} in the ring of differential operators over @var{v}.
@end table

@table @var
@item return
Polynomial or List
@item p
Number
@item f, g
Polynomial or List
@item v
List
@end table

@itemize @bullet
@item Ask the sm1 server to multiply @var{f} and @var{g} in the ring of differential operators over @var{v}.
@item @code{sm1.mul_h} is for homogenized Weyl algebra.
@item BUG: @code{sm1.mul(p0*dp0,1,[p0])} returns
@code{dp0*p0+1}.
A variable order such that d-variables come after non-d-variables
is necessary for the correct computation.
@end itemize
*/

/*&ja
@node sm1.mul,,, SM1 Functions
@subsection @code{sm1.mul}
@findex sm1.mul
@table @t
@item sm1.mul(@var{f},@var{g},@var{v}|proc=@var{p})
::  sm1サーバ に @var{f} かける @var{g} を @var{v}
上の微分作用素環でやってくれるように頼む.
@end table

@table @var
@item return
多項式またはリスト
@item p
数
@item f, g
多項式またはリスト
@item v
リスト
@end table

@itemize @bullet
@item   sm1サーバ に @var{f} かける @var{g} を @var{v}
上の微分作用素環でやってくれるように頼む.
@item @code{sm1.mul_h} は homogenized Weyl 代数用.
@item BUG: @code{sm1.mul(p0*dp0,1,[p0])} は
@code{dp0*p0+1} を戻す.  
d変数が後ろにくるような変数順序がはいっていないと, この関数は正しい答えを戻さない.
@end itemize
*/

/*&C

@example
[277] sm1.mul(dx,x,[x]);
x*dx+1
[278] sm1.mul([x,y],[1,2],[x,y]);
x+2*y
[279] sm1.mul([[1,2],[3,4]],[[x,y],[1,2]],[x,y]);
[[x+2,y+4],[3*x+4,3*y+8]]
@end example

*/

	
 

/*&en
@node sm1.distraction,,, SM1 Functions
@subsection @code{sm1.distraction}
@findex sm1.distraction
@table @t
@item sm1.distraction([@var{f},@var{v},@var{x},@var{d},@var{s}]|proc=@var{p})
::  ask the @code{sm1} server to compute the distraction of @var{f}.
@end table

@table @var
@item return
List
@item p
Number
@item f
Polynomial
@item v,x,d,s
List
@end table

@itemize @bullet
@item  It asks the @code{sm1} server of the descriptor number @var{p}
to compute the distraction of  @var{f} in the ring of differential
operators with variables @var{v}.
@item @var{x} is a list of x-variables and @var{d} is that of d-variables
to be distracted. @var{s} is a list of variables to express the distracted @var{f}.
@item Distraction is roughly speaking to replace x*dx by a single variable x.
See Saito, Sturmfels, Takayama : Grobner Deformations of Hypergeometric Differential Equations at page 68 for details.
@end itemize
*/

/*&ja
@node sm1.distraction,,, SM1 Functions

@subsection @code{sm1.distraction}
@findex sm1.distraction
@table @t
@item sm1.distraction([@var{f},@var{v},@var{x},@var{d},@var{s}]|proc=@var{p})
::  @code{sm1} に @var{f} の distraction を計算してもらう.
@end table

@table @var
@item return
リスト
@item p
数
@item f
多項式
@item v,x,d,s
リスト
@end table

@itemize @bullet
@item  識別子 @var{p}  の @code{sm1}  サーバに,
@var{f} の distraction を @var{v} 上の微分作用素環で計算してもらう.
@item @var{x} , @var{d} は, それぞれ, distract すべき x 変数, d 変数の
リスト.  Distraction したら, @var{s} を変数として結果を表す.
@item Distraction というのは x*dx を x で置き換えることである.
詳しくは Saito, Sturmfels, Takayama : Grobner Deformations of Hypergeometric Differential Equations の page 68 を見よ.
@end itemize
*/

/*&C

@example
[280] sm1.distraction([x*dx,[x],[x],[dx],[x]]);
x
[281] sm1.distraction([dx^2,[x],[x],[dx],[x]]);
x^2-x
[282] sm1.distraction([x^2,[x],[x],[dx],[x]]);
x^2+3*x+2
[283] fctr(@@);
[[1,1],[x+1,1],[x+2,1]]
[284] sm1.distraction([x*dx*y+x^2*dx^2*dy,[x,y],[x],[dx],[x]]);
(x^2-x)*dy+x*y
@end example
*/

/*&en
@table @t
@item Reference
    @code{distraction2(sm1)}, 
@end table
*/

/*&ja
@table @t
@item 参照
    @code{distraction2(sm1)}, 
@end table
*/



/*&en
@node sm1.gkz,,, SM1 Functions
@subsection @code{sm1.gkz}
@findex sm1.gkz
@table @t
@item sm1.gkz([@var{A},@var{B}]|proc=@var{p})
::  Returns the GKZ system (A-hypergeometric system) associated to the matrix 
@var{A} with the parameter vector @var{B}.
@end table

@table @var
@item return
List
@item p
Number
@item A, B
List
@end table

@itemize @bullet
@item Returns the GKZ hypergeometric system 
(A-hypergeometric system) associated to the matrix 
@end itemize
*/

/*&ja
@node sm1.gkz,,, SM1 Functions
@subsection @code{sm1.gkz}
@findex sm1.gkz
@table @t
@item sm1.gkz([@var{A},@var{B}]|proc=@var{p})
::  行列 @var{A} とパラメータ @var{B} に付随した GKZ 系 (A-hypergeometric system) をもどす.
@end table

@table @var
@item return
リスト
@item p
数
@item A, B
リスト
@end table

@itemize @bullet
@item  行列 @var{A} とパラメータ @var{B} に付随した GKZ 系 (A-hypergeometric system) をもどす.
@end itemize
*/

/*&C

@example

[280] sm1.gkz([  [[1,1,1,1],[0,1,3,4]],  [0,2] ]);
[[x4*dx4+x3*dx3+x2*dx2+x1*dx1,4*x4*dx4+3*x3*dx3+x2*dx2-2,
 -dx1*dx4+dx2*dx3,-dx2^2*dx4+dx1*dx3^2,dx1^2*dx3-dx2^3,-dx2*dx4^2+dx3^3],
 [x1,x2,x3,x4]]

@end example

*/

/*&en
@node sm1.mgkz,,, SM1 Functions
@subsection @code{sm1.mgkz}
@findex sm1.mgkz
@table @t
@item sm1.mgkz([@var{A},@var{W},@var{B}]|proc=@var{p})
::  Returns the modified GKZ system (A-hypergeometric system) associated to the matrix 
@var{A} and the weight @var{w} with the parameter vector @var{B}.
@end table

@table @var
@item return
List
@item p
Number
@item A, W, B
List
@end table

@itemize @bullet
@item Returns the modified GKZ hypergeometric system 
(A-hypergeometric system) associated to the matrix 
@item http://arxiv.org/abs/0707.0043
@end itemize
*/

/*&ja
@node sm1.mgkz,,, SM1 Functions
@subsection @code{sm1.mgkz}
@findex sm1.mgkz
@table @t
@item sm1.mgkz([@var{A},@var{W},@var{B}]|proc=@var{p})
::  行列 @var{A}, weight @var{W} とパラメータ @var{B} に付随した modified GKZ 系 (A-hypergeometric system) をもどす.
@end table

@table @var
@item return
リスト
@item p
数
@item A, W, B
リスト
@end table

@itemize @bullet
@item  行列 @var{A}, weight vector @var{W} とパラメータ @var{B} に付随した modified GKZ 系 (A-hypergeometric system) をもどす.
@item http://arxiv.org/abs/0707.0043
@end itemize
*/

/*&C

@example

[280] sm1.mgkz([ [[1,2,3]], [1,2,1], [a/2]]);
[[6*x3*dx3+4*x2*dx2+2*x1*dx1-a,-x4*dx4+x3*dx3+2*x2*dx2+x1*dx1,
  -dx2+dx1^2,-x4^2*dx3+dx1*dx2],[x1,x2,x3,x4]]

Modified A-hypergeometric system for 
A=(1,2,3), w=(1,2,1), beta=(a/2).
@end example

*/




/*&en
@node sm1.appell1,,, SM1 Functions
@subsection @code{sm1.appell1}
@findex sm1.appell1
@table @t
@item sm1.appell1(@var{a}|proc=@var{p})
::  Returns the Appell hypergeometric system F_1 or F_D. 
@end table

@table @var
@item return
List
@item p
Number
@item a
List
@end table

@itemize @bullet
@item Returns the hypergeometric system for the Lauricella function
F_D(a,b1,b2,...,bn,c;x1,...,xn)
where @var{a} =(a,c,b1,...,bn).
When n=2, the Lauricella function is called the Appell function F_1.
The parameters a, c, b1, ..., bn may be rational numbers.
@item It does not call sm1 function appell1. As a concequence,
when parameters are rational or symbolic, this function also works
as well as integral parameters.
@end itemize
*/

/*&ja
@node sm1.appell1,,, SM1 Functions
@subsection @code{sm1.appell1}
@findex sm1.appell1
@table @t
@item sm1.appell1(@var{a}|proc=@var{p})
:: F_1 または F_D に対応する方程式系を戻す. 
@end table

@table @var
@item return
リスト
@item p
数
@item a
リスト
@end table

@itemize @bullet
@item Appell の関数 F_1 および その n 変数化である Lauricella の関数
F_D(a,b1,b2,...,bn,c;x1,...,xn)
のみたす微分方程式系を戻す. ここで,
@var{a} =(a,c,b1,...,bn).
パラメータは有理数でもよい.
@item sm1 の関数 appell1 をよぶわけでないので, パラメータが有理数や文字式の場合も
正しく動く.
@end itemize
*/

/*&C

@example

[281] sm1.appell1([1,2,3,4]);
[[((-x1+1)*x2*dx1-3*x2)*dx2+(-x1^2+x1)*dx1^2+(-5*x1+2)*dx1-3,
  (-x2^2+x2)*dx2^2+((-x1*x2+x1)*dx1-6*x2+2)*dx2-4*x1*dx1-4,
  ((-x2+x1)*dx1+3)*dx2-4*dx1],       equations
 [x1,x2]]                            the list of variables

[282] sm1.gb(@@);
[[((-x2+x1)*dx1+3)*dx2-4*dx1,((-x1+1)*x2*dx1-3*x2)*dx2+(-x1^2+x1)*dx1^2
  +(-5*x1+2)*dx1-3,(-x2^2+x2)*dx2^2+((-x2^2+x1)*dx1-3*x2+2)*dx2
  +(-4*x2-4*x1)*dx1-4,
  (x2^3+(-x1-1)*x2^2+x1*x2)*dx2^2+((-x1*x2+x1^2)*dx1+6*x2^2
 +(-3*x1-2)*x2+2*x1)*dx2-4*x1^2*dx1+4*x2-4*x1],
 [x1*dx1*dx2,-x1^2*dx1^2,-x2^2*dx1*dx2,-x1*x2^2*dx2^2]]

[283] sm1.rank(sm1.appell1([1/2,3,5,-1/3]));
3

[285] Mu=2$ Beta = 1/3$
[287] sm1.rank(sm1.appell1([Mu+Beta,Mu+1,Beta,Beta,Beta]));
4


@end example

*/

/*&en
@node sm1.appell4,,, SM1 Functions
@subsection @code{sm1.appell4}
@findex sm1.appell4
@table @t
@item sm1.appell4(@var{a}|proc=@var{p})
::  Returns the Appell hypergeometric system F_4 or F_C. 
@end table

@table @var
@item return
List
@item p
Number
@item a
List
@end table

@itemize @bullet
@item Returns the hypergeometric system for the Lauricella function
F_4(a,b,c1,c2,...,cn;x1,...,xn)
where @var{a} =(a,b,c1,...,cn).
When n=2, the Lauricella function is called the Appell function F_4.
The parameters a, b, c1, ..., cn may be rational numbers.
@item @item It does not call sm1 function appell4. As a concequence,
when parameters are rational or symbolic, this function also works
as well as integral parameters.
@end itemize
*/

/*&ja
@node sm1.appell4,,, SM1 Functions
@subsection @code{sm1.appell4}
@findex sm1.appell4
@table @t
@item sm1.appell4(@var{a}|proc=@var{p})
:: F_4 または F_C に対応する方程式系を戻す. 
@end table

@table @var
@item return
リスト
@item p
数
@item a
リスト
@end table

@itemize @bullet
@item Appell の関数 F_4 および その n 変数化である Lauricella の関数
F_C(a,b,c1,c2,...,cn;x1,...,xn)
のみたす微分方程式系を戻す. ここで,
@var{a} =(a,b,c1,...,cn).
パラメータは有理数でもよい.
@item sm1 の関数 appell1 をよぶわけでないので, パラメータが有理数や文字式の場合も
正しく動く.
@end itemize
*/

/*&C

@example

[281] sm1.appell4([1,2,3,4]);
  [[-x2^2*dx2^2+(-2*x1*x2*dx1-4*x2)*dx2+(-x1^2+x1)*dx1^2+(-4*x1+3)*dx1-2,
  (-x2^2+x2)*dx2^2+(-2*x1*x2*dx1-4*x2+4)*dx2-x1^2*dx1^2-4*x1*dx1-2],
                                                              equations
    [x1,x2]]                                      the list of variables

[282] sm1.rank(@@);
4

@end example

*/




/*&en
@node sm1.rank,,, SM1 Functions
@subsection @code{sm1.rank}
@findex sm1.rank
@table @t
@item sm1.rank(@var{a}|proc=@var{p})
::  Returns the holonomic rank of the system of differential equations @var{a}.
@end table

@table @var
@item return
Number
@item p
Number
@item a
List
@end table

@itemize @bullet
@item It evaluates the dimension of the space of holomorphic solutions
at a generic point of the system of differential equations @var{a}.
The dimension is called the holonomic rank.
@item @var{a} is a list consisting of a list of differential equations and
a list of variables.
@item @code{sm1.rrank} returns the holonomic rank when @var{a} is regular
holonomic. It is generally faster than @code{sm1.rank}.
@end itemize
*/

/*&ja
@node sm1.rank,,, SM1 Functions
@subsection @code{sm1.rank}
@findex sm1.rank
@table @t
@item sm1.rank(@var{a}|proc=@var{p})
::  微分方程式系 @var{a} の holonomic rank を戻す.
@end table

@table @var
@item return
数
@item p
数
@item a
リスト
@end table

@itemize @bullet
@item 微分方程式系 @var{a} の, generic point での正則解の次元を
戻す. この次元を, holonomic rank と呼ぶ.
@item @var{a} は微分作用素のリストと変数のリストよりなる.
@item  @var{a} が regular holonomic のときは @code{sm1.rrank}
も holonomic rank を戻す.
いっぱんにこの関数の方が @code{sm1.rank} より早い.
@end itemize
*/

/*&C

@example

[284]  sm1.gkz([  [[1,1,1,1],[0,1,3,4]],  [0,2] ]);
[[x4*dx4+x3*dx3+x2*dx2+x1*dx1,4*x4*dx4+3*x3*dx3+x2*dx2-2,
  -dx1*dx4+dx2*dx3, -dx2^2*dx4+dx1*dx3^2,dx1^2*dx3-dx2^3,-dx2*dx4^2+dx3^3],
 [x1,x2,x3,x4]]
[285] sm1.rrank(@@);
4

[286]  sm1.gkz([  [[1,1,1,1],[0,1,3,4]],  [1,2]]);
[[x4*dx4+x3*dx3+x2*dx2+x1*dx1-1,4*x4*dx4+3*x3*dx3+x2*dx2-2,
 -dx1*dx4+dx2*dx3,-dx2^2*dx4+dx1*dx3^2,dx1^2*dx3-dx2^3,-dx2*dx4^2+dx3^3],
 [x1,x2,x3,x4]]
[287] sm1.rrank(@@);
5

@end example

*/


/*&en
@node sm1.auto_reduce,,, SM1 Functions
@subsection @code{sm1.auto_reduce}
@findex sm1.auto_reduce
@table @t
@item sm1.auto_reduce(@var{s}|proc=@var{p})
::  Set the flag "AutoReduce" to @var{s}.
@end table

@table @var
@item return
Number
@item p
Number
@item s
Number
@end table

@itemize @bullet
@item  If @var{s} is 1, then all Grobner bases to be computed 
will be the reduced Grobner bases.
@item If @var{s} is 0, then Grobner bases are not necessarily the reduced
Grobner bases.  This is the default.
@end itemize
*/

/*&ja
@node sm1.auto_reduce,,, SM1 Functions
@subsection @code{sm1.auto_reduce}
@findex sm1.auto_reduce
@table @t
@item sm1.auto_reduce(@var{s}|proc=@var{p})
::  フラグ "AutoReduce" を @var{s} に設定.
@end table

@table @var
@item 戻り値
数
@item p
数
@item s
数
@end table

@itemize @bullet
@item  @var{s} が 1 のとき, 以後計算されるグレブナ基底はすべて,
reduced グレブナ基底となる.
@item  @var{s} が 0 のとき, 計算されるグレブナ基底は
reduced グレブナ基底とはかぎらない. こちらがデフォールト.
@end itemize
*/

  

/*&en
@node sm1.slope,,, SM1 Functions
@subsection @code{sm1.slope}
@findex sm1.slope
@table @t
@item sm1.slope(@var{ii},@var{v},@var{f_filtration},@var{v_filtration}|proc=@var{p})
::  Returns the slopes of differential equations @var{ii}.
@end table

@table @var
@item return
List
@item p
Number
@item ii
List  (equations)
@item v
List  (variables)
@item f_filtration
List  (weight vector)
@item v_filtration
List (weight vector)
@end table

@itemize @bullet
@item @code{sm1.slope} returns the (geometric) slopes 
of the system of differential equations @var{ii}
along the hyperplane specified by
the V filtration @var{v_filtration}.
@item @var{v} is a list of variables.
@item The return value is a list of lists.
The first entry of each list is the slope and the second entry
is the weight vector for which the microcharacteristic variety is
not bihomogeneous.
@end itemize

@noindent
Algorithm:
see "A.Assi, F.J.Castro-Jimenez and J.M.Granger,
How to calculate the slopes of a D-module, Compositio Math, 104, 1-17, 1996"
Note that the signs of the slopes s' are negative, but the absolute values -s'
of the slopes are returned.
In other words, when pF+qV is the gap, -s'=q/p is returned.
Note that s=1-1/s' is called the slope in recent literatures. Solutions belongs to O(s).
The number s satisfies 1<= s.  
We have r=s-1=-1/s', and kappa=1/r=-s', which is used 1/Gamma(1+m*r) factor and exp(-tau^kappa)
in the Borel and Laplace transformations respectively.

*/

/*&ja
@node sm1.slope,,, SM1 Functions
@subsection @code{sm1.slope}
@findex sm1.slope
@table @t
@item sm1.slope(@var{ii},@var{v},@var{f_filtration},@var{v_filtration}|proc=@var{p})
::  微分方程式系 @var{ii} の slope を戻す.
@end table

@table @var
@item return
数
@item p
数
@item ii
リスト  (方程式)
@item v
リスト (変数)
@item f_filtration
リスト  (weight vector)
@item v_filtration
リスト (weight vector)
@end table

@itemize @bullet
@item @code{sm1.slope} は
微分方程式系 @var{ii} の V filtration  @var{v_filtration}
で指定する超平面に沿っての (geomeric) slope を計算する.
@item @var{v} は変数のリスト.
@item 戻り値は, リストを成分とするリストである.
成分リストの第 1 要素が slope, 第 2 要素は, その weight vector に対応する
microcharacteristic variety が bihomogeneous でない.
@end itemize

@noindent
Algorithm:
"A.Assi, F.J.Castro-Jimenez and J.M.Granger,
How to calculate the slopes of a D-module, Compositio Math, 104, 1-17, 1996"
をみよ.
Slope s' の本来の定義では, 符号が負となるが, このプログラムは,
Slope の絶対値 -s' を戻す.
つまり pF+qV がmicro特性多様体のgapであるとき, -s'=q/p を戻す.
最近の文献では s=1-1/s' を slope と呼んでいる. 解は O(s) に属する.
数 s は 1<= s を満す.  
r=s-1=-1/s' および kappa=1/r=-s' である.
これらの数はBorel and Laplace 変換においてそれぞれ 1/Gamma(1+m*r) factor,
exp(-tau^kappa) 項として使われる.
*/

/*&C

@example

[284] A= sm1.gkz([  [[1,2,3]],  [-3] ]);


[285] sm1.slope(A[0],A[1],[0,0,0,1,1,1],[0,0,-1,0,0,1]);

[286] A2 = sm1.gkz([ [[1,1,1,0],[2,-3,1,-3]], [1,0]]);
     (* This is an interesting example given by Laura Matusevich, 
        June 9, 2001 *)

[287] sm1.slope(A2[0],A2[1],[0,0,0,0,1,1,1,1],[0,0,0,-1,0,0,0,1]);


@end example

*/
/*&en
@table @t
@item Reference
    @code{sm.gb}
@end table
*/
/*&ja
@table @t
@item 参照
    @code{sm.gb}
@end table
*/


/*&en
@include sm1-auto.en
*/

/*&ja
@include sm1-auto.ja
*/


end$

