@comment $OpenXM: OpenXM/src/asir-doc/parts/groebner.texi,v 1.25 2020/09/07 05:16:41 noro Exp $
\BJP
@node グレブナ基底の計算,,, Top
@chapter グレブナ基底の計算
\E
\BEG
@node Groebner basis computation,,, Top
@chapter Groebner basis computation
\E

@menu
\BJP
* 分散表現多項式::
* 基本的な函数::
* 計算および表示の制御::
* 項順序の設定::
* Weight::
* 有理式を係数とするグレブナ基底計算::
* 基底変換::
* Weyl 代数::
* 多項式環上の加群::
* グレブナ基底に関する函数::
\E
\BEG
* Distributed polynomial:: 
* Reading files::
* Fundamental functions::
* Controlling Groebner basis computations::
* Setting term orderings::
* Weight::
* Groebner basis computation with rational function coefficients::
* Change of ordering::
* Weyl algebra::
* Module over a polynomial ring::
* Functions for Groebner basis computation::
\E
@end menu

\BJP
@node 分散表現多項式,,, グレブナ基底の計算
@section 分散表現多項式
\E
\BEG
@node Distributed polynomial,,, Groebner basis computation
@section Distributed polynomial
\E

@noindent
\BJP
分散表現多項式とは, 多項式の内部形式の一つである. 通常の多項式 
(@code{type} が 2) は, 再帰表現と呼ばれる形式で表現されている. すなわ
ち, 特定の変数を主変数とする 1 変数多項式で, その他の変数は, その 1 変
数多項式の係数に, 主変数を含まない多項式として現れる. この係数が, また, 
ある変数を主変数とする多項式となっていることから再帰表現と呼ばれる.
\E
\BEG
A distributed polynomial is a polynomial with a special internal
representation different from the ordinary one.
      
An ordinary polynomial (having @code{type} 2) is internally represented
in a format, called recursive representation.
In fact, it is represented as an uni-variate polynomial with respect to
a fixed variable, called main variable of that polynomial,
where the other variables appear in the coefficients which may again
polynomials in such variables other than the previous main variable.
A polynomial in the coefficients is again represented as
an uni-variate polynomial in a certain fixed variable,
the main variable.  Thus, by this recursive structure of polynomial
representation, it is called the `recursive representation.'
\E

@iftex
@tex
\JP $(x+y+z)^2 = 1 \cdot x^2 + (2 \cdot y + (2 \cdot z)) \cdot x + ((2 \cdot z) \cdot y + (1 \cdot z^2 ))$
\EG $(x+y+z)^2 = 1 \cdot x^2 + (2 \cdot y + (2 \cdot z)) \cdot x + ((2 \cdot z) \cdot y + (1 \cdot z^2 ))$
@end tex
@end iftex
@ifnottex
@example
(x+y+z)^2 = 1 x^2 + (2 y + (2 z)) x + ((2 z) y + (1 z^2 ))
@end example
@end ifnottex

@noindent
\BJP
これに対し, 多項式を, 変数の冪積と係数の積の和として表現したものを分散
表現と呼ぶ. 
\E
\BEG
On the other hand,
we call a representation the distributed representation of a polynomial,
if a polynomial is represented, according to its original meaning,
as a sum of monomials,
where a monomial is the product of power product of variables
and a coefficient.  We call a polynomial, represented in such an
internal format, a distributed polynomial. (This naming may sounds
something strange.)
\E

@iftex
@tex
\JP $(x+y+z)^2 = 1 \cdot x^2 + 2 \cdot xy + 2 \cdot xz + 1 \cdot y^2 + 2 \cdot yz +1 \cdot z^2$
\EG $(x+y+z)^2 = 1 \cdot x^2 + 2 \cdot xy + 2 \cdot xz + 1 \cdot y^2 + 2 \cdot yz +1 \cdot z^2$
@end tex
@end iftex
@ifnottex
@example
(x+y+z)^2 = 1 x^2 + 2 xy + 2 xz + 1 y^2 + 2 yz +1 z^2$
@end example
@end ifnottex

@noindent
\BJP
グレブナ基底計算においては, 単項式に注目して操作を行うため多項式が分散表現
されている方がより効率のよい演算が可能になる. このため, 分散表現多項式が, 
識別子 9 の型として @b{Asir} のトップレベルから利用可能となっている. 
ここで, 後の説明のために, いくつかの言葉を定義しておく. 
\E
\BEG
For computation of Groebner basis, efficient operation is expected if
polynomials are represented in a distributed representation,
because major operations for Groebner basis are performed with respect
to monomials.
From this view point, we provide the object type distributed polynomial
with its object identification number 9, and objects having such a type
are available by @b{Asir} language.
      
Here, we provide several definitions for the later description.
\E

@table @b
\BJP
@item 項 (term)
変数の冪積. すなわち, 係数 1 の単項式のこと. @b{Asir} においては, 
\E
\BEG
@item term
The power product of variables, i.e., a monomial with coefficient 1.
In an @b{Asir} session, it is displayed in the form like
\E

@example
<<0,1,2,3,4>>
@end example

\BJP
という形で表示され, また, この形で入力可能である. この例は, 5 変数の項
を示す. 各変数を @code{a}, @code{b}, @code{c}, @code{d}, @code{e} とすると
この項は @code{b*c^2*d^3*e^4} を表す. 
\E
\BEG
and also can be input in such a form.
This example shows a term in 5 variables.  If we assume the 5 variables
as @code{a}, @code{b}, @code{c}, @code{d}, and @code{e},
the term represents @code{b*c^2*d^3*e^4} in the ordinary expression.
\E

\BJP
@item 項順序 (term order)
分散表現多項式における項は, 次の性質を満たす全順序により整列される. 
\E
\BEG
@item term order
Terms are ordered according to a total order with the following properties.
\E

@enumerate
@item
\JP 任意の項 @code{t} に対し @code{t} > 1
\EG For all @code{t} @code{t} > 1.

@item
\JP @code{t}, @code{s}, @code{u} を項とする時, @code{t} > @code{s} ならば @code{tu} > @code{su}
\EG For all @code{t}, @code{s}, @code{u} @code{t} > @code{s} implies @code{tu} > @code{su}.
@end enumerate

\BJP
この性質を満たす全順序を項順序と呼ぶ. この順序は変数順序 (変数のリスト) 
と項順序型 (数, リストまたは行列) により指定される.
\E
\BEG
Such a total order is called a term ordering. A term ordering is specified
by a variable ordering (a list of variables) and a type of term ordering
(an integer, a list or a matrix).
\E

\BJP
@item 単項式 (monomial)
項と係数の積. 
\E
\BEG
@item monomial
The product of a term and a coefficient.
In an @b{Asir} session, it is displayed in the form like
\E

@example
2*<<0,1,2,3,4>>
@end example

\JP という形で表示され, また, この形で入力可能である. 
\EG and also can be input in such a form.

\BJP
@item 頭項 (head term)
@itemx 頭単項式 (head monomial)
@itemx 頭係数 (head coefficient)
分散表現多項式における各単項式は, 項順序により整列される. この時順
序最大の単項式を頭単項式, それに現れる項, 係数をそれぞれ頭項, 頭係数
と呼ぶ. 
\E
\BEG
@item head term
@itemx head monomial
@itemx head coefficient
      
Monomials in a distributed polynomial is sorted by a total order.
In such representation, we call the monomial that is maximum
with respect to the order the head monomial, and its term and coefficient
the head term and the head coefficient respectively.
\E
@end table

@noindent
ChangeLog
@itemize @bullet
\BJP
@item 分散表現多項式は任意のオブジェクトを係数にもてるようになった.
また加群のk成分の要素を次の形式 <<d0,d1,...:k>> で表現するようになった (2017-08-31).
\E
\BEG
@item Distributed polynomials accept objects as coefficients.
The k-th element of a free module is expressed as <<d0,d1,...:k>> (2017-08-31).
\E
@item 
1.15 algnum.c,
1.53 ctrl.c,
1.66 dp-supp.c,
1.105 dp.c,
1.73 gr.c,
1.4 reduct.c,
1.16 _distm.c,
1.17 dalg.c,
1.52 dist.c,
1.20 distm.c,
1.8  gmpq.c,
1.238 engine/nd.c,
1.102  ca.h,
1.411  version.h,
1.28 cpexpr.c,
1.42 pexpr.c,
1.20 pexpr_body.c,
1.40 spexpr.c,
1.27 arith.c,
1.77 eval.c,
1.56 parse.h,
1.37 parse.y,
1.8 stdio.c,
1.31 plotf.c
@end itemize

\BJP
@node 基本的な函数,,, グレブナ基底の計算
@section 基本的な函数
\E
\BEG
@node Fundamental functions,,, Groebner basis computation
@section Fundamental functions
\E

@noindent
\BJP
2003 年以前の版においては, グレブナ基底を計算するための基本的な函数は @code{dp_gr_main()} および
@code{dp_gr_mod_main()}, @code{dp_gr_f_main()}
 なる 3 つの組み込み函数であった. 通常は, パラメタ
設定などを行ったのちこれらを呼び出すユーザ函数を用いるのが便利である. 
これらのユーザ函数は, ファイル @samp{gr} を @code{load()} により読
み込むことにより使用可能となる. @samp{gr} は, @b{Asir} の標準
ライブラリディレクトリに置かれている. 
@example
[0] load("gr")$
@end example


現在の版においては, @code{nd_gr}, @code{nd_f4} などの新しい関数が実装されており,
一般にこちらの方が効率よくグレブナー基底が計算できる 
(@fref{nd_gr nd_gr_trace nd_f4 nd_f4_trace nd_weyl_gr nd_weyl_gr_trace}).
\E
\BEG
In the version before 2003, 
facilities for computing Groebner bases are 
@code{dp_gr_main()}, @code{dp_gr_mod_main()}and @code{dp_gr_f_main()}.
To call these functions, 
it is necessary to set several parameters correctly and it is convenient
to use a set of interface functions provided in the library file
@samp{gr}.
The facilities will be ready to use after you load the package by
@code{load()}.  The package @samp{gr} is placed in the standard library
directory of @b{Asir}.  

In the current version, new functions such as @code{nd_gr}, @code{nd_f4} are available
and these function can compute Groebner bases more efficiently than old functions
(@fref{nd_gr nd_gr_trace nd_f4 nd_f4_trace nd_weyl_gr nd_weyl_gr_trace}).
\E

@noindent
\BJP
2003 年以前の版において
グレブナ基底を計算するためのトップレベルは次の 3 つである. 
以下で, @var{plist} は多項式のリスト, @var{vlist} は変数 (不定元) のリスト, 
@var{order} は変数順序型, @var{p} は @code{2^27} 未満の素数である. 
\E
\BEG
There are many functions and options defined in the package @samp{gr}.
Usually not so many of them are used.  Top level functions for Groebner
basis computation are the following three functions.
      
In the following description, @var{plist}, @var{vlist}, @var{order}
and @var{p} stand for  a list of polynomials,  a list of variables
(indeterminates), a type of term ordering and a prime less than
@code{2^27} respectively.
\E

@table @code
@item gr(@var{plist},@var{vlist},@var{order})

\BJP
Gebauer-Moeller による useless pair elimination criteria, sugar
strategy および Traverso による trace-lifting を用いた Buchberger アル
ゴリズムによる有理数係数グレブナ基底計算函数. 一般にはこの函数を用いる.
\E
\BEG
Function that computes Groebner bases over the rationals. The
algorithm is Buchberger algorithm with useless pair elimination
criteria by Gebauer-Moeller, sugar strategy and trace-lifting by
Traverso. For ordinary computation, this function is used.
\E

@item hgr(@var{plist},@var{vlist},@var{order})

\BJP
入力多項式を斉次化した後 @code{gr()} のグレブナ基底候補生成部により候
補生成し, 非斉次化, interreduce したものを @code{gr()} のグレブナ基底
チェック部でチェックする. 0 次元システム (解の個数が有限個の方程式系) 
の場合, sugar strategy が係数膨張を引き起こす場合がある. このような場
合, strategy を斉次化による strategy に置き換えることにより係数膨張を
抑制することができる場合が多い.
\E
\BEG
After homogenizing the input polynomials a candidate of the \gr basis
is computed by trace-lifting. Then the candidate is dehomogenized and
checked whether it is indeed a Groebner basis of the input.  Sugar
strategy often causes intermediate coefficient swells.  It is
empirically known that the combination of homogenization and suppresses
the swells for such cases.
\E

@item gr_mod(@var{plist},@var{vlist},@var{order},@var{p})

\BJP
Gebauer-Moeller による useless pair elimination criteria, sugar
strategy および Buchberger アルゴリズムによる GF(p) 係数グレブナ基底計
算函数.
\E
\BEG
Function that computes Groebner bases over GF(@var{p}). The same
algorithm as @code{gr()} is used.
\E
@end table

\BJP
現在の版においては, これらに相当する機能は @code{nd_gr}, @code{nd_gr_trace} にまとめられている.
詳しくは @fref{nd_gr nd_gr_trace nd_f4 nd_f4_trace nd_weyl_gr nd_weyl_gr_trace} 参照.
\E
\BEG
In the current version, the functions corresponding to these three interfaces are provided
by @code{nd_gr}, @code{nd_gr_trace}.
See @fref{nd_gr nd_gr_trace nd_f4 nd_f4_trace nd_weyl_gr nd_weyl_gr_trace}.
\E

\BJP
@node 計算および表示の制御,,, グレブナ基底の計算
@section 計算および表示の制御
\E
\BEG
@node Controlling Groebner basis computations,,, Groebner basis computation
@section Controlling Groebner basis computations
\E

@noindent
\BJP
グレブナ基底の計算において, さまざまなパラメタ設定を行うことにより計算, 
表示を制御することができる. これらは, 組み込み函数 @code{dp_gr_flags()}
により設定参照することができる. 無引数で @code{dp_gr_flags()} を実行する
と, 現在設定されているパラメタが, 名前と値のリストで返される. 
\E
\BEG
One can control a Groebner basis computation by setting various parameters.
These parameters can be set and examined by a built-in function
@code{dp_gr_flags()}. Without argument it returns the current settings.
\E

@example
[100] dp_gr_flags();
[Demand,0,NoSugar,0,NoCriB,0,NoGC,0,NoMC,0,NoRA,0,NoGCD,0,Top,0,
ShowMag,1,Print,1,Stat,0,Reverse,0,InterReduce,0,Multiple,0]
[101]
@end example

\BJP
以下で, 各パラメタの意味を説明する. on の場合とは, パラメタが 0 でない場合を
いう. これらのパラメタの初期値は全て 0 (off) である. 
\E
\BEG
The return value is a list which contains the names of parameters and their
values. The meaning of the parameters are as follows. `on' means that the
parameter is not zero.
\E

@table @code
@item NoSugar
\BJP
on の場合, sugar strategy の代わりに Buchbergerの normal strategy が用
いられる.
\E
\BEG
If `on', Buchberger's normal strategy is used instead of sugar strategy.
\E

@item NoCriB
\JP on の場合, 不必要対検出規準のうち, 規準 B を適用しない.
\EG If `on', criterion B among the Gebauer-Moeller's criteria is not applied.

@item NoGC
\JP on の場合, 結果がグレブナ基底になっているかどうかのチェックを行わない.
\BEG
If `on', the check that a Groebner basis candidate is indeed a Groebner basis,
is not executed.
\E

@item NoMC
\BJP
on の場合, 結果が入力イデアルと同等のイデアルであるかどうかのチェック
を行わない.
\E
\BEG
If `on', the check that the resulting polynomials generates the same ideal as
the ideal generated by the input, is not executed.
\E

@item NoRA
\BJP
on の場合, 結果を reduced グレブナ基底にするための
interreduce を行わない. 
\E
\BEG
If `on', the interreduction, which makes the Groebner basis reduced, is not
executed.
\E

@item NoGCD
\BJP
on の場合, 有理式係数のグレブナ基底計算において, 生成された多項式の, 
係数の content をとらない.
\E
\BEG
If `on', content removals are not executed during a Groebner basis computation
over a rational function field.
\E

@item Top
\JP on の場合, normal form 計算において頭項消去のみを行う. 
\EG If `on', Only the head term of the polynomial being reduced is reduced.

@comment @item Interreduce
@comment \BJP
@comment on の場合, 多項式を生成する毎に, それまで生成された基底をその多項式に
@comment よる normal form で置き換える.
@comment \E
@comment \BEG
@comment If `on', intermediate basis elements are reduced by using a newly generated
@comment basis element.
@comment \E

@item Reverse
\BJP
on の場合, normal form 計算の際の reducer を, 新しく生成されたものを優
先して選ぶ.
\E
\BEG
If `on', the selection strategy of reducer in a normal form computation
is such that a newer reducer is used first.
\E

@item Print
\JP on の場合, グレブナ基底計算の途中におけるさまざまな情報を表示する. 
\BEG
If `on', various information during a Groebner basis computation is
displayed.
\E

@item PrintShort
\JP on で、Print が off の場合, グレブナ基底計算の途中の情報を短縮形で表示する. 
\BEG
If `on' and Print is `off', short information during a Groebner basis computation is
displayed.
\E

@item Stat
\BJP
on で @code{Print} が off ならば, @code{Print} が on のとき表示さ
れるデータの内, 集計データのみが表示される. 
\E
\BEG
If `on', a summary of information is shown after a Groebner basis
computation. Note that the summary is always shown if @code{Print} is `on'.
\E

@item ShowMag
\BJP
on で @code{Print} が on ならば, 生成が生成される毎に, その多項式の
係数のビット長の和を表示し, 最後に, それらの和の最大値を表示する. 
\E
\BEG
If `on' and @code{Print} is `on', the sum of bit length of
coefficients of a generated basis element, which we call @var{magnitude},
is shown after every normal computation.  After comleting the
computation the maximal value among the sums is shown.
\E

@item Content
@itemx Multiple
\BJP
0 でない有理数の時, 有理数上の正規形計算において, 係数のビット長の和が
@code{Content} 倍になるごとに係数全体の GCD が計算され, その GCD で
割った多項式を簡約する. @code{Content} が 1 ならば, 簡約するごとに
GCD 計算が行われ一般には効率が悪くなるが, @code{Content} を 2 程度
とすると, 巨大な整数が係数に現れる場合, 効率が良くなる場合がある. 
backward compatibility のため、@code{Multiple} で整数値を指定できる.
\E
\BEG
If a non-zero rational number, in a normal form computation
over the rationals, the integer content of the polynomial being
reduced is removed when its magnitude becomes @code{Content} times
larger than a registered value, which is set to the magnitude of the
input polynomial. After each content removal the registered value is
set to the magnitude of the resulting polynomial. @code{Content} is
equal to 1, the simiplification is done after every normal form computation.
It is empirically known that it is often efficient to set @code{Content} to 2
for the case where large integers appear during the computation.
An integer value can be set by the keyword @code{Multiple} for
backward compatibility.
\E

@item Demand

\BJP
正当なディレクトリ名 (文字列) を値に持つとき, 生成された多項式はメモリ
中におかれず, そのディレクトリ中にバイナリデータとして置かれ, その多項
式を用いる normal form 計算の際, 自動的にメモリ中にロードされる. 各多
項式は, 内部でのインデックスをファイル名に持つファイルに格納される. 
ここで指定されたディレクトリに書かれたファイルは自動的には消去されない
ため, ユーザが責任を持って消去する必要がある. 
\E
\BEG
If the value (a character string) is a valid directory name, then
generated basis elements are put in the directory and are loaded on
demand during normal form computations.  Each elements is saved in the
binary form and its name coincides with the index internally used in
the computation. These binary files are not removed automatically
and one should remove them by hand.
\E
@end table

@noindent
\JP @code{Print} が 0 でない場合次のようなデータが表示される.
\EG If @code{Print} is `on', the following information are shown.

@example
[93] gr(cyclic(4),[c0,c1,c2,c3],0)$
mod= 99999989, eval = []
(0)(0)<<0,2,0,0>>(2,3),nb=2,nab=5,rp=2,sugar=2,mag=4
(0)(0)<<0,1,2,0>>(1,2),nb=3,nab=6,rp=2,sugar=3,mag=4
(0)(0)<<0,1,1,2>>(0,1),nb=4,nab=7,rp=3,sugar=4,mag=6
.
(0)(0)<<0,0,3,2>>(5,6),nb=5,nab=8,rp=2,sugar=5,mag=4
(0)(0)<<0,1,0,4>>(4,6),nb=6,nab=9,rp=3,sugar=5,mag=4
(0)(0)<<0,0,2,4>>(6,8),nb=7,nab=10,rp=4,sugar=6,mag=6
....gb done
reduceall
.......
membercheck
(0,0)(0,0)(0,0)(0,0)
gbcheck total 8 pairs
........
UP=(0,0)SP=(0,0)SPM=(0,0)NF=(0,0)NFM=(0.010002,0)ZNFM=(0.010002,0)
PZ=(0,0)NP=(0,0)MP=(0,0)RA=(0,0)MC=(0,0)GC=(0,0)T=40,B=0 M=8 F=6
D=12 ZR=5 NZR=6 Max_mag=6
[94]
@end example

@noindent
\BJP
最初に表示される @code{mod}, @code{eval} は, trace-lifting で用いられる法
である. @code{mod} は素数, @code{eval} は有理式係数の場合に用いられる
数のリストである. 
\E
\BEG
In this example @code{mod} and @code{eval} indicate moduli used in
trace-lifting. @code{mod} is a prime and @code{eval} is a list of integers
used for evaluation when the ground field is a field of rational functions.
\E

@noindent
\JP 計算途中で多項式が生成される毎に次の形のデータが表示される. 
\EG The following information is shown after every normal form computation.

@example
(TNF)(TCONT)HT(INDEX),nb=NB,nab=NAB,rp=RP,sugar=S,mag=M
@end example

@noindent
\JP それらの意味は次の通り. 
\EG Meaning of each component is as follows.

@table @code
\BJP
@item TNF

normal form 計算時間 (秒)

@item TCONT

content 計算時間 (秒)

@item HT

生成された多項式の頭項

@item INDEX

S-多項式を構成する多項式のインデックスのペア

@item NB

現在の, 冗長性を除いた基底の数

@item NAB

現在までに生成された基底の数

@item RP

残りのペアの数

@item S

生成された多項式の sugar の値

@item M

生成された多項式の係数のビット長の和 (@code{ShowMag} が on の時に表示される. )
\E
\BEG
@item TNF

CPU time for normal form computation (second)

@item TCONT

CPU time for content removal(second)

@item HT

Head term of the generated basis element

@item INDEX

Pair of indices which corresponds to the reduced S-polynomial

@item NB

Number of basis elements after removing redundancy
      
@item NAB

Number of all the basis elements
      
@item RP

Number of remaining pairs

@item S

Sugar of the generated basis element
      
@item M

Magnitude of the generated basis element (shown if @code{ShowMag} is `on'.)
\E
@end table

@noindent
\BJP
最後に, 集計データが表示される. 意味は次の通り. 
(時間の表示において, 数字が 2 つあるものは, 計算時間と GC 時間のペアである.)
\E
\BEG
The summary of the information shown after a Groebner basis
computation is as follows.  If a component shows timings and it
contains two numbers, they are a pair of time for computation and time
for garbage collection.
\E

@table @code
\BJP
@item UP

ペアのリストの操作にかかった時間

@item SP

有理数上の S-多項式計算時間

@item SPM

有限体上の S-多項式計算時間

@item NF

有理数上の normal form 計算時間

@item NFM

有限体上の normal form 計算時間

@item ZNFM

@code{NFM} の内, 0 への reduction にかかった時間

@item PZ

content 計算時間

@item NP

有理数係数多項式の係数に対する剰余演算の計算時間

@item MP

S-多項式を生成するペアの選択にかかった時間

@item RA

interreduce 計算時間

@item MC

trace-lifting における, 入力多項式のメンバシップ計算時間

@item GC

結果のグレブナ基底候補のグレブナ基底チェック時間

@item T

生成されたペアの数

@item B, M, F, D

各 criterion により除かれたペアの数
      
@item ZR

0 に reduce されたペアの数

@item NZR

0 でない多項式に reduce されたペアの数

@item Max_mag

生成された多項式の, 係数のビット長の和の最大値
\E
\BEG
@item UP

Time to manipulate the list of critical pairs

@item SP

Time to compute S-polynomials over the rationals

@item SPM

Time to compute S-polynomials over a finite field

@item NF

Time to compute normal forms over the rationals

@item NFM

Time to compute normal forms over a finite field

@item ZNFM

Time for zero reductions in @code{NFM}

@item PZ

Time to remove integer contents

@item NP

Time to compute remainders for coefficients of polynomials with coefficients
in the rationals

@item MP

Time to select pairs from which S-polynomials are computed

@item RA

Time to interreduce the Groebner basis candidate

@item MC

Time to check that each input polynomial is a member of the ideal
generated by the Groebner basis candidate.

@item GC

Time to check that the Groebner basis candidate is a Groebner basis

@item T

Number of critical pairs generated

@item B, M, F, D

Number of critical pairs removed by using each criterion
     
@item ZR

Number of S-polynomials reduced to 0

@item NZR

Number of S-polynomials reduced to non-zero results

@item Max_mag

Maximal magnitude among all the generated polynomials
\E
@end table

\BJP
@node 項順序の設定,,, グレブナ基底の計算
@section 項順序の設定
\E
\BEG
@node Setting term orderings,,, Groebner basis computation
@section Setting term orderings
\E

@noindent
\BJP
項は内部では, 各変数に関する指数を成分とする整数ベクトルとして表現され
る. 多項式を分散表現多項式に変換する際, 各変数がどの成分に対応するかを
指定するのが, 変数リストである. さらに, それら整数ベクトルの全順序を
指定するのが項順序の型である. 項順序型は, 数, 数のリストあるいは
行列で表現される. 
\E
\BEG
A term is internally represented as an integer vector whose components
are exponents with respect to variables. A variable list specifies the
correspondences between variables and components. A type of term ordering
specifies a total order for integer vectors. A type of term ordering is
represented by an integer, a list of integer or matrices.
\E

@noindent
\JP 基本的な項順序型として次の 3 つがある. 
\EG There are following three fundamental types.

@table @code
\JP @item 0 (DegRevLex; @b{全次数逆辞書式順序})
\EG @item 0 (DegRevLex; @b{total degree reverse lexicographic ordering})

\BJP
一般に, この順序によるグレブナ基底計算が最も高速である. ただし, 
方程式を解くという目的に用いることは, 一般にはできない. この
順序によるグレブナ基底は, 解の個数の計算, イデアルのメンバシップや, 
他の変数順序への基底変換のためのソースとして用いられる. 
\E
\BEG
In general, computation by this ordering shows the fastest speed
in most Groebner basis computations.
However, for the purpose to solve polynomial equations, this type
of ordering is, in general, not so suitable.
The Groebner bases obtained by this ordering is used for computing
the number of solutions, solving ideal membership problem and seeds
for conversion to other Groebner bases under different ordering.
\E

\JP @item 1 (DegLex; @b{全次数辞書式順序})
\EG @item 1 (DegLex; @b{total degree lexicographic ordering})

\BJP
この順序も, 辞書式順序に比べて高速にグレブナ基底を求めることができるが, 
@code{DegRevLex} と同様直接その結果を用いることは困難である. しかし, 
辞書式順序のグレブナ基底を求める際に, 斉次化後にこの順序でグレブナ基底
を求めている. 
\E
\BEG
By this type term ordering, Groebner bases are obtained fairly faster
than Lex (lexicographic) ordering, too.
Alike the @code{DegRevLex} ordering, the result, in general, cannot directly
be used for solving polynomial equations.
It is used, however, in such a way
that a Groebner basis is computed in this ordering after homogenization
to obtain the final lexicographic Groebner basis.
\E

\JP @item 2 (Lex; @b{辞書式順序})
\EG @item 2 (Lex; @b{lexicographic ordering})

\BJP
この順序によるグレブナ基底は, 方程式を解く場合に最適の形の基底を与えるが
計算時間がかかり過ぎるのが難点である. 特に, 解が有限個の場合, 結果の
係数が極めて長大な多倍長数になる場合が多い. この場合, @code{gr()}, 
@code{hgr()} による計算が極めて有効になる場合が多い. 
\E
\BEG
Groebner bases computed by this ordering give the most convenient
Groebner bases for solving the polynomial equations.
The only and serious shortcoming is the enormously long computation
time. 
It is often observed that the number coefficients of the result becomes
very very long integers, especially if the ideal is 0-dimensional.
For such a case, it is empirically true for many cases
that i.e., computation by
@code{gr()} and/or @code{hgr()} may be quite effective.
\E
@end table

@noindent
\BJP
これらを組み合わせてリストで指定することにより, 様々な消去順序が指定できる. 
これは, 
\E
\BEG
By combining these fundamental orderingl into a list, one can make
various term ordering called elimination orderings.
\E

@code{[[O1,L1],[O2,L2],...]}

@noindent
\BJP
で指定される. @code{Oi} は 0, 1, 2 のいずれかで, @code{Li} は変数の個
数を表す. この指定は, 変数を先頭から @code{L1}, @code{L2} , ...個
ずつの組に分け, それぞれの変数に関し, 順に @code{O1}, @code{O2},
...の項順序型で大小が決定するまで比較することを意味する. この型の
順序は一般に消去順序と呼ばれる. 
\E
\BEG
In this example @code{Oi} indicates 0, 1 or 2 and @code{Li} indicates
the number of variables subject to the corresponding orderings.
This specification means the following.
      
The variable list is separated into sub lists from left to right where
the @code{i}-th list contains @code{Li} members and it corresponds to
the ordering of type @code{Oi}. The result of a comparison is equal
to that for the leftmost different sub components. This type of ordering
is called an elimination ordering.
\E

@noindent
\BJP
さらに, 行列により項順序を指定することができる. 一般に, @code{n} 行
@code{m} 列の実数行列 @code{M} が次の性質を持つとする. 
\E
\BEG
Furthermore one can specify a term ordering by a matrix.
Suppose that a real @code{n}, @code{m} matrix @code{M} has the
following properties.
\E

@enumerate
@item
\JP 長さ @code{m} の整数ベクトル @code{v} に対し @code{Mv=0} と @code{v=0} は同値. 
\BEG
For all integer vectors @code{v} of length @code{m} @code{Mv=0} is equivalent
to @code{v=0}.
\E

@item
\BJP
非負成分を持つ長さ @code{m} の 0 でない整数ベクトル @code{v} に対し, 
@code{Mv} の 0 でない最初の成分は非負.
\E
\BEG
For all non-negative integer vectors @code{v} the first non-zero component
of @code{Mv} is non-negative.
\E
@end enumerate

@noindent
\BJP
この時, 2 つのベクトル @code{t}, @code{s} に対し, 
@code{t>s} を, @code{M(t-s)} の 0 でない最初の成分が非負,
で定義することにより項順序が定義できる.
\E
\BEG
Then we can define a term ordering such that, for two vectors
@code{t}, @code{s}, @code{t>s} means that the first non-zero component
of @code{M(t-s)} is non-negative.
\E

@noindent
\BJP
項順序型は, @code{gr()} などの引数として指定される他, 組み込み函数
@code{dp_ord()} で指定され, さまざまな函数の実行の際に参照される. 
\E
\BEG
Types of term orderings are used as arguments of functions such as
@code{gr()}. It is also set internally by @code{dp_ord()} and is used
during executions of various functions.
\E

@noindent
\BJP
これらの順序の具体的な定義およびグレブナ基底に関する更に詳しい解説は
@code{[Becker,Weispfenning]} などを参照のこと. 
\E
\BEG
For concrete definitions of term ordering and more information
about Groebner basis, refer to, for example, the book
@code{[Becker,Weispfenning]}.
\E

@noindent
\JP 項順序型の設定の他に, 変数の順序自体も計算時間に大きな影響を与える. 
\BEG
Note that the variable ordering have strong effects on the computation
time as well as the choice of types of term orderings.
\E

@example
[90] B=[x^10-t,x^8-z,x^31-x^6-x-y]$
[91] gr(B,[x,y,z,t],2);
[x^2-2*y^7+(-41*t^2-13*t-1)*y^2+(2*t^17-12*t^14+42*t^12+30*t^11-168*t^9
-40*t^8+70*t^7+252*t^6+30*t^5-140*t^4-168*t^3+2*t^2-12*t+16)*z^2*y
+(-12*t^16+72*t^13-28*t^11-180*t^10+112*t^8+240*t^7+28*t^6-127*t^5
-167*t^4-55*t^3+30*t^2+58*t-15)*z^4,
(y+t^2*z^2)*x+y^7+(20*t^2+6*t+1)*y^2+(-t^17+6*t^14-21*t^12-15*t^11
+84*t^9+20*t^8-35*t^7-126*t^6-15*t^5+70*t^4+84*t^3-t^2+5*t-9)*z^2*y
+(6*t^16-36*t^13+14*t^11+90*t^10-56*t^8-120*t^7-14*t^6+64*t^5+84*t^4
+27*t^3-16*t^2-30*t+7)*z^4,
(t^3-1)*x-y^6+(-6*t^13+24*t^10-20*t^8-36*t^7+40*t^5+24*t^4-6*t^3-20*t^2
-6*t-1)*y+(t^17-6*t^14+9*t^12+15*t^11-36*t^9-20*t^8-5*t^7+54*t^6+15*t^5
+10*t^4-36*t^3-11*t^2-5*t+9)*z^2,
-y^8-8*t*y^3+16*z^2*y^2+(-8*t^16+48*t^13-56*t^11-120*t^10+224*t^8+160*t^7
-56*t^6-336*t^5-112*t^4+112*t^3+224*t^2+24*t-56)*z^4*y+(t^24-8*t^21
+20*t^19+28*t^18-120*t^16-56*t^15+14*t^14+300*t^13+70*t^12-56*t^11
-400*t^10-84*t^9+84*t^8+268*t^7+84*t^6-56*t^5-63*t^4-36*t^3+46*t^2
-12*t+1)*z,2*t*y^5+z*y^2+(-2*t^11+8*t^8-20*t^6-12*t^5+40*t^3+8*t^2
-10*t-20)*z^3*y+8*t^14-32*t^11+48*t^8-t^7-32*t^5-6*t^4+9*t^2-t,
-z*y^3+(t^7-2*t^4+3*t^2+t)*y+(-2*t^6+4*t^3+2*t-2)*z^2,
2*t^2*y^3+z^2*y^2+(-2*t^5+4*t^2-6)*z^4*y
+(4*t^8-t^7-8*t^5+2*t^4-4*t^3+5*t^2-t)*z,
z^3*y^2+2*t^3*y+(-t^7+2*t^4+t^2-t)*z^2,
-t*z*y^2-2*z^3*y+t^8-2*t^5-t^3+t^2,
-t^3*y^2-2*t^2*z^2*y+(t^6-2*t^3-t+1)*z^4,z^5-t^4]
[93] gr(B,[t,z,y,x],2);
[x^10-t,x^8-z,x^31-x^6-x-y]
@end example

@noindent
\BJP
変数順序 @code{[x,y,z,t]} におけるグレブナ基底は, 基底の数も多く, それぞれの
式も大きい. しかし, 順序 @code{[t,z,y,x]} にもとでは, @code{B} がすでに
グレブナ基底となっている. 大雑把にいえば, 辞書式順序でグレブナ基底を求める
ことは, 左側の (順序の高い) 変数を, 右側の (順序の低い) 変数で書き表す
ことであり, この例の場合は, @code{t},  @code{z}, @code{y} が既に
@code{x} で表されていることからこのような極端な結果となったわけである. 
実際に現れる計算においては, このように選ぶべき変数順序が明らかである
ことは少なく, 試行錯誤が必要な場合もある. 
\E
\BEG
As you see in the above example, the Groebner base under variable
ordering @code{[x,y,z,t]} has a lot of bases and each base itself is
large.  Under variable ordering @code{[t,z,y,x]}, however, @code{B} itself
is already the Groebner basis.
Roughly speaking, to obtain a Groebner base under the lexicographic
ordering is to express the variables on the left (having higher order)
in terms of variables on the right (having lower order).
In the example, variables @code{t},  @code{z}, and @code{y} are already
expressed by variable @code{x}, and the above explanation justifies
such a drastic experimental results.
In practice, however, optimum ordering for variables may not known
beforehand, and some heuristic trial may be inevitable.
\E

\BJP
@node Weight ,,, グレブナ基底の計算
@section Weight
\E
\BEG
@node Weight,,, Groebner basis computation
@section Weight
\E
\BJP
前節で紹介した項順序は, 各変数に weight (重み) を設定することで
より一般的なものとなる. 
\E
\BEG
Term orderings introduced in the previous section can be generalized
by setting a weight for each variable.
\E
@example
[0] dp_td(<<1,1,1>>);
3
[1] dp_set_weight([1,2,3])$
[2] dp_td(<<1,1,1>>);
6
@end example
\BJP
単項式の全次数を計算する際, デフォルトでは
各変数の指数の和を全次数とする. これは各変数の weight を 1 と
考えていることに相当する. この例では, 第一, 第二, 第三変数の
weight をそれぞれ 1,2,3 と指定している. このため, @code{<<1,1,1>>}
の全次数 (以下ではこれを単項式の weight と呼ぶ) が @code{1*1+1*2+1*3=6} となる.
weight を設定することで, 同じ項順序型のもとで異なる項順序が定義できる.
例えば, weight をうまく設定することで, 多項式を weighted homogeneous
にすることができる場合がある. 
\E
\BEG
By default, the total degree of a monomial is equal to
the sum of all exponents. This means that the weight for each variable
is set to 1.
In this example, the weights for the first, the second and the third
variable are set to 1, 2 and 3 respectively.
Therefore the total degree of @code{<<1,1,1>>} under this weight,
which is called the weight of the monomial, is @code{1*1+1*2+1*3=6}.
By setting weights, different term orderings can be set under a type of
term ordeing. In some case a polynomial can 
be made weighted homogeneous by setting an appropriate weight.
\E

\BJP
各変数に対する weight をまとめたものを weight vector と呼ぶ.
すべての成分が正であり, グレブナ基底計算において, 全次数の
代わりに用いられるものを特に sugar weight と呼ぶことにする.
sugar strategy において, 全次数の代わりに使われるからである.
一方で, 各成分が必ずしも正とは限らない weight vector は,
sugar weight として設定することはできないが, 項順序の一般化には
有用である. これらは, 行列による項順序の設定にすでに現れて
いる. すなわち, 項順序を定義する行列の各行が, 一つの weight vector
と見なされる. また, ブロック順序は, 各ブロックの
変数に対応する成分のみ 1 で他は 0 の weight vector による比較を
最初に行ってから, 各ブロック毎の tie breaking を行うことに相当する.
\E

\BEG
A list of weights for all variables is called a weight vector.
A weight vector is called a sugar weight vector if
its elements are all positive and it is used for computing
a weighted total degree of a monomial, because such a weight
is used instead of total degree in sugar strategy.
On the other hand, a weight vector whose elements are not necessarily
positive cannot be set as a sugar weight, but it is useful for
generalizing term order. In fact, such a weight vector already
appeared in a matrix order. That is, each row of a matrix defining
a term order is regarded as a weight vector. A block order 
is also considered as a refinement of comparison by weight vectors.
It compares two terms by using a weight vector whose elements
corresponding to variables in a block is 1 and 0 otherwise,
then it applies a tie breaker.
\E

\BJP
weight vector の設定は @code{dp_set_weight()} で行うことができる
が, 項順序を指定する際の他のパラメタ (項順序型, 変数順序) と
まとめて設定できることが望ましい. このため, 次のような形でも
項順序が指定できる.
\E
\BEG
A weight vector can be set by using @code{dp_set_weight()}.
However it is more preferable if a weight vector can be set
together with other parapmeters such as a type of term ordering
and a variable order. This is realized as follows.
\E

@example
[64] B=[x+y+z-6,x*y+y*z+z*x-11,x*y*z-6]$
[65] dp_gr_main(B|v=[x,y,z],sugarweight=[3,2,1],order=0);
[z^3-6*z^2+11*z-6,x+y+z-6,-y^2+(-z+6)*y-z^2+6*z-11]
[66] dp_gr_main(B|v=[y,z,x],order=[[1,1,0],[0,1,0],[0,0,1]]);
[x^3-6*x^2+11*x-6,x+y+z-6,-x^2+(-y+6)*x-y^2+6*y-11]
[67] dp_gr_main(B|v=[y,z,x],order=[[x,1,y,2,z,3]]);
[x+y+z-6,x^3-6*x^2+11*x-6,-x^2+(-y+6)*x-y^2+6*y-11]
@end example

\BJP
いずれの例においても, 項順序は option として指定されている.
最初の例では @code{v} により変数順序を, @code{sugarweight} により
sugar weight vector を, @code{order}により項順序型を指定している.
二つ目の例における @code{order} の指定は matrix order と同様である.
すなわち, 指定された weight vector を左から順に使って weight の比較
を行う. 三つ目の例も同様であるが, ここでは weight vector の要素を
変数毎に指定している. 指定がないものは 0 となる. 三つ目の例では,
@code{order} による指定では項順序が決定しない. この場合には,
tie breaker として全次数逆辞書式順序が自動的に設定される.
この指定方法は, @code{dp_gr_main}, @code{dp_gr_mod_main} など
の組み込み関数でのみ可能であり, @code{gr} などのユーザ定義関数
では未対応である.
\E
\BEG
In each example, a term ordering is specified as options.
In the first example, a variable order, a sugar weight vector
and a type of term ordering are specified by options @code{v}, 
@code{sugarweight} and @code{order} respectively.
In the second example, an option @code{order} is used
to set a matrix ordering. That is, the specified weight vectors
are used from left to right for comparing terms.
The third example shows a variant of specifying a weight vector,
where each component of a weight vector is specified variable by variable,
and unspecified components are set to zero. In this example,
a term order is not determined only by the specified weight vector.
In such a case a tie breaker by the graded reverse lexicographic ordering
is set automatically.
This type of a term ordering specification can be applied only to builtin
functions such as @code{dp_gr_main()}, @code{dp_gr_mod_main()}, not to
user defined functions such as @code{gr()}.
\E

\BJP
@node 有理式を係数とするグレブナ基底計算,,, グレブナ基底の計算
@section 有理式を係数とするグレブナ基底計算
\E
\BEG
@node Groebner basis computation with rational function coefficients,,, Groebner basis computation
@section Groebner basis computation with rational function coefficients
\E

@noindent
\BJP
@code{gr()} などのトップレベル函数は, いずれも, 入力多項式リストに
現れる変数 (不定元) と, 変数リストに現れる変数を比較して, 変数リストに
ない変数が入力多項式に現れている場合には, 自動的に, その変数を, 係数
体の元として扱う. 
\E
\BEG
Such variables that appear within the input polynomials but
not appearing in the input variable list are automatically treated
as elements in the coefficient field
by top level functions, such as @code{gr()}.
\E

@example
[64] gr([a*x+b*y-c,d*x+e*y-f],[x,y],2);
[(-e*a+d*b)*x-f*b+e*c,(-e*a+d*b)*y+f*a-d*c]
@end example

@noindent
\BJP
この例では, @code{a}, @code{b}, @code{c}, @code{d} が係数体の元として
扱われる. すなわち, 有理函数体 
@b{F} = @b{Q}(@code{a},@code{b},@code{c},@code{d}) 上の 2 変数多項式環
@b{F}[@code{x},@code{y}] におけるグレブナ基底を求めることになる. 
注意すべきことは, 
係数が体として扱われていることである. すなわち, 係数の間に多項式
としての共通因子があった場合には, 結果からその因子は除かれている
ため, 有理数体上の多項式環上の問題として考えた場合の結果とは一般
には異なる. また, 主として計算効率上の問題のため, 分散表現多項式
の係数として実際に許されるのは多項式までである. すなわち, 分母を
持つ有理式は分散表現多項式の係数としては許されない. 
\E
\BEG
In this example, variables @code{a}, @code{b}, @code{c}, and @code{d}
are treated as elements in the coefficient field.
In this case, a Groebner basis is computed
on a bi-variate polynomial ring
@b{F}[@code{x},@code{y}]
over rational function field
 @b{F} = @b{Q}(@code{a},@code{b},@code{c},@code{d}).
Notice that coefficients are considered as a member in a field.
As a consequence, polynomial factors common to the coefficients
are removed so that the result, in general, is different from
the result that would be obtained when the problem is considered
as a computation of Groebner basis over a polynomial ring
with rational function coefficients.
And note that coefficients of a distributed polynomial are limited
to numbers and polynomials because of efficiency.
\E

\BJP
@node 基底変換,,, グレブナ基底の計算
@section 基底変換
\E
\BEG
@node Change of ordering,,, Groebner basis computation
@section Change of orderng
\E

@noindent
\BJP
辞書式順序のグレブナ基底を求める場合, 直接 @code{gr()} などを起動する
より, 一旦他の順序 (例えば全次数逆辞書式順序) のグレブナ基底を計算して, 
それを入力として辞書式順序のグレブナ基底を計算する方が効率がよい場合
がある. また, 入力が何らかの順序でのグレブナ基底になっている場合, 基底
変換と呼ばれる方法により, Buchberger アルゴリズムによらずに効率良く
辞書式順序のグレブナ基底が計算できる場合がある. このような目的のための
函数が, ユーザ定義函数として @samp{gr} にいくつか定義されている. 
以下の 2 つの函数は, 変数順序 @var{vlist1}, 項順序型 @var{order} で
既にグレブナ基底となっている多項式リスト @var{gbase} を, 変数順序
@var{vlist2} における辞書式順序のグレブナ基底に変換する函数である. 
\E
\BEG
When we compute a lex order Groebner basis, it is often efficient to
compute it via Groebner basis with respect to another order such as
degree reverse lex order, rather than to compute it directory by
@code{gr()} etc. If we know that an input is a Groebner basis with
respect to an order, we can apply special methods called change of
ordering for a Groebner basis computation with respect to another
order, without using Buchberger algorithm. The following two functions
are ones for change of ordering such that they convert a Groebner
basis @var{gbase} with respect to the variable order @var{vlist1} and
the order type @var{order} into a lex Groebner basis with respect
to the variable order @var{vlist2}.
\E

@table @code
@item tolex(@var{gbase},@var{vlist1},@var{order},@var{vlist2})

\BJP
この函数は, @var{gbase} が有理数体上のシステムの場合にのみ使用可能である. 
この函数は, 辞書式順序のグレブナ基底を, 有限体上で計算されたグレブナ基底
を雛型として, 未定係数法および Hensel 構成により求めるものである. 
\E
\BEG
This function can be used only when @var{gbase} is an ideal over the
rationals.  The input @var{gbase} must be a Groebner basis with respect
to the variable order @var{vlist1} and the order type @var{order}. Moreover
the ideal generated by @var{gbase} must be zero-dimensional.
This computes the lex Groebner basis of @var{gbase}
by using the modular change of ordering algorithm. The algorithm first
computes the lex Groebner basis over a finite field. Then each element
in the lex Groebner basis over the rationals is computed with undetermined
coefficient method and linear equation solving by Hensel lifting.
\E

@item tolex_tl(@var{gbase},@var{vlist1},@var{order},@var{vlist2},@var{homo})

\BJP
この函数は, 辞書式順序のグレブナ基底を Buchberger アルゴリズムにより求
めるものであるが, 入力がある順序におけるグレブナ基底である場合の 
trace-liftingにおけるグレブナ基底候補の頭項, 頭係数の性質を利用して, 
最終的なグレブナ基底チェック, イデアルメンバシップチェックを省略してい
るため, 単にBuchberger アルゴリズムを繰り返すより効率よく計算できる. 
更に, 入力が 0 次元システムの場合, 自動的にもう 1 つの中間的な項順序を
経由して辞書式順序のグレブナ基底を計算する. 多くの場合, この方法は, 
直接辞書式順序の計算を行うより効率がよい. (もちろん例外あり. )
引数 @var{homo} が 0 でない時, @code{hgr()} と同様に斉次化を経由して
計算を行う. 
\E
\BEG
This function computes the lex Groebner basis of @var{gbase}.  The
input @var{gbase} must be a Groebner basis with respect to the
variable order @var{vlist1} and the order type @var{order}.
Buchberger algorithm with trace lifting is used to compute the lex
Groebner basis, however the Groebner basis check and the ideal
membership check can be omitted by using several properties derived
from the fact that the input is a Groebner basis. So it is more
efficient than simple repetition of Buchberger algorithm. If the input
is zero-dimensional, this function inserts automatically a computation
of Groebner basis with respect to an elimination order, which makes
the whole computation more efficient for many cases. If @var{homo} is
not equal to 0, homogenization is used in each step.
\E
@end table

@noindent
\BJP
その他, 0 次元システムに対し, 与えられた多項式の最小多項式を求める
函数, 0 次元システムの解を, よりコンパクトに表現するための函数などが
@samp{gr} で定義されている. これらについては個々の函数の説明を参照のこと. 
\E
\BEG
For zero-dimensional systems, there are several functions to
compute the minimal polynomial of a polynomial and or a more compact
representation for zeros of the system. They are all defined in @samp{gr}.
Refer to the sections for each functions.
\E

\BJP
@node Weyl 代数,,, グレブナ基底の計算
@section Weyl 代数
\E
\BEG
@node Weyl algebra,,, Groebner basis computation
@section Weyl algebra
\E

@noindent

\BJP
これまでは, 通常の可換な多項式環におけるグレブナ基底計算について
述べてきたが, グレブナ基底の理論は, ある条件を満たす非可換な
環にも拡張できる. このような環の中で, 応用上も重要な, 
Weyl 代数, すなわち多項式環上の微分作用素環の演算および
グレブナ基底計算が Risa/Asir に実装されている. 

体 @code{K} 上の @code{n} 次元 Weyl 代数 
@code{D=K<x1,@dots{},xn,D1,@dots{},Dn>} は
\E

\BEG
So far we have explained Groebner basis computation in
commutative polynomial rings. However Groebner basis can be
considered in more general non-commutative rings.
Weyl algebra is one of such rings and 
Risa/Asir implements fundamental operations
in Weyl algebra and Groebner basis computation in Weyl algebra.

The @code{n} dimensional Weyl algebra over a field @code{K},
@code{D=K<x1,@dots{},xn,D1,@dots{},Dn>} is a non-commutative
algebra which has the following fundamental relations:
\E

@code{xi*xj-xj*xi=0}, @code{Di*Dj-Dj*Di=0}, @code{Di*xj-xj*Di=0} (@code{i!=j}),
@code{Di*xi-xi*Di=1}

\BJP
という基本関係を持つ環である. @code{D} は 多項式環 @code{K[x1,@dots{},xn]} を係数
とする微分作用素環で,  @code{Di} は @code{xi} による微分を表す. 交換関係により, 
@code{D} の元は, @code{x1^i1*@dots{}*xn^in*D1^j1*@dots{}*Dn^jn} なる単項
式の @code{K} 線形結合として書き表すことができる. 
Risa/Asir においては, この単項式を, 可換な多項式と同様に
@code{<<i1,@dots{},in,j1,@dots{},jn>>} で表す. すなわち, @code{D} の元も
分散表現多項式として表される. 加減算は, 可換の場合と同様に, @code{+}, @code{-}
により
実行できるが, 乗算は, 非可換性を考慮して @code{dp_weyl_mul()} という関数
により実行する.
\E

\BEG
@code{D} is the ring of differential operators whose coefficients
are polynomials in @code{K[x1,@dots{},xn]} and
@code{Di} denotes the differentiation with respect to  @code{xi}.
According to the commutation relation,
elements of @code{D} can be represented as a @code{K}-linear combination 
of monomials @code{x1^i1*@dots{}*xn^in*D1^j1*@dots{}*Dn^jn}.
In Risa/Asir, this type of monomial is represented 
by @code{<<i1,@dots{},in,j1,@dots{},jn>>} as in the case of commutative
polynomial.
That is, elements of @code{D} are represented by distributed polynomials.
Addition and subtraction can be done by @code{+}, @code{-},
but multiplication is done by calling @code{dp_weyl_mul()} because of
the non-commutativity of @code{D}.
\E

@example
[0] A=<<1,2,2,1>>;
(1)*<<1,2,2,1>>
[1] B=<<2,1,1,2>>;
(1)*<<2,1,1,2>>
[2] A*B;
(1)*<<3,3,3,3>>
[3] dp_weyl_mul(A,B);
(1)*<<3,3,3,3>>+(1)*<<3,2,3,2>>+(4)*<<2,3,2,3>>+(4)*<<2,2,2,2>>
+(2)*<<1,3,1,3>>+(2)*<<1,2,1,2>>
@end example

\BJP
グレブナ基底計算についても, Weyl 代数専用の関数として, 
次の関数が用意してある. 
\E
\BEG
The following functions are available for Groebner basis computation
in Weyl algebra:
\E
@code{dp_weyl_gr_main()},
@code{dp_weyl_gr_mod_main()},
@code{dp_weyl_gr_f_main()},
@code{dp_weyl_f4_main()},
@code{dp_weyl_f4_mod_main()}.
\BJP
また, 応用として, global b 関数の計算が実装されている. 
\E
\BEG
Computation of the global b function is implemented as an application.
\E

\BJP
@node 多項式環上の加群,,, グレブナ基底の計算
@section 多項式環上の加群
\E
\BEG
@node Module over a polynomial ring,,, Groebner basis computation
@section Module over a polynomial ring
\E

@noindent

\BJP
多項式環上の自由加群の元は, 加群単項式 te_i の線型和として内部表現される.
ここで t は多項式環の単項式, e_i は自由加群の標準基底である. 加群単項式は, 多項式環の単項式
に位置 i を追加した @code{<<a,b,...,c:i>>} で表す. 加群多項式, すなわち加群単項式の線型和は,
設定されている加群項順序にしたがって降順に整列される. 加群項順序には以下の3種類がある.

@table @code
@item TOP 順序

これは, te_i > se_j となるのは t>s または (t=s かつ i<j) となるような項順序である. ここで,
t, s の比較は多項式環に設定されている順序で行う. 
この型の順序は, @code{dp_ord([0,Ord])} に
より設定する. ここで, @code{Ord} は多項式環の順序型である.

@item POT 順序

これは, te_i > se_j となるのは i<j または (i=j かつ t>s) となるような項順序である. ここで,
t, s の比較は多項式環に設定されている順序で行う.
この型の順序は, @code{dp_ord([1,Ord])} に
より設定する. ここで, @code{Ord} は多項式環の順序型である.

@item Schreyer 型順序

各標準基底 e_i に対し, 別の自由加群の加群単項式 T_i が与えられていて, te_i > se_j となるのは
tT_i > sT_j または (tT_i=sT_j かつ i<j) となるような項順序である. ここで tT_i, sT_j の
比較は, これらが所属する自由加群に設定されている順序で行う.
この型の順序は, 通常再帰的に設定される. すなわち, T_i が所属する自由加群の順序も Schreyer 型
であるか, またはボトムとなる TOP, POT などの項順序となる. 
この型の順序は @code{dpm_set_schreyer([H_1,H_2,...])} により指定する. ここで,
@code{H_i=[T_1,T_2,...]} は加群単項式のリストで, @code{[H_2,...]} で定義される Schreyer 型項順序を
@code{tT_i} らに適用するという意味である. 
@end table

加群多項式を入力する方法としては, @code{<<a,b,...:i>>} なる形式で直接入力する他に,
多項式リストを作り, @code{dpm_ltod()} により変換する方法もある.
\E
\BEG
not yet
\E

\BJP
@node グレブナ基底に関する函数,,, グレブナ基底の計算
@section グレブナ基底に関する函数
\E
\BEG
@node Functions for Groebner basis computation,,, Groebner basis computation
@section Functions for Groebner basis computation
\E

@menu
* gr hgr gr_mod::
* lex_hensel lex_tl tolex tolex_d tolex_tl::
* lex_hensel_gsl tolex_gsl tolex_gsl_d::
* gr_minipoly minipoly::
* tolexm minipolym::
* dp_gr_main dp_gr_mod_main dp_gr_f_main dp_weyl_gr_main dp_weyl_gr_mod_main dp_weyl_gr_f_main::
* dp_f4_main dp_f4_mod_main dp_weyl_f4_main dp_weyl_f4_mod_main::
* nd_gr nd_gr_trace nd_f4 nd_f4_trace nd_weyl_gr nd_weyl_gr_trace::
* nd_gr_postproc nd_weyl_gr_postproc::
* dp_gr_flags dp_gr_print::
* dp_ord::
* dp_set_weight dp_set_top_weight dp_weyl_set_weight::
* dp_ptod::
* dp_dtop::
* dp_mod dp_rat::
* dp_homo dp_dehomo::
* dp_ptozp dp_prim::
* dp_nf dp_nf_mod dp_true_nf dp_true_nf_mod dp_weyl_nf dp_weyl_nf_mod::
* dp_hm dp_ht dp_hc dp_rest::
* dpm_hm dpm_ht dpm_hc dpm_hp dpm_rest::
* dpm_sp::
* dpm_redble::
* dpm_nf dpm_nf_and_quotient::
* dpm_dtol::
* dpm_ltod::
* dpm_dptodpm::
* dpm_schreyer_base::
* dpm_schreyer_frame::
* dpm_set_schreyer_level::
* dpm_sp_nf::
* dp_td dp_sugar::
* dp_lcm::
* dp_redble::
* dp_subd::
* dp_mbase::
* dp_mag::
* dp_red dp_red_mod::
* dp_sp dp_sp_mod::
* p_nf p_nf_mod p_true_nf p_true_nf_mod ::
* p_terms::
* gb_comp::
* katsura hkatsura cyclic hcyclic::
* dp_vtoe dp_etov::
* lex_hensel_gsl tolex_gsl tolex_gsl_d::
* primadec primedec::
* primedec_mod::
* bfunction bfct generic_bfct ann ann0::
@end menu

\JP @node gr hgr gr_mod,,, グレブナ基底に関する函数
\EG @node gr hgr gr_mod,,, Functions for Groebner basis computation
@subsection @code{gr}, @code{hgr}, @code{gr_mod}, @code{dgr}
@findex gr
@findex hgr
@findex gr_mod
@findex dgr

@table @t
@item gr(@var{plist},@var{vlist},@var{order})
@itemx hgr(@var{plist},@var{vlist},@var{order})
@itemx gr_mod(@var{plist},@var{vlist},@var{order},@var{p})
@itemx dgr(@var{plist},@var{vlist},@var{order},@var{procs})
\JP :: グレブナ基底の計算
\EG :: Groebner basis computation
@end table

@table @var
@item return
\JP リスト
\EG list
@item plist  vlist  procs
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@item p
\JP 2^27 未満の素数
\EG prime less than 2^27
@end table

@itemize @bullet
\BJP
@item
標準ライブラリの @samp{gr} で定義されている. 
@item
gr を名前に含む関数は現在メンテされていない. @code{nd_gr}系の関数を代わりに利用すべきである(@fref{nd_gr nd_gr_trace nd_f4 nd_f4_trace nd_weyl_gr nd_weyl_gr_trace}).
@item
いずれも, 多項式リスト @var{plist} の, 変数順序 @var{vlist}, 項順序型
@var{order} に関するグレブナ基底を求める. @code{gr()}, @code{hgr()}
は 有理数係数, @code{gr_mod()} は GF(@var{p}) 係数として計算する. 
@item
@var{vlist} は不定元のリスト. @var{vlist} に現れない不定元は, 
係数体に属すると見なされる. 
@item
@code{gr()}, trace-lifting (モジュラ演算を用いた高速化) および sugar
strategy による計算, @code{hgr()} は trace-lifting および
斉次化による 矯正された sugar strategy による計算を行う. 
@item
@code{dgr()} は, @code{gr()}, @code{hgr()} を
子プロセスリスト @var{procs} の 2 つのプロセスにより同時に計算させ, 
先に結果を返した方の結果を返す. 結果は同一であるが, どちらの方法が
高速か一般には不明のため, 実際の経過時間を短縮するのに有効である. 
@item
@code{dgr()} で表示される時間は, この函数が実行されているプロセスでの
CPU 時間であり, この函数の場合はほとんど通信のための時間である. 
@item
多項式リスト @var{plist} の要素が分散表現多項式の場合は
結果も分散表現多項式のリストである.
この場合, 引数の分散多項式は与えられた順序に従い @code{dp_sort} で
ソートされてから計算される.
多項式リストの要素が分散表現多項式の場合も
変数の数分の不定元のリストを @var{vlist} 引数として与えないといけない
(ダミー).
\E
\BEG
@item 
These functions are defined in @samp{gr} in the standard library
directory.
@item
Functions of which names contains gr are obsoleted. 
Functions of @code{nd_gr} families should be used (@fref{nd_gr nd_gr_trace nd_f4 nd_f4_trace nd_weyl_gr nd_weyl_gr_trace}).
@item 
They compute a Groebner basis of a polynomial list @var{plist} with
respect to the variable order @var{vlist} and the order type @var{order}.
@code{gr()} and @code{hgr()} compute a Groebner basis over the rationals
and @code{gr_mod} computes over GF(@var{p}).
@item 
Variables not included in @var{vlist} are regarded as
included in the ground field.
@item 
@code{gr()} uses trace-lifting (an improvement by modular computation)
 and sugar strategy.
@code{hgr()} uses trace-lifting and a cured sugar strategy
by using homogenization.
@item 
@code{dgr()} executes @code{gr()}, @code{dgr()} simultaneously on
two process in a child process list @var{procs} and returns
the result obtained first. The results returned from both the process
should be equal, but it is not known in advance which method is faster.
Therefore this function is useful to reduce the actual elapsed time.
@item 
The CPU time shown after an execution of @code{dgr()} indicates
that of the master process, and most of the time corresponds to the time
for communication.
@item
When the elements of @var{plist} are distributed polynomials,
the result is also a list of distributed polynomials.
In this case, firstly  the elements of @var{plist} is sorted by @code{dp_sort}
and the Grobner basis computation is started.
Variables must be given in @var{vlist} even in this case
(these variables are dummy).
\E
@end itemize

@example
[0] load("gr")$
[64] load("cyclic")$
[74] G=gr(cyclic(5),[c0,c1,c2,c3,c4],2);
[c4^15+122*c4^10-122*c4^5-1,...]
[75] GM=gr_mod(cyclic(5),[c0,c1,c2,c3,c4],2,31991)$
24628*c4^15+29453*c4^10+2538*c4^5+7363
[76] (G[0]*24628-GM[0])%31991;
0
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_gr_main dp_gr_mod_main dp_gr_f_main dp_weyl_gr_main dp_weyl_gr_mod_main dp_weyl_gr_f_main},
@fref{dp_ord}.
@end table

\JP @node lex_hensel lex_tl tolex tolex_d tolex_tl,,, グレブナ基底に関する函数
\EG @node lex_hensel lex_tl tolex tolex_d tolex_tl,,, Functions for Groebner basis computation
@subsection @code{lex_hensel}, @code{lex_tl}, @code{tolex}, @code{tolex_d}, @code{tolex_tl}
@findex lex_hensel
@findex lex_tl
@findex tolex
@findex tolex_d
@findex tolex_tl

@table @t
@item lex_hensel(@var{plist},@var{vlist1},@var{order},@var{vlist2},@var{homo})
@itemx lex_tl(@var{plist},@var{vlist1},@var{order},@var{vlist2},@var{homo})
\JP :: 基底変換による辞書式順序グレブナ基底の計算
\EG:: Groebner basis computation with respect to a lex order by change of ordering
@item tolex(@var{plist},@var{vlist1},@var{order},@var{vlist2})
@itemx tolex_d(@var{plist},@var{vlist1},@var{order},@var{vlist2},@var{procs})
@itemx tolex_tl(@var{plist},@var{vlist1},@var{order},@var{vlist2},@var{homo})
\JP :: グレブナ基底を入力とする, 基底変換による辞書式順序グレブナ基底の計算
\EG :: Groebner basis computation with respect to a lex order by change of ordering, starting from a Groebner basis
@end table

@table @var
@item return
\JP リスト
\EG list
@item plist  vlist1  vlist2  procs
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@item homo
\JP フラグ
\EG flag
@end table

@itemize @bullet
\BJP
@item
標準ライブラリの @samp{gr} で定義されている. 
@item
@code{lex_hensel()}, @code{lex_tl()} は, 
多項式リスト @var{plist} の, 変数順序 @var{vlist1}, 項順序型
@var{order} に関するグレブナ基底を求め, それを, 変数順序 @var{vlist2}
の辞書式順序グレブナ基底に変換する. 
@item
@code{tolex()}, @code{tolex_tl()} は, 
変数順序 @var{vlist1}, 項順序型 @var{order} に関するグレブナ基底である
多項式リスト @var{plist} を変数順序 @var{vlist2} の辞書式順序グレブナ
基底に変換する. 
@code{tolex_d()} は, @code{tolex()} における, 各基底の計算を, 子プロセス
リスト @var{procs} の各プロセスに分散計算させる. 
@item
@code{lex_hensel()}, @code{lex_tl()} においては, 辞書式順序グレブナ基底の
計算は次のように行われる. (@code{[Noro,Yokoyama]} 参照.)
@enumerate
@item
@var{vlist1}, @var{order} に関するグレブナ基底 @var{G0} を計算する. 
(@code{lex_hensel()} のみ. )
@item
@var{G0} の各元の @var{vlist2} に関する辞書式順序における頭係数を割らない
ような素数 @var{p} を選び, GF(@var{p}) 上での辞書式順序グレブナ基底
@var{Gp} を計算する. 
@item
@var{Gp} に現れるすべての項の, @var{G0} に関する正規形 @var{NF} を計算する. 
@item
@var{Gp} の各元 @var{f} につき, @var{f} の係数を未定係数で, 
@var{f} の各項を対応する @var{NF} の元で置き換え, 各項の係数を 0 と置いた,
未定係数に関する線形方程式系 @var{Lf} を作る. 
@item
@var{Lf} が, 法 @var{p} で一意解を持つことを用いて @var{Lf} の解を
法 @var{p}の解から Hensel 構成により求める. 
@item
すべての @var{Gp} の元につき線形方程式が解けたらその解全体が求める
辞書式順序でのグレブナ基底. もしどれかの線形方程式の求解に失敗したら, 
@var{p} をとり直してやり直す. 
@end enumerate

@item
@code{lex_tl()}, @code{tolex_tl()} においては, 辞書式順序グレブナ基底の
計算は次のように行われる. 

@enumerate
@item
@var{vlist1}, @var{order} に関するグレブナ基底 @var{G0} を計算する. 
(@code{lex_hensel()} のみ. )
@item
@var{G0} が 0 次元システムでないとき, @var{G0} を入力として, 
@var{G0} の各元の @var{vlist2} に関する辞書式順序における頭係数を割らない
ような素数 @var{p} を選び, @var{p} を用いた trace-lifting により辞書式
順序のグレブナ基底候補を求め, もし求まったならチェックなしにそれが求める
グレブナ基底となる. もし失敗したら, @var{p} をとり直してやり直す. 
@item
@var{G0} が 0 次元システムのとき, @var{G0} を入力として, 
まず, @var{vlist2} の最後の変数以外を消去する消去順序により
グレブナ基底 @var{G1} を計算し, それから辞書式順序のグレブナ基底を
計算する. その際, 各ステップでは, 入力の各元の, 求める順序における
頭係数を割らない素数を用いた trace-lifting でグレブナ基底候補を求め, 
もし求まったらチェックなしにそれがその順序でのグレブナ基底となる. 
@end enumerate

@item
有理式係数の計算は, @code{lex_tl()}, @code{tolex_tl()} のみ受け付ける. 
@item
@code{homo} が 0 でない場合, 内部で起動される Buchberger アルゴリズムに
おいて, 斉次化が行われる.
@item
@code{tolex_d()} で表示される時間は, この函数が実行されているプロセスに
おいて行われた計算に対応していて, 子プロセスにおける時間は含まれない. 
\E
\BEG
@item 
These functions are defined in @samp{gr} in the standard library
directory.
@item 
@code{lex_hensel()} and @code{lex_tl()} first compute a Groebner basis
with respect to the variable order @var{vlist1} and the order type @var{order}.
Then the Groebner basis is converted into a lex order Groebner basis
with respect to the variable order @var{vlist2}.
@item 
@code{tolex()} and @code{tolex_tl()} convert a Groebner basis @var{plist}
with respect to the variable order @var{vlist1} and the order type @var{order}
into a lex order Groebner basis
with respect to the variable order @var{vlist2}.
@code{tolex_d()} does computations of basis elements in @code{tolex()}
in parallel on the processes in a child process list @var{procs}.
@item 
In @code{lex_hensel()} and @code{tolex_hensel()} a lex order Groebner basis
is computed as follows.(Refer to @code{[Noro,Yokoyama]}.)
@enumerate
@item 
Compute a Groebner basis @var{G0} with respect to @var{vlist1} and @var{order}.
(Only in @code{lex_hensel()}. )
@item 
Choose a prime which does not divide head coefficients of elements in @var{G0}
with respect to @var{vlist1} and @var{order}. Then compute a lex order
Groebner basis @var{Gp} over GF(@var{p}) with respect to @var{vlist2}.
@item 
Compute @var{NF}, the set of all the normal forms with respect to
@var{G0} of terms appearing in @var{Gp}.
@item 
For each element @var{f} in @var{Gp}, replace coefficients and terms in @var{f}
with undetermined coefficients and the corresponding polynomials in @var{NF}
respectively, and generate a system of liear equation @var{Lf} by equating
the coefficients of terms in the replaced polynomial with 0.
@item 
Solve @var{Lf} by Hensel lifting, starting from the unique mod @var{p}
solution.
@item 
If all the linear equations generated from the elements in @var{Gp}
could be solved, then the set of solutions corresponds to a lex order
Groebner basis. Otherwise redo the whole process with another @var{p}.
@end enumerate
      
@item
In @code{lex_tl()} and @code{tolex_tl()} a lex order Groebner basis
is computed as follows.(Refer to @code{[Noro,Yokoyama]}.)
      
@enumerate
@item 
Compute a Groebner basis @var{G0} with respect to @var{vlist1} and @var{order}.
(Only in @code{lex_tl()}. )
@item 
If @var{G0} is not zero-dimensional, choose a prime which does not divide
head coefficients of elements in @var{G0} with respect to @var{vlist1} and
@var{order}. Then compute a candidate of a lex order Groebner basis
via trace lifting with @var{p}. If it succeeds the candidate is indeed
a lex order Groebner basis without any check. Otherwise redo the whole
process with another @var{p}.
@item
    
If @var{G0} is zero-dimensional, starting from @var{G0},
compute a Groebner basis @var{G1} with respect to an elimination order
to eliminate variables other than the last variable in @var{vlist2}.
Then compute a lex order Groebner basis stating from @var{G1}. These
computations are done by trace lifting and the selection of a mudulus
@var{p} is the same as in non zero-dimensional cases.
@end enumerate
      
@item
Computations with rational function coefficients can be done only by
@code{lex_tl()} and @code{tolex_tl()}.
@item 
If @code{homo} is not equal to 0, homogenization is used in Buchberger
algorithm.
@item 
The CPU time shown after an execution of @code{tolex_d()} indicates
that of the master process, and it does not include the time in child
processes.
\E
@end itemize

@example
[78] K=katsura(5)$ 
30msec + gc : 20msec
[79] V=[u5,u4,u3,u2,u1,u0]$
0msec
[80] G0=hgr(K,V,2)$
91.558sec + gc : 15.583sec
[81] G1=lex_hensel(K,V,0,V,0)$
49.049sec + gc : 9.961sec
[82] G2=lex_tl(K,V,0,V,1)$
31.186sec + gc : 3.500sec
[83] gb_comp(G0,G1);
1
10msec
[84] gb_comp(G0,G2);
1
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_gr_main dp_gr_mod_main dp_gr_f_main dp_weyl_gr_main dp_weyl_gr_mod_main dp_weyl_gr_f_main},
\JP @fref{dp_ord}, @fref{分散計算}
\EG @fref{dp_ord}, @fref{Distributed computation}
@end table

\JP @node lex_hensel_gsl tolex_gsl tolex_gsl_d,,, グレブナ基底に関する函数
\EG @node lex_hensel_gsl tolex_gsl tolex_gsl_d,,, Functions for Groebner basis computation
@subsection @code{lex_hensel_gsl}, @code{tolex_gsl}, @code{tolex_gsl_d}
@findex lex_hensel_gsl
@findex tolex_gsl
@findex tolex_gsl_d

@table @t
@item lex_hensel_gsl(@var{plist},@var{vlist1},@var{order},@var{vlist2},@var{homo})
\JP :: GSL 形式のイデアル基底の計算
\EG ::Computation of an GSL form ideal basis
@item tolex_gsl(@var{plist},@var{vlist1},@var{order},@var{vlist2})
@itemx tolex_gsl_d(@var{plist},@var{vlist1},@var{order},@var{vlist2},@var{procs})
\JP :: グレブナ基底を入力とする, GSL 形式のイデアル基底の計算
\EG :: Computation of an GSL form ideal basis stating from a Groebner basis
@end table

@table @var
@item return
\JP リスト
\EG list
@item plist  vlist1  vlist2  procs
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@item homo
\JP フラグ
\EG flag
@end table

@itemize @bullet
\BJP
@item
@code{lex_hensel_gsl()} は @code{lex_hensel()} の, @code{tolex_gsl()} は
@code{tolex()} の変種で, 結果のみが異なる. 
@code{tolex_gsl_d()} は, 基底計算を, @code{procs} で指定される子プロセスに
分散計算させる. 
@item
入力が 0 次元システムで, その辞書式順序グレブナ基底が
@code{[f0,x1-f1,...,xn-fn]} (@code{f0},...,@code{fn} は
@code{x0} の 1 変数多項式) なる形 (これを SL 形式と呼ぶ) を持つ場合, 
@code{[[x1,g1,d1],...,[xn,gn,dn],[x0,f0,f0']]} なるリスト (これを GSL 形式と呼ぶ)
を返す. 
ここで, @code{gi} は, @code{di*f0'*fi-gi} が @code{f0} で割り切れるような
@code{x0} の1 変数多項式で, 
解は @code{f0(x0)=0} なる @code{x0} に対し, @code{[x1=g1/(d1*f0'),...,xn=gn/(dn*f0')]}
となる. 辞書式順序グレブナ基底が上のような形でない場合, @code{tolex()} に
よる通常のグレブナ基底を返す. 
@item
GSL 形式により表される基底はグレブナ基底ではないが, 一般に係数が SL 形式
のグレブナ基底より非常に小さいため計算も速く, 解も求めやすい. 
@code{tolex_gsl_d()} で表示される時間は, この函数が実行されているプロセスに
おいて行われた計算に対応していて, 子プロセスにおける時間は含まれない. 
\E
\BEG
@item 
@code{lex_hensel_gsl()} and @code{lex_hensel()} are variants of
@code{tolex_gsl()} and @code{tolex()} respectively. The results are
Groebner basis or a kind of ideal basis, called GSL form.
@code{tolex_gsl_d()} does basis computations in parallel on child
processes specified in @code{procs}.
      
@item
If the input is zero-dimensional and a lex order Groebner basis has
the form @code{[f0,x1-f1,...,xn-fn]} (@code{f0},...,@code{fn} are
univariate polynomials of @code{x0}; SL form), then this these
functions return a list such as
@code{[[x1,g1,d1],...,[xn,gn,dn],[x0,f0,f0']]} (GSL form).  In this list
@code{gi} is a univariate polynomial of @code{x0} such that
@code{di*f0'*fi-gi} divides @code{f0} and the roots of the input ideal is
@code{[x1=g1/(d1*f0'),...,xn=gn/(dn*f0')]} for @code{x0}
such that @code{f0(x0)=0}.
If the lex order Groebner basis does not have the above form, 
these functions return
a lex order Groebner basis computed by @code{tolex()}.
@item 
Though an ideal basis represented as GSL form is not a Groebner basis
we can expect that the coefficients are much smaller than those in a Groebner
basis and that the computation is efficient.
The CPU time shown after an execution of @code{tolex_gsl_d()} indicates
that of the master process, and it does not include the time in child
processes.
\E
@end itemize

@example
[103] K=katsura(5)$
[104] V=[u5,u4,u3,u2,u1,u0]$
[105] G0=gr(K,V,0)$
[106] GSL=tolex_gsl(G0,V,0,V)$ 
[107] GSL[0];
[u1,8635837421130477667200000000*u0^31-...]
[108] GSL[1];
[u2,10352277157007342793600000000*u0^31-...]
[109] GSL[5];
[u0,11771021876193064124640000000*u0^32-...,
376672700038178051988480000000*u0^31-...]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{lex_hensel lex_tl tolex tolex_d tolex_tl},
\JP @fref{分散計算}
\EG @fref{Distributed computation}
@end table

\JP @node gr_minipoly minipoly,,, グレブナ基底に関する函数
\EG @node gr_minipoly minipoly,,, Functions for Groebner basis computation
@subsection @code{gr_minipoly}, @code{minipoly}
@findex gr_minipoly
@findex minipoly

@table @t
@item gr_minipoly(@var{plist},@var{vlist},@var{order},@var{poly},@var{v},@var{homo})
\JP :: 多項式の, イデアルを法とした最小多項式の計算
\EG :: Computation of the minimal polynomial of a polynomial modulo an ideal
@item minipoly(@var{plist},@var{vlist},@var{order},@var{poly},@var{v})
\JP :: グレブナ基底を入力とする, 多項式の最小多項式の計算
\EG :: Computation of the minimal polynomial of a polynomial modulo an ideal
@end table

@table @var
@item return
\JP 多項式
\EG polynomial
@item plist  vlist
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@item poly
\JP 多項式
\EG polynomial
@item v
\JP 不定元
\EG indeterminate
@item homo
\JP フラグ
\EG flag
@end table

@itemize @bullet
\BJP
@item
@code{gr_minipoly()} はグレブナ基底の計算から行い, @code{minipoly()} は
入力をグレブナ基底とみなす. 
@item
イデアル I が体 K 上の多項式環 K[X] の 0 次元イデアルの時, 
K[@var{v}] の元 f(@var{v}) に f(@var{p}) mod I を対応させる
環準同型の核は 0 でない多項式により生成される. この生成元を @var{p}
の, 法 @var{I} での最小多項式と呼ぶ. 
@item
@code{gr_minipoly()}, @code{minipoly()} は, 多項式 @var{p} の最小多項式
を求め, @var{v} を変数とする多項式として返す. 
@item
最小多項式は, グレブナ基底の 1 つの元として計算することもできるが, 
最小多項式のみを求めたい場合, @code{minipoly()}, @code{gr_minipoly()} は
グレブナ基底を用いる方法に比べて効率がよい. 
@item
@code{gr_minipoly()} に指定する項順序としては, 通常全次数逆辞書式順序を
用いる. 
\E
\BEG
@item 
@code{gr_minipoly()} begins by computing a Groebner basis.
@code{minipoly()} regards an input as a Groebner basis with respect to
the variable order @var{vlist} and the order type @var{order}.
@item 
Let K be a field. If an ideal @var{I} in K[X] is zero-dimensional, then, for
a polynomial @var{p} in K[X], the kernel of a homomorphism from
K[@var{v}] to K[X]/@var{I} which maps f(@var{v}) to f(@var{p}) mod @var{I}
is generated by a polynomial. The generator is called the minimal polynomial
of @var{p} modulo @var{I}.
@item 
@code{gr_minipoly()} and @code{minipoly()} computes the minimal polynomial
of a polynomial @var{p} and returns it as a polynomial of @var{v}.
@item 
The minimal polynomial can be computed as an element of a Groebner basis.
But if we are only interested in the minimal polynomial,
@code{minipoly()} and @code{gr_minipoly()} can compute it more efficiently
than methods using Groebner basis computation.
@item 
It is recommended to use a degree reverse lex order as a term order
for @code{gr_minipoly()}.
\E
@end itemize

@example
[117] G=tolex(G0,V,0,V)$      
43.818sec + gc : 11.202sec
[118] GSL=tolex_gsl(G0,V,0,V)$
17.123sec + gc : 2.590sec
[119] MP=minipoly(G0,V,0,u0,z)$
4.370sec + gc : 780msec
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{lex_hensel lex_tl tolex tolex_d tolex_tl}.
@end table

\JP @node tolexm minipolym,,, グレブナ基底に関する函数
\EG @node tolexm minipolym,,, Functions for Groebner basis computation
@subsection @code{tolexm}, @code{minipolym}
@findex tolexm
@findex minipolym

@table @t
@item tolexm(@var{plist},@var{vlist1},@var{order},@var{vlist2},@var{mod})
\JP :: 法 @var{mod} での基底変換によるグレブナ基底計算
\EG :: Groebner basis computation modulo @var{mod} by change of ordering.
@item minipolym(@var{plist},@var{vlist1},@var{order},@var{poly},@var{v},@var{mod})
\JP :: 法 @var{mod} でのグレブナ基底による多項式の最小多項式の計算
\EG :: Minimal polynomial computation modulo @var{mod} the same method as
@end table

@table @var
@item return
\JP @code{tolexm()} : リスト, @code{minipolym()} : 多項式
\EG @code{tolexm()} : list, @code{minipolym()} : polynomial
@item plist  vlist1  vlist2
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@item mod
\JP 素数
\EG prime
@end table

@itemize @bullet
\BJP
@item
入力 @var{plist} はいずれも 変数順序 @var{vlist1}, 項順序型 @var{order},
法 @var{mod} におけるグレブナ基底でなければならない. 
@item
@code{minipolym()} は @code{minipoly} に対応する計算を法 @var{mod}で行う. 
@item
@code{tolexm()} は FGLM 法による基底変換により @var{vlist2},
辞書式順序によるグレブナ基底を計算する. 
\E
\BEG
@item 
An input @var{plist} must be a Groebner basis modulo @var{mod}
with respect to the variable order @var{vlist1} and the order type @var{order}.
@item 
@code{minipolym()} executes the same computation as in @code{minipoly}.
@item 
@code{tolexm()} computes a lex order Groebner basis modulo @var{mod}
with respect to the variable order @var{vlist2}, by using FGLM algorithm.
\E
@end itemize

@example
[197] tolexm(G0,V,0,V,31991);
[8271*u0^31+10435*u0^30+816*u0^29+26809*u0^28+...,...]
[198] minipolym(G0,V,0,u0,z,31991);
z^32+11405*z^31+20868*z^30+21602*z^29+...
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{lex_hensel lex_tl tolex tolex_d tolex_tl},
@fref{gr_minipoly minipoly}.
@end table

\JP @node dp_gr_main dp_gr_mod_main dp_gr_f_main dp_weyl_gr_main dp_weyl_gr_mod_main dp_weyl_gr_f_main,,, グレブナ基底に関する函数
\EG @node dp_gr_main dp_gr_mod_main dp_gr_f_main dp_weyl_gr_main dp_weyl_gr_mod_main dp_weyl_gr_f_main,,, Functions for Groebner basis computation
@subsection @code{dp_gr_main}, @code{dp_gr_mod_main}, @code{dp_gr_f_main}, @code{dp_weyl_gr_main}, @code{dp_weyl_gr_mod_main}, @code{dp_weyl_gr_f_main}
@findex dp_gr_main
@findex dp_gr_mod_main
@findex dp_gr_f_main
@findex dp_weyl_gr_main
@findex dp_weyl_gr_mod_main
@findex dp_weyl_gr_f_main

@table @t
@item dp_gr_main(@var{plist},@var{vlist},@var{homo},@var{modular},@var{order})
@itemx dp_gr_mod_main(@var{plist},@var{vlist},@var{homo},@var{modular},@var{order})
@itemx dp_gr_f_main(@var{plist},@var{vlist},@var{homo},@var{order})
@itemx dp_weyl_gr_main(@var{plist},@var{vlist},@var{homo},@var{modular},@var{order})
@itemx dp_weyl_gr_mod_main(@var{plist},@var{vlist},@var{homo},@var{modular},@var{order})
@itemx dp_weyl_gr_f_main(@var{plist},@var{vlist},@var{homo},@var{order})
\JP :: グレブナ基底の計算 (組み込み函数)
\EG :: Groebner basis computation (built-in functions)
@end table

@table @var
@item return
\JP リスト
\EG list
@item plist  vlist
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@item homo
\JP フラグ
\EG flag
@item modular
\JP フラグまたは素数
\EG flag or prime
@end table

@itemize @bullet
\BJP
@item
これらの函数は, グレブナ基底計算の基本的組み込み函数であり, @code{gr()},
@code{hgr()}, @code{gr_mod()} などはすべてこれらの函数を呼び出して計算
を行っている. 関数名に weyl が入っているものは, Weyl 代数上の計算
のための関数である. 
@item
@code{dp_gr_f_main()}, @code{dp_weyl_f_main()} は, 種々の有限体上のグレブナ基底を計算する
場合に用いる. 入力は, あらかじめ, @code{simp_ff()} などで, 
考える有限体上に射影されている必要がある. 
@item
フラグ @var{homo} が 0 でない時, 入力を斉次化してから Buchberger アルゴリズム
を実行する. 
@item
@code{dp_gr_mod_main()} に対しては, @var{modular} は, GF(@var{modular}) 上
での計算を意味する. 
@code{dp_gr_main()} に対しては, @var{modular} は次のような意味を持つ. 
@enumerate
@item
@var{modular} が 1 の時, trace-lifting による計算を行う. 素数は
@code{lprime(0)} から順に成功するまで @code{lprime()} を呼び出して生成する. 
@item
@var{modular} が 2 以上の自然数の時, その値を素数とみなして trace-lifting
を行う. その素数で失敗した場合, 0 を返す. 
@item
@var{modular} が負の場合, 
@var{-modular} に対して上述の規則が適用されるが, trace-lifting の最終
段階のグレブナ基底チェックとイデアルメンバシップチェックが省略される. 
@end enumerate

@item
@code{gr(P,V,O)} は @code{dp_gr_main(P,V,0,1,O)}, @code{hgr(P,V,O)} は
@code{dp_gr_main(P,V,1,1,O)}, @code{gr_mod(P,V,O,M)} は
@code{dp_gr_mod_main(P,V,0,M,O)} をそれぞれ実行する. 
@item
@var{homo}, @var{modular} の他に, @code{dp_gr_flags()} で設定される
さまざまなフラグにより計算が制御される. 
\E
\BEG
@item
These functions are fundamental built-in functions for Groebner basis
computation and @code{gr()},@code{hgr()} and @code{gr_mod()}
are all interfaces to these functions. Functions whose names
contain weyl are those for computation in Weyl algebra.
@item
@code{dp_gr_f_main()} and @code{dp_weyl_gr_f_main()}
are functions for Groebner basis computation
over various finite fields. Coefficients of input polynomials 
must be converted to elements of a finite field 
currently specified by @code{setmod_ff()}.
@item
If @var{homo} is not equal to 0, homogenization is applied before entering
Buchberger algorithm
@item
For @code{dp_gr_mod_main()}, @var{modular} means a computation over
GF(@var{modular}).
For @code{dp_gr_main()}, @var{modular} has the following mean.
@enumerate
@item
If @var{modular} is 1 , trace lifting is used. Primes for trace lifting
are generated by @code{lprime()}, starting from @code{lprime(0)}, until
the computation succeeds.
@item
If @var{modular} is an integer  greater than 1, the integer is regarded as a
prime and trace lifting is executed by using the prime. If the computation
fails then 0 is returned.
@item
If @var{modular} is negative, the above rule is applied for @var{-modular}
but the Groebner basis check and ideal-membership check are omitted in
the last stage of trace lifting.
@end enumerate
     
@item
@code{gr(P,V,O)}, @code{hgr(P,V,O)} and @code{gr_mod(P,V,O,M)} execute
@code{dp_gr_main(P,V,0,1,O)}, @code{dp_gr_main(P,V,1,1,O)}
and @code{dp_gr_mod_main(P,V,0,M,O)} respectively.
@item
Actual computation is controlled by various parameters set by 
@code{dp_gr_flags()}, other then by @var{homo} and @var{modular}.
\E
@end itemize

@table @t
\JP @item 参照
\EG @item References
@fref{dp_ord},
@fref{dp_gr_flags dp_gr_print},
@fref{gr hgr gr_mod},
@fref{setmod_ff},
\JP @fref{計算および表示の制御}.
\EG @fref{Controlling Groebner basis computations}
@end table

\JP @node dp_f4_main dp_f4_mod_main dp_weyl_f4_main dp_weyl_f4_mod_main,,, グレブナ基底に関する函数
\EG @node dp_f4_main dp_f4_mod_main dp_weyl_f4_main dp_weyl_f4_mod_main,,, Functions for Groebner basis computation
@subsection @code{dp_f4_main}, @code{dp_f4_mod_main}, @code{dp_weyl_f4_main}, @code{dp_weyl_f4_mod_main}
@findex dp_f4_main
@findex dp_f4_mod_main
@findex dp_weyl_f4_main
@findex dp_weyl_f4_mod_main

@table @t
@item dp_f4_main(@var{plist},@var{vlist},@var{order})
@itemx dp_f4_mod_main(@var{plist},@var{vlist},@var{order})
@itemx dp_weyl_f4_main(@var{plist},@var{vlist},@var{order})
@itemx dp_weyl_f4_mod_main(@var{plist},@var{vlist},@var{order})
\JP :: F4 アルゴリズムによるグレブナ基底の計算 (組み込み函数)
\EG :: Groebner basis computation by F4 algorithm (built-in functions)
@end table

@table @var
@item return
\JP リスト
\EG list
@item plist  vlist
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@end table

@itemize @bullet
\BJP
@item
F4 アルゴリズムによりグレブナ基底の計算を行う. 
@item
F4 アルゴリズムは, J.C. Faugere により提唱された新世代グレブナ基底
算法であり, 本実装は, 中国剰余定理による線形方程式求解を用いた
試験的な実装である. 
@item
斉次化の引数がないことを除けば, 引数および動作はそれぞれ 
@code{dp_gr_main()}, @code{dp_gr_mod_main()},
@code{dp_weyl_gr_main()}, @code{dp_weyl_gr_mod_main()}
と同様である. 
\E
\BEG
@item
These functions compute Groebner bases by F4 algorithm.
@item
F4 is a new generation algorithm for Groebner basis computation
invented by J.C. Faugere. The current implementation of @code{dp_f4_main()}
uses Chinese Remainder theorem and not highly optimized.
@item
Arguments and actions are the same as those of 
@code{dp_gr_main()}, @code{dp_gr_mod_main()},
@code{dp_weyl_gr_main()}, @code{dp_weyl_gr_mod_main()},
except for lack of the argument for controlling homogenization.
\E
@end itemize

@table @t
\JP @item 参照
\EG @item References
@fref{dp_ord},
@fref{dp_gr_flags dp_gr_print},
@fref{gr hgr gr_mod},
\JP @fref{計算および表示の制御}.
\EG @fref{Controlling Groebner basis computations}
@end table

\JP @node nd_gr nd_gr_trace nd_f4 nd_f4_trace nd_weyl_gr nd_weyl_gr_trace,,, グレブナ基底に関する函数
\EG @node nd_gr nd_gr_trace nd_f4 nd_f4_trace nd_weyl_gr nd_weyl_gr_trace,,, Functions for Groebner basis computation
@subsection @code{nd_gr}, @code{nd_gr_trace}, @code{nd_f4}, @code{nd_f4_trace}, @code{nd_weyl_gr}, @code{nd_weyl_gr_trace}
@findex nd_gr
@findex nd_gr_trace
@findex nd_f4
@findex nd_f4_trace
@findex nd_weyl_gr
@findex nd_weyl_gr_trace

@table @t
@item nd_gr(@var{plist},@var{vlist},@var{p},@var{order}[|@var{option=value,...}])
@itemx nd_gr_trace(@var{plist},@var{vlist},@var{homo},@var{p},@var{order}[|@var{option=value,...}])
@itemx nd_f4(@var{plist},@var{vlist},@var{modular},@var{order}[|@var{option=value,...}])
@itemx nd_f4_trace(@var{plist},@var{vlist},@var{homo},@var{p},@var{order}[|@var{option=value,...}])
@itemx nd_weyl_gr(@var{plist},@var{vlist},@var{p},@var{order}[|@var{option=value,...}])
@itemx nd_weyl_gr_trace(@var{plist},@var{vlist},@var{homo},@var{p},@var{order}[|@var{option=value,...}])
\JP :: グレブナ基底の計算 (組み込み函数)
\EG :: Groebner basis computation (built-in functions)
@end table

@table @var
@item return
\JP リスト
\EG list
@item plist  vlist
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@item homo
\JP フラグ
\EG flag
@item modular
\JP フラグまたは素数
\EG flag or prime
@end table

\BJP
@itemize @bullet
@item
これらの函数は, グレブナ基底計算組み込み関数の新実装である.
@item @code{nd_gr} は, @code{p} が 0 のとき有理数体上の Buchberger
アルゴリズムを実行する. @code{p} が 2 以上の自然数のとき, GF(p) 上の
Buchberger アルゴリズムを実行する.
@item @code{nd_gr_trace} および @code{nd_f4_trace}
は有理数体上で trace アルゴリズムを実行する.
@var{p} が 0 または 1 のとき, 自動的に選ばれた素数を用いて, 成功する
まで trace アルゴリズムを実行する.
@var{p} が 2 以上のとき, trace はGF(p) 上で計算される. trace アルゴリズム
が失敗した場合 0 が返される. @var{p} が負の場合, グレブナ基底チェックは
行わない. この場合, @var{p} が -1 ならば自動的に選ばれた素数が,
それ以外は指定された素数を用いてグレブナ基底候補の計算が行われる. 
@code{nd_f4_trace} は, 各全次数について, ある有限体上で F4 アルゴリズム
で行った結果をもとに, その有限体上で 0 でない基底を与える S-多項式のみを
用いて行列生成を行い, その全次数における基底を生成する方法である. 得られる
多項式集合はやはりグレブナ基底候補であり, @code{nd_gr_trace} と同様の
チェックが行われる.
@item
@code{nd_f4} は @code{modular} が 0 のとき有理数体上の, @code{modular} が
マシンサイズ素数のとき有限体上の F4 アルゴリズムを実行する.
@item
@var{plist} が多項式リストの場合, @var{plist}で生成されるイデアルのグレブナー基底が
計算される. @var{plist} が多項式リストのリストの場合, 各要素は多項式環上の自由加群の元と見なされ,
これらが生成する部分加群のグレブナー基底が計算される. 後者の場合, 項順序は加群に対する項順序を
指定する必要がある. これは @var{[s,ord]} の形で指定する. @var{s} が 0 ならば TOP (Term Over Position),
1 ならば POT (Position Over Term) を意味し, @var{ord} は多項式環の単項式に対する項順序である.
@item
@code{nd_weyl_gr}, @code{nd_weyl_gr_trace} は Weyl 代数用である.
@item
@code{f4} 系関数以外はすべて有理関数係数の計算が可能である.
@item
一般に @code{dp_gr_main}, @code{dp_gr_mod_main} より高速であるが,
特に有限体上の場合顕著である.
@item
以下のオプションが指定できる.
@table @code
@item homo
1 のとき, 斉次化を経由して計算する. (@code{nd_gr}, @code{nd_f4} のみ)
@item dp
1 のとき, 分散表現多項式 (加群の場合には加群多項式) を結果として返す.
@item nora
1 のとき, 結果の相互簡約を行わない.
@end table
@end itemize
\E

\BEG
@itemize @bullet
@item
These functions are new implementations for computing Groebner bases.
@item @code{nd_gr} executes Buchberger algorithm over the rationals
if  @code{p} is 0, and that over GF(p) if @code{p} is a prime.
@item @code{nd_gr_trace} executes the trace algorithm over the rationals.
If @code{p} is 0 or 1, the trace algorithm is executed until it succeeds
by using automatically chosen primes.
If @code{p} a positive prime, 
the trace is computed over GF(p). 
If the trace algorithm fails 0 is returned.
If @code{p} is negative, 
the Groebner basis check and ideal-membership check are omitted.
In this case, an automatically chosen prime if @code{p} is 1,
otherwise the specified prime is used to compute a Groebner basis
candidate.
Execution of @code{nd_f4_trace} is done as follows:
For each total degree, an F4-reduction of S-polynomials over a finite field
is done, and S-polynomials which give non-zero basis elements are gathered.
Then F4-reduction over Q is done for the gathered S-polynomials.
The obtained polynomial set is a Groebner basis candidate and the same
check procedure as in the case of @code{nd_gr_trace} is done.
@item
@code{nd_f4} executes F4 algorithm over Q if @code{modular} is equal to 0,
or over a finite field GF(@code{modular}) 
if @code{modular} is a prime number of machine size (<2^29).
If @var{plist} is a list of polynomials, then a Groebner basis of the ideal generated by @var{plist}
is computed. If @var{plist} is a list of lists of polynomials, then each list of polynomials are regarded
as an element of a free module over a polynomial ring and a Groebner basis of the sub-module generated by @var{plist}
in the free module. In the latter case a term order in the free module should be specified.
This is specified by @var{[s,ord]}. If @var{s} is 0 then it means TOP (Term Over Position).
If @var{s} is 1 then it means POT 1 (Position Over Term). @var{ord} is a term order in the base polynomial ring.
@item
@code{nd_weyl_gr}, @code{nd_weyl_gr_trace} are for Weyl algebra computation.
@item
Functions except for F4 related ones can handle rational coefficient cases.
@item
In general these functions are more efficient than 
@code{dp_gr_main}, @code{dp_gr_mod_main}, especially over finite fields.
@item
The following options can be specified.
@table @code
@item homo
If set to 1, the computation is done via homogenization. (only for @code{nd_gr} and @code{nd_f4})
@item dp
If set to 1, the functions return a list of distributed polynomials (a list of
module polynomials when the input is a sub-module).
@item nora
If set to 1, the inter-reduction is not performed.
@end table
@end itemize
\E

@example
[38] load("cyclic")$
[49] C=cyclic(7)$
[50] V=vars(C)$
[51] cputime(1)$
[52] dp_gr_mod_main(C,V,0,31991,0)$
26.06sec + gc : 0.313sec(26.4sec)
[53] nd_gr(C,V,31991,0)$
ndv_alloc=1477188
5.737sec + gc : 0.1837sec(5.921sec)
[54] dp_f4_mod_main(C,V,31991,0)$  
3.51sec + gc : 0.7109sec(4.221sec)
[55] nd_f4(C,V,31991,0)$
1.906sec + gc : 0.126sec(2.032sec)
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_ord},
@fref{dp_gr_flags dp_gr_print},
\JP @fref{計算および表示の制御}.
\EG @fref{Controlling Groebner basis computations}
@end table

\JP @node nd_gr_postproc nd_weyl_gr_postproc,,, グレブナ基底に関する函数
\EG @node nd_gr_postproc nd_weyl_gr_postproc,,, Functions for Groebner basis computation
@subsection @code{nd_gr_postproc}, @code{nd_weyl_gr_postproc}
@findex nd_gr_postproc
@findex nd_weyl_gr_postproc

@table @t
@item nd_gr_postproc(@var{plist},@var{vlist},@var{p},@var{order},@var{check})
@itemx nd_weyl_gr_postproc(@var{plist},@var{vlist},@var{p},@var{order},@var{check})
\JP :: グレブナ基底候補のチェックおよび相互簡約
\EG :: Check of Groebner basis candidate and inter-reduction
@end table

@table @var
@item return
\JP リスト または 0
\EG list or 0
@item plist  vlist
\JP リスト
\EG list
@item p
\JP 素数または 0
\EG prime or 0
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@item check
\JP 0 または 1
\EG 0 or 1
@end table

@itemize @bullet
\BJP
@item
グレブナ基底(候補)の相互簡約を行う.
@item
@code{nd_weyl_gr_postproc} は Weyl 代数用である.
@item
@var{check=1} の場合, @var{plist} が, @var{vlist}, @var{p}, @var{order} で指定される多項式環, 項順序でグレブナー基底になっているか
のチェックも行う.
@item
斉次化して計算したグレブナー基底を非斉次化したものを相互簡約を行う, CRT で計算したグレブナー基底候補のチェックを行うなどの場合に用いる.
\E
\BEG
@item
Perform the inter-reduction for a Groebner basis (candidate).
@item
@code{nd_weyl_gr_postproc} is for Weyl algebra.
@item
If @var{check=1} then the check whether @var{plist} is a Groebner basis with respect to a term order in a polynomial ring 
or Weyl algebra specified by @var{vlist}, @var{p} and @var{order}.
@item
This function is used for inter-reduction of a non-reduced Groebner basis that is obtained by dehomogenizing a Groebner basis
computed via homogenization, or Groebner basis check of a Groebner basis candidate computed by CRT.
\E
@end itemize

@example
afo
@end example

\JP @node dp_gr_flags dp_gr_print,,, グレブナ基底に関する函数
\EG @node dp_gr_flags dp_gr_print,,, Functions for Groebner basis computation
@subsection @code{dp_gr_flags}, @code{dp_gr_print}
@findex dp_gr_flags
@findex dp_gr_print

@table @t
@item dp_gr_flags([@var{list}])
@itemx dp_gr_print([@var{i}])
\JP :: 計算および表示用パラメタの設定, 参照
\BEG :: Set and show various parameters for controlling computations 
and showing information.
\E
@end table

@table @var
@item return
\JP 設定値
\EG value currently set
@item list
\JP リスト
\EG list
@item i
\JP 整数
\EG integer
@end table

@itemize @bullet
\BJP
@item
@code{dp_gr_main()}, @code{dp_gr_mod_main()}, @code{dp_gr_f_main()}  実行時におけるさまざま
なパラメタを設定, 参照する. 
@item
引数がない場合, 現在の設定が返される. 
@item
引数は, @code{["Print",1,"NoSugar",1,...]} なる形のリストで, 左から順に
設定される. パラメタ名は文字列で与える必要がある. 
@item
@code{dp_gr_print()} は, 特にパラメタ @code{Print}, @code{PrintShort} の値を直接設定, 参照
できる. 設定される値は次の通りである。
@table @var
@item i=0
@code{Print=0}, @code{PrintShort=0}
@item i=1
@code{Print=1}, @code{PrintShort=0}
@item i=2
@code{Print=0}, @code{PrintShort=1}
@end table
これは, @code{dp_gr_main()} などをサブルーチンとして用いるユーザ
函数において, そのサブルーチンが中間情報の表示
を行う際に, 迅速にフラグを見ることができるように用意されている. 
\E
\BEG
@item
@code{dp_gr_flags()} sets and shows various parameters for Groebner basis
 computation.
@item
If no argument is specified the current settings are returned.
@item
Arguments must be specified as a list such as
 @code{["Print",1,"NoSugar",1,...]}. Names of parameters must be character
strings.
@item
@code{dp_gr_print()} is used to set and show the value of a parameter
@code{Print} and @code{PrintShort}. 
@table @var
@item i=0
@code{Print=0}, @code{PrintShort=0}
@item i=1
@code{Print=1}, @code{PrintShort=0}
@item i=2
@code{Print=0}, @code{PrintShort=1}
@end table
This functions is prepared to get quickly the value
when a user defined function calling @code{dp_gr_main()} etc.
uses the value as a flag for showing intermediate information.
\E
@end itemize

@table @t
\JP @item 参照
\EG @item References
\JP @fref{計算および表示の制御}
\EG @fref{Controlling Groebner basis computations}
@end table

\JP @node dp_ord,,, グレブナ基底に関する函数
\EG @node dp_ord,,, Functions for Groebner basis computation
@subsection @code{dp_ord}
@findex dp_ord

@table @t
@item dp_ord([@var{order}])
\JP :: 変数順序型の設定, 参照
\EG :: Set and show the ordering type.
@end table

@table @var
@item return
\JP 変数順序型 (数, リストまたは行列)
\EG ordering type (number, list or matrix)
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@end table

@itemize @bullet
\BJP
@item
引数がある時, 変数順序型を @var{order} に設定する. 引数がない時, 
現在設定されている変数順序型を返す. 

@item
分散表現多項式に関する函数, 演算は引数として変数順序型をとるものととらないもの
があり, とらないものに関しては, その時点で設定されている値を用いて計算が
行われる. 

@item
@code{gr()} など, 引数として変数順序型をとるものは, 内部で @code{dp_ord()}
を呼び出し, 変数順序型を設定する. この設定は, 計算終了後も生き残る. 

@item
分散表現多項式の四則演算も, 設定されている値を用いて計算される. 従って, 
その多項式が生成された時点における変数順序型が, 四則演算時に正しく設定
されていなければならない. また, 演算対象となる多項式は, 同一の変数順序
型に基づいて生成されたものでなければならない. 

@item
トップレベル函数以外の函数を直接呼び出す場合には, この函数により
変数順序型を正しく設定しなければならない. 

@item
引数がリストの場合, 自由加群における項順序型を設定する. 引数が@code{[0,Ord]} の場合,
多項式環上で @code{Ord} で指定される項順序に基づく TOP 順序, 引数が @code{[1,Ord]} の場合
OPT 順序を設定する.

\E
\BEG
@item
If an argument is specified, the function
sets the current ordering type to @var{order}.
If no argument is specified, the function returns the ordering
type currently set.
     
@item
There are two types of functions concerning distributed polynomial,
functions which take a ordering type and those which don't take it.
The latter ones use the current setting.
     
@item
Functions such as @code{gr()}, which need a ordering type as an argument,
call @code{dp_ord()} internally during the execution.
The setting remains after the execution.
     
Fundamental arithmetics for distributed polynomial also use the current
setting. Therefore, when such arithmetics for distributed polynomials
are done, the current setting must coincide with the ordering type
which was used upon the creation of the polynomials. It is assumed
that such polynomials were generated under the same ordering type.
     
@item
Type of term ordering must be correctly set by this function
when functions other than top level functions are called directly.

@item
If the argument is a list, then an ordering type in a free module is set.
If the argument is @code{[0,Ord]} then a TOP ordering based on the ordering type specified
by @code{Ord} is set. 
If the argument is @code{[1,Ord]} then a POT ordering is set.
\E
@end itemize

@example
[19] dp_ord(0)$          
[20] <<1,2,3>>+<<3,1,1>>;
(1)*<<1,2,3>>+(1)*<<3,1,1>>
[21] dp_ord(2)$          
[22] <<1,2,3>>+<<3,1,1>>;
(1)*<<3,1,1>>+(1)*<<1,2,3>>
@end example

@table @t
\JP @item 参照
\EG @item References
\JP @fref{項順序の設定}
\EG @fref{Setting term orderings}
@end table

\JP @node dp_set_weight dp_set_top_weight dp_weyl_set_weight,,, グレブナ基底に関する函数
\EG @node dp_set_weight dp_set_top_weight dp_weyl_set_weight,,, Functions for Groebner basis computation
@subsection @code{dp_set_weight}, @code{dp_set_top_weight}, @code{dp_weyl_set_weight}
@findex dp_set_weight
@findex dp_set_top_weight
@findex dp_weyl_set_weight

@table @t
@item dp_set_weight([@var{weight}])
\JP :: sugar weight の設定, 参照
\EG :: Set and show the sugar weight.
@item dp_set_top_weight([@var{weight}])
\JP :: top weight の設定, 参照
\EG :: Set and show the top weight.
@item dp_weyl_set_weight([@var{weight}])
\JP :: weyl weight の設定, 参照
\EG :: Set and show the weyl weight.
@end table

@table @var
@item return
\JP ベクトル
\EG a vector
@item weight
\JP 整数のリストまたはベクトル
\EG a list or vector of integers
@end table

@itemize @bullet
\BJP
@item
@code{dp_set_weight} は sugar weight を @var{weight} に設定する. 引数がない時, 
現在設定されている sugar weight を返す. sugar weight は正整数を成分とするベクトルで,
各変数の重みを表す. 次数つき順序において, 単項式の次数を計算する際に用いられる.
斉次化変数用に, 末尾に 1 を付け加えておくと安全である.
@item
@code{dp_set_top_weight} は top weight を @var{weight} に設定する. 引数がない時, 
現在設定されている top weight を返す. top weight が設定されているとき, 
まず top weight による単項式比較を先に行う. tie breaker として現在設定されている
項順序が用いられるが, この比較には top weight は用いられない.

@item
@code{dp_weyl_set_weight} は weyl weight を @var{weight} に設定する. 引数がない時, 
現在設定されている weyl weight を返す. weyl weight w を設定すると,
項順序型 11 での計算において, (-w,w) を top weight, tie breaker を graded reverse lex
とした項順序が設定される.
\E
\BEG
@item
@code{dp_set_weight} sets the sugar weight=@var{weight}. It returns the current sugar weight.
A sugar weight is a vector with positive integer components and it represents the weights of variables.
It is used for computing the weight of a monomial in a graded ordering.
It is recommended to append a component 1 at the end of the weight vector for a homogenizing variable.
@item
@code{dp_set_top_weight} sets the top weight=@var{weight}. It returns the current top weight.
It a top weight is set, the weights of monomials under the top weight are firstly compared.
If the the weights are equal then the current term ordering is applied as a tie breaker, but
the top weight is not used in the tie breaker.

@item
@code{dp_weyl_set_weight} sets the weyl weigh=@var{weight}. It returns the current weyl weight.
If a weyl weight w is set, in the comparison by the term order type 11, a term order with 
the top weight=(-w,w) and the tie breaker=graded reverse lex is applied.
\E
@end itemize

@table @t
\JP @item 参照
\EG @item References
@fref{Weight}
@end table


\JP @node dp_ptod,,, グレブナ基底に関する函数
\EG @node dp_ptod,,, Functions for Groebner basis computation
@subsection @code{dp_ptod}
@findex dp_ptod

@table @t
@item dp_ptod(@var{poly},@var{vlist})
\JP :: 多項式を分散表現多項式に変換する. 
\EG :: Converts an ordinary polynomial into a distributed polynomial.
@end table

@table @var
@item return
\JP 分散表現多項式
\EG distributed polynomial
@item poly
\JP 多項式
\EG polynomial
@item vlist
\JP リスト
\EG list
@end table

@itemize @bullet
\BJP
@item
変数順序 @var{vlist} および現在の変数順序型に従って分散表現多項式に変換する. 
@item
@var{vlist} に含まれない不定元は, 係数体に属するとして変換される. 
\E
\BEG
@item
According to the variable ordering @var{vlist} and current
type of term ordering, this function converts an ordinary
polynomial into a distributed polynomial.
@item
Indeterminates not included in @var{vlist} are regarded to belong to
the coefficient field.
\E
@end itemize

@example
[50] dp_ord(0);
1
[51] dp_ptod((x+y+z)^2,[x,y,z]);
(1)*<<2,0,0>>+(2)*<<1,1,0>>+(1)*<<0,2,0>>+(2)*<<1,0,1>>+(2)*<<0,1,1>>
+(1)*<<0,0,2>>
[52] dp_ptod((x+y+z)^2,[x,y]);  
(1)*<<2,0>>+(2)*<<1,1>>+(1)*<<0,2>>+(2*z)*<<1,0>>+(2*z)*<<0,1>>
+(z^2)*<<0,0>>
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_dtop},
@fref{dp_ord}.
@end table

\JP @node dpm_dptodpm,,, グレブナ基底に関する函数
\EG @node dpm_dptodpm,,, Functions for Groebner basis computation
@subsection @code{dpm_dptodpm}
@findex dpm_dptodpm

@table @t
@item dpm_dptodpm(@var{dpoly},@var{pos})
\JP :: 分散表現多項式を加群多項式に変換する. 
\EG :: Converts a distributed polynomial into a module polynomial.
@end table

@table @var
@item return
\JP 加群多項式
\EG module polynomial
@item dpoly
\JP 分散表現多項式
\EG distributed polynomial
@item pos
\JP 正整数
\EG positive integer
@end table

@itemize @bullet
\BJP
@item
分散表現多項式を加群多項式に変換する.
@item
出力は加群多項式 @code{dpoly e_pos} である.
\E
\BEG
@item
This function converts a distributed polynomial into a module polynomial.
@item
The output is @code{dpoly e_pos}.
\E
@end itemize

@example
[50] dp_ord([0,0])$
[51] D=dp_ptod((x+y+z)^2,[x,y,z]);
(1)*<<2,0,0>>+(2)*<<1,1,0>>+(1)*<<0,2,0>>+(2)*<<1,0,1>>+(2)*<<0,1,1>>
+(1)*<<0,0,2>>
[52] dp_dptodpm(D,2);
(1)*<<2,0,0:2>>+(2)*<<1,1,0:2>>+(1)*<<0,2,0:2>>+(2)*<<1,0,1:2>>
+(2)*<<0,1,1:2>>+(1)*<<0,0,2:2>>
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_ptod},
@fref{dp_ord}.
@end table

\JP @node dpm_ltod,,, グレブナ基底に関する函数
\EG @node dpm_ltod,,, Functions for Groebner basis computation
@subsection @code{dpm_ltod}
@findex dpm_ltod

@table @t
@item dpm_dptodpm(@var{plist},@var{vlist})
\JP :: 多項式リストを加群多項式に変換する. 
\EG :: Converts a list of polynomials into a module polynomial.
@end table

@table @var
@item return
\JP 加群多項式
\EG module polynomial
@item plist
\JP 多項式リスト
\EG list of polynomials
@item vlist
\JP 変数リスト
\EG list of variables
@end table

@itemize @bullet
\BJP
@item
多項式リストを加群多項式に変換する.
@item
@code{[p1,...,pm]} は @code{p1 e1+...+pm em} に変換される.
\E
\BEG
@item
This function converts a list of polynomials into a module polynomial.
@item
@code{[p1,...,pm]} is converted into @code{p1 e1+...+pm em}.
\E
@end itemize

@example
[2126] dp_ord([0,0])$
[2127] dpm_ltod([x^2+y^2,x,y-z],[x,y,z]);
(1)*<<2,0,0:1>>+(1)*<<0,2,0:1>>+(1)*<<1,0,0:2>>+(1)*<<0,1,0:3>>
+(-1)*<<0,0,1:3>>
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dpm_dtol},
@fref{dp_ord}.
@end table

\JP @node dpm_dtol,,, グレブナ基底に関する函数
\EG @node dpm_dtol,,, Functions for Groebner basis computation
@subsection @code{dpm_dtol}
@findex dpm_dtol

@table @t
@item dpm_dptodpm(@var{poly},@var{vlist})
\JP :: 加群多項式を多項式リストに変換する. 
\EG :: Converts a module polynomial into a list of polynomials.
@end table

@table @var
@item return
\JP 多項式リスト
\EG list of polynomials
@item poly
\JP 加群多項式
\EG module polynomial
@item vlist
\JP 変数リスト
\EG list of variables
@end table

@itemize @bullet
\BJP
@item
加群多項式を多項式リストに変換する.
@item
@code{p1 e1+...+pm em} は @code{[p1,...,pm]} に変換される.
@item
出力リストの長さは, @code{poly} に含まれる標準基底の最大インデックスとなる.
\E
\BEG
@item
This function converts a module polynomial into a list of polynomials.
@item
@code{p1 e1+...+pm em} is converted into @code{[p1,...,pm]}.
@item
The length of the output list is equal to the largest index among those of the standard bases
containd in @code{poly}.
\E
@end itemize

@example
[2126] dp_ord([0,0])$
[2127] D=(1)*<<2,0,0:1>>+(1)*<<0,2,0:1>>+(1)*<<1,0,0:2>>+(1)*<<0,1,0:3>>
+(-1)*<<0,0,1:3>>$
[2128] dpm_dtol(D,[x,y,z]);
[x^2+y^2,x,y-z]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dpm_ltod},
@fref{dp_ord}.
@end table

\JP @node dp_dtop,,, グレブナ基底に関する函数
\EG @node dp_dtop,,, Functions for Groebner basis computation
@subsection @code{dp_dtop}
@findex dp_dtop

@table @t
@item dp_dtop(@var{dpoly},@var{vlist})
\JP :: 分散表現多項式を多項式に変換する. 
\EG :: Converts a distributed polynomial into an ordinary polynomial.
@end table

@table @var
@item return
\JP 多項式
\EG polynomial
@item dpoly
\JP 分散表現多項式
\EG distributed polynomial
@item vlist
\JP リスト
\EG list
@end table

@itemize @bullet
\BJP
@item
分散表現多項式を, 与えられた不定元リストを用いて多項式に変換する. 
@item
不定元リストは, 長さ分散表現多項式の変数の個数と一致していれば何でもよい. 
\E
\BEG
@item
This function converts a distributed polynomial into an ordinary polynomial
according to a list of indeterminates @var{vlist}.
@item
@var{vlist} is such a list that its length coincides with the number of
variables of @var{dpoly}.
\E
@end itemize

@example
[53] T=dp_ptod((x+y+z)^2,[x,y]);
(1)*<<2,0>>+(2)*<<1,1>>+(1)*<<0,2>>+(2*z)*<<1,0>>+(2*z)*<<0,1>>
+(z^2)*<<0,0>>
[54] P=dp_dtop(T,[a,b]);
z^2+(2*a+2*b)*z+a^2+2*b*a+b^2
@end example

\JP @node dp_mod dp_rat,,, グレブナ基底に関する函数
\EG @node dp_mod dp_rat,,, Functions for Groebner basis computation
@subsection @code{dp_mod}, @code{dp_rat}
@findex dp_mod
@findex dp_rat

@table @t
@item dp_mod(@var{p},@var{mod},@var{subst})
\JP :: 有理数係数分散表現多項式の有限体係数への変換
\EG :: Converts a distributed polynomial into one with coefficients in a finite field.
@item dp_rat(@var{p})
\JP :: 有限体係数分散表現多項式の有理数係数への変換
\BEG
:: Converts a distributed polynomial with coefficients in a finite field into
one with coefficients in the rationals.
\E
@end table

@table @var
@item return
\JP 分散表現多項式
\EG distributed polynomial
@item p
\JP 分散表現多項式
\EG distributed polynomial
@item mod
\JP 素数
\EG prime
@item subst
\JP リスト
\EG list
@end table

@itemize @bullet
\BJP
@item
@code{dp_nf_mod()}, @code{dp_true_nf_mod()} は, 入力として有限体係数の
分散表現多項式を必要とする. このような場合, @code{dp_mod()} により
有理数係数分散表現多項式を変換して用いることができる. また, 得られた
結果は, 有限体係数多項式とは演算できるが, 有理数係数多項式とは演算できない
ため, @code{dp_rat()} により変換する必要がある. 
@item
有限体係数の演算においては, あらかじめ @code{setmod()} により有限体の元の
個数を指定しておく必要がある. 
@item
@var{subst} は, 係数が有理式の場合, その有理式の変数にあらかじめ数を代入
した後有限体係数に変換するという操作を行う際の, 代入値を指定するもので, 
@code{[[@var{var},@var{value}],...]} の形のリストである. 
\E
\BEG
@item
@code{dp_nf_mod()} and @code{dp_true_nf_mod()} require
distributed polynomials with coefficients in a finite field as arguments.
@code{dp_mod()} is used to convert distributed polynomials with rational
number coefficients into appropriate ones.
Polynomials with coefficients in a finite field
cannot be used as inputs of operations with polynomials
with rational number coefficients. @code{dp_rat()} is used for such cases.
@item
The ground finite field must be set in advance by using @code{setmod()}.
@item
@var{subst} is such a list as @code{[[@var{var},@var{value}],...]}.
This is valid when the ground field of the input polynomial is a
rational function field. @var{var}'s are variables in the ground field and
the list means that @var{value} is substituted for @var{var} before
converting the coefficients into elements of a finite field.
\E
@end itemize

@example
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_nf dp_nf_mod dp_true_nf dp_true_nf_mod dp_weyl_nf dp_weyl_nf_mod},
@fref{subst psubst},
@fref{setmod}.
@end table

\JP @node dp_homo dp_dehomo,,, グレブナ基底に関する函数
\EG @node dp_homo dp_dehomo,,, Functions for Groebner basis computation
@subsection @code{dp_homo}, @code{dp_dehomo}
@findex dp_homo
@findex dp_dehomo

@table @t
@item dp_homo(@var{dpoly})
\JP :: 分散表現多項式の斉次化
\EG :: Homogenize a distributed polynomial
@item dp_dehomo(@var{dpoly})
\JP :: 斉次分散表現多項式の非斉次化
\EG :: Dehomogenize a homogeneous distributed polynomial
@end table

@table @var
@item return
\JP 分散表現多項式
\EG distributed polynomial
@item dpoly
\JP 分散表現多項式
\EG distributed polynomial
@end table

@itemize @bullet
\BJP
@item
@code{dp_homo()} は, @var{dpoly} の 各項 @var{t} について, 指数ベクトルの長さを
1 伸ばし, 最後の成分の値を @var{d}-@code{deg(@var{t})} 
(@var{d} は @var{dpoly} の全次数) とした分散表現多項式を返す. 
@item
@code{dp_dehomo()} は, @var{dpoly} の各項について, 指数ベクトルの最後の成分
を取り除いた分散多項式を返す. 
@item
いずれも, 生成された多項式を用いた演算を行う場合, それらに適合する項順序を
正しく設定する必要がある. 
@item
@code{hgr()} などにおいて, 内部的に用いられている.
\E
\BEG
@item
@code{dp_homo()} makes a copy of @var{dpoly}, extends
the length of the exponent vector of each term @var{t} in the copy by 1,
and sets the value of the newly appended
component to @var{d}-@code{deg(@var{t})}, where @var{d} is the total
degree of @var{dpoly}.
@item
@code{dp_dehomo()} make a copy of @var{dpoly} and removes the last component
of each terms in the copy.
@item
Appropriate term orderings must be set when the results are used as inputs
of some operations.
@item
These are used internally in @code{hgr()} etc.
\E
@end itemize

@example
[202] X=<<1,2,3>>+3*<<1,2,1>>;
(1)*<<1,2,3>>+(3)*<<1,2,1>>
[203] dp_homo(X);
(1)*<<1,2,3,0>>+(3)*<<1,2,1,2>>
[204] dp_dehomo(@@);
(1)*<<1,2,3>>+(3)*<<1,2,1>>
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{gr hgr gr_mod}.
@end table

\JP @node dp_ptozp dp_prim,,, グレブナ基底に関する函数
\EG @node dp_ptozp dp_prim,,, Functions for Groebner basis computation
@subsection @code{dp_ptozp}, @code{dp_prim}
@findex dp_ptozp
@findex dp_prim

@table @t
@item dp_ptozp(@var{dpoly})
\JP :: 定数倍して係数を整数係数かつ係数の整数 GCD を 1 にする. 
\BEG
:: Converts a distributed polynomial @var{poly} with rational coefficients
into an integral distributed polynomial such that GCD of all its coefficients
is 1.
\E
@item dp_prim(@var{dpoly})
\JP :: 有理式倍して係数を整数係数多項式係数かつ係数の多項式 GCD を 1 にする. 
\BEG
:: Converts a distributed polynomial @var{poly} with rational function
coefficients into an integral distributed polynomial such that polynomial 
GCD of all its coefficients is 1.
\E
@end table

@table @var
@item return
\JP 分散表現多項式
\EG distributed polynomial
@item dpoly
\JP 分散表現多項式
\EG distributed polynomial
@end table

@itemize @bullet
\BJP
@item
@code{dp_ptozp()} は,  @code{ptozp()} に相当する操作を分散表現多項式に
対して行う. 係数が多項式を含む場合, 係数に含まれる多項式共通因子は
取り除かない. 
@item
@code{dp_prim()} は, 係数が多項式を含む場合, 係数に含まれる多項式共通因子
を取り除く. 
\E
\BEG
@item
@code{dp_ptozp()} executes the same operation as @code{ptozp()} for
a distributed polynomial. If the coefficients include polynomials,
polynomial contents included in the coefficients are not removed.
@item
@code{dp_prim()} removes polynomial contents.
\E
@end itemize

@example
[208] X=dp_ptod(3*(x-y)*(y-z)*(z-x),[x]);
(-3*y+3*z)*<<2>>+(3*y^2-3*z^2)*<<1>>+(-3*z*y^2+3*z^2*y)*<<0>>
[209] dp_ptozp(X);                       
(-y+z)*<<2>>+(y^2-z^2)*<<1>>+(-z*y^2+z^2*y)*<<0>>
[210] dp_prim(X);                        
(1)*<<2>>+(-y-z)*<<1>>+(z*y)*<<0>>
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{ptozp}.
@end table

\JP @node dp_nf dp_nf_mod dp_true_nf dp_true_nf_mod dp_weyl_nf dp_weyl_nf_mod,,, グレブナ基底に関する函数
\EG @node dp_nf dp_nf_mod dp_true_nf dp_true_nf_mod dp_weyl_nf dp_weyl_nf_mod,,, Functions for Groebner basis computation
@subsection @code{dp_nf}, @code{dp_nf_mod}, @code{dp_true_nf}, @code{dp_true_nf_mod}, @code{dp_weyl_nf}, @code{dp_weyl_nf_mod}
@findex dp_nf
@findex  dp_true_nf
@findex dp_nf_mod
@findex  dp_true_nf_mod
@findex dp_weyl_nf
@findex dp_weyl_nf_mod

@table @t
@item dp_nf(@var{indexlist},@var{dpoly},@var{dpolyarray},@var{fullreduce})
@item dp_weyl_nf(@var{indexlist},@var{dpoly},@var{dpolyarray},@var{fullreduce})
@item dp_nf_mod(@var{indexlist},@var{dpoly},@var{dpolyarray},@var{fullreduce},@var{mod})
@item dp_weyl_nf_mod(@var{indexlist},@var{dpoly},@var{dpolyarray},@var{fullreduce},@var{mod})
\JP :: 分散表現多項式の正規形を求める. (結果は定数倍されている可能性あり)

\BEG
:: Computes the normal form of a distributed polynomial.
(The result may be multiplied by a constant in the ground field.)
\E
@item dp_true_nf(@var{indexlist},@var{dpoly},@var{dpolyarray},@var{fullreduce})
@item dp_true_nf_mod(@var{indexlist},@var{dpoly},@var{dpolyarray},@var{fullreduce},@var{mod})
\JP :: 分散表現多項式の正規形を求める. (真の結果を @code{[分子, 分母]} の形で返す)
\BEG
:: Computes the normal form of a distributed polynomial. (The true result
is returned in such a list as @code{[numerator, denominator]})
\E
@end table

@table @var
@item return
\JP @code{dp_nf()} : 分散表現多項式, @code{dp_true_nf()} : リスト
\EG @code{dp_nf()} : distributed polynomial, @code{dp_true_nf()} : list
@item indexlist
\JP リスト
\EG list
@item dpoly
\JP 分散表現多項式
\EG distributed polynomial
@item dpolyarray
\JP 配列
\EG array of distributed polynomial
@item fullreduce
\JP フラグ
\EG flag
@item mod
\JP 素数
\EG prime
@end table

@itemize @bullet
\BJP
@item
分散表現多項式 @var{dpoly} の正規形を求める. 
@item
名前に weyl を含む関数はワイル代数における正規形計算を行う. 以下の説明は weyl を含むものに対しても同様に成立する.
@item
@code{dp_nf_mod()}, @code{dp_true_nf_mod()} の入力は, @code{dp_mod()} など
により, 有限体上の分散表現多項式になっていなければならない. 
@item
結果に有理数, 有理式が含まれるのを避けるため, @code{dp_nf()} は
真の値の定数倍の値を返す. 有理式係数の場合の @code{dp_nf_mod()} も同様
であるが, 係数体が有限体の場合 @code{dp_nf_mod()} は真の値を返す. 
@item
@code{dp_true_nf()}, @code{dp_true_nf_mod()} は, 
@code{[@var{nm},@var{dn}]} なる形のリストを返す. 
ただし, @var{nm} は係数に分数, 有理式を含まない分散表現多項式, @var{dn} は
数または多項式で @var{nm}/@var{dn} が真の値となる. 
@item
@var{dpolyarray} は分散表現多項式を要素とするベクトル, 
@var{indexlist} は正規化計算に用いる @var{dpolyarray} の要素のインデックス
のリスト. 
@item
@var{fullreduce} が 0 でないとき全ての項に対して簡約を行う. @var{fullreduce}
が 0 のとき頭項のみに対して簡約を行う. 
@item
@var{indexlist} で指定された多項式は, 前の方のものが優先的に使われる. 
@item
一般には @var{indexlist} の与え方により函数の値は異なる可能性があるが, 
グレブナ基底に対しては一意的に定まる. 
@item
分散表現でない固定された多項式集合による正規形を多数求める必要がある場合
に便利である. 単一の演算に関しては, @code{p_nf}, @code{p_true_nf} を
用いるとよい. 
\E
\BEG
@item
Computes the normal form of a distributed polynomial.
@item
Functions whose name contain @code{weyl} compute normal forms in Weyl algebra. The description below also applies to
the functions for Weyl algebra.
@item
@code{dp_nf_mod()} and @code{dp_true_nf_mod()} require
distributed polynomials with coefficients in a finite field as arguments.
@item
The result of @code{dp_nf()} may be multiplied by a constant in the
ground field in order to make the result integral. The same is true
for @code{dp_nf_mod()}, but it returns the true normal form if
the ground field is a finite field.
@item
@code{dp_true_nf()} and @code{dp_true_nf_mod()} return
such a list as @code{[@var{nm},@var{dn}]}.
Here @var{nm} is a distributed polynomial whose coefficients are integral
in the ground field, @var{dn} is an integral element in the ground
field and @var{nm}/@var{dn} is the true normal form.
@item
@var{dpolyarray} is a vector whose components are distributed polynomials
and @var{indexlist} is a list of indices which is used for the normal form
computation.
@item
When argument @var{fullreduce} has non-zero value,
all terms are reduced. When it has value 0,
only the head term is reduced.
@item
As for the polynomials specified by @var{indexlist}, one specified by
an index placed at the preceding position has priority to be selected.
@item
In general, the result of the function may be different depending on
@var{indexlist}.  However, the result is unique for Groebner bases.
@item
These functions are useful when a fixed non-distributed polynomial set
is used as a set of reducers to compute normal forms of many polynomials.
For single computation @code{p_nf} and @code{p_true_nf} are sufficient.
\E
@end itemize

@example
[0] load("gr")$
[64] load("katsura")$
[69] K=katsura(4)$
[70] dp_ord(2)$
[71] V=[u0,u1,u2,u3,u4]$
[72] DP1=newvect(length(K),map(dp_ptod,K,V))$
[73] G=gr(K,V,2)$
[74] DP2=newvect(length(G),map(dp_ptod,G,V))$
[75] T=dp_ptod((u0-u1+u2-u3+u4)^2,V)$
[76] dp_dtop(dp_nf([0,1,2,3,4],T,DP1,1),V);
u4^2+(6*u3+2*u2+6*u1-2)*u4+9*u3^2+(6*u2+18*u1-6)*u3+u2^2
+(6*u1-2)*u2+9*u1^2-6*u1+1
[77] dp_dtop(dp_nf([4,3,2,1,0],T,DP1,1),V);
-5*u4^2+(-4*u3-4*u2-4*u1)*u4-u3^2-3*u3-u2^2+(2*u1-1)*u2-2*u1^2-3*u1+1
[78] dp_dtop(dp_nf([0,1,2,3,4],T,DP2,1),V);
-11380879768451657780886122972730785203470970010204714556333530492210
456775930005716505560062087150928400876150217079820311439477560587583
488*u4^15+...
[79] dp_dtop(dp_nf([4,3,2,1,0],T,DP2,1),V);
-11380879768451657780886122972730785203470970010204714556333530492210
456775930005716505560062087150928400876150217079820311439477560587583
488*u4^15+...
[80] @@78==@@79;
1
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_dtop},
@fref{dp_ord},
@fref{dp_mod dp_rat},
@fref{p_nf p_nf_mod p_true_nf p_true_nf_mod}.
@end table

\JP @node dpm_nf dpm_nf_and_quotient,,, グレブナ基底に関する函数
\EG @node dpm_nf dpm_nf_and_quotient,,, Functions for Groebner basis computation
@subsection @code{dpm_nf}, @code{dpm_nf_and_quotient}
@findex dpm_nf
@findex dpm_nf_and_quotient

@table @t
@item dpm_nf([@var{indexlist},]@var{dpoly},@var{dpolyarray},@var{fullreduce})
\JP :: 加群多項式の正規形を求める. (結果は定数倍されている可能性あり)

\BEG
:: Computes the normal form of a module polynomial.
(The result may be multiplied by a constant in the ground field.)
\E
@item dpm_nf_and_quotient([@var{indexlist},]@var{dpoly},@var{dpolyarray})
\JP :: 加群多項式の正規形と商を求める.
\BEG
:: Computes the normal form of a module polynomial and the quotient.
\E
@end table

@table @var
@item return
\JP @code{dpm_nf()} : 加群多項式, @code{dpm_nf_and_quotient()} : リスト
\EG @code{dpm_nf()} : module polynomial, @code{dpm_nf_and_quotient()} : list
@item indexlist
\JP リスト
\EG list
@item dpoly
\JP 加群多項式
\EG module polynomial
@item dpolyarray
\JP 配列
\EG array of module polynomial
@end table

@itemize @bullet
\BJP
@item
加群多項式 @var{dpoly} の正規形を求める. 
@item
結果に有理数, 有理式が含まれるのを避けるため, @code{dpm_nf()} は
真の値の定数倍の値を返す. 
@item
@var{dpolyarray} は加群多項式を要素とするベクトル, 
@var{indexlist} は正規化計算に用いる @var{dpolyarray} の要素のインデックス
@item
@var{indexlist} が与えられている場合, @var{dpolyarray} の中で, @var{indexlist} で指定されたもののみが, 前の方から優先的に使われる. 
@var{indexlist} が与えられていない場合には, @var{dpolyarray} の中の全ての多項式が前の方から優先的に使われる.
@item
@code{dpm_nf_and_quotient()} は, 
@code{[@var{nm},@var{dn},@var{quo}]} なる形のリストを返す. 
ただし, @var{nm} は係数に分数を含まない加群多項式, @var{dn} は
数または多項式で @var{nm}/@var{dn} が真の値となる. 
@var{quo} は除算の商を表す配列で, @var{dn}@var{dpoly}=@var{nm}+@var{quo[0]dpolyarray[0]+...} が成り立つ.
のリスト. 
@item
@var{fullreduce} が 0 でないとき全ての項に対して簡約を行う. @var{fullreduce}
が 0 のとき頭項のみに対して簡約を行う. 
\E
\BEG
@item
Computes the normal form of a module polynomial.
@item
The result of @code{dpm_nf()} may be multiplied by a constant in the
ground field in order to make the result integral.
@item
@var{dpolyarray} is a vector whose components are module polynomials
and @var{indexlist} is a list of indices which is used for the normal form
computation.
@item
If @var{indexlist} is given, only the polynomials in @var{dpolyarray} specified in @var{indexlist}
is used in the division. An index placed at the preceding position has priority to be selected.
If @var{indexlist} is not given, all the polynomials in @var{dpolyarray} are used.
@item
@code{dpm_nf_and_quotient()} returns
such a list as @code{[@var{nm},@var{dn},@var{quo}]}.
Here @var{nm} is a module polynomial whose coefficients are integral
in the ground field, @var{dn} is an integral element in the ground
field and @var{nm}/@var{dn} is the true normal form.
@var{quo} is an array containing the quotients of the division satisfying
@var{dn}@var{dpoly}=@var{nm}+@var{quo[0]dpolyarray[0]+...}.
@item
When argument @var{fullreduce} has non-zero value,
all terms are reduced. When it has value 0,
only the head term is reduced.
\E
@end itemize

@example
[2126] dp_ord([1,0])$
[2127] S=ltov([(1)*<<0,0,2,0:1>>+(1)*<<0,0,1,1:1>>+(1)*<<0,0,0,2:1>>
+(-1)*<<3,0,0,0:2>>+(-1)*<<0,0,2,1:2>>+(-1)*<<0,0,1,2:2>>
+(1)*<<3,0,1,0:3>>+(1)*<<3,0,0,1:3>>+(1)*<<0,0,2,2:3>>,
(-1)*<<0,1,0,0:1>>+(-1)*<<0,0,1,0:1>>+(-1)*<<0,0,0,1:1>>
+(-1)*<<3,0,0,0:3>>+(1)*<<0,1,1,1:3>>,(1)*<<0,1,0,0:2>>
+(1)*<<0,0,1,0:2>>+(1)*<<0,0,0,1:2>>+(-1)*<<0,1,1,0:3>>
+(-1)*<<0,1,0,1:3>>+(-1)*<<0,0,1,1:3>>])$
[2128] U=dpm_sp(S[0],S[1]);
(1)*<<0,0,3,0:1>>+(-1)*<<0,1,1,1:1>>+(1)*<<0,0,2,1:1>>
+(-1)*<<0,1,0,2:1>>+(1)*<<3,1,0,0:2>>+(1)*<<0,1,2,1:2>>
+(1)*<<0,1,1,2:2>>+(-1)*<<3,1,1,0:3>>+(1)*<<3,0,2,0:3>>
+(-1)*<<3,1,0,1:3>>+(-1)*<<0,1,3,1:3>>+(-1)*<<0,1,2,2:3>>
[2129] dpm_nf(U,S,1);
0
[2130] L=dpm_nf_and_quotient(U,S)$
[2131] Q=L[2]$
[2132] D=L[1]$
[2133] D*U-(Q[1]*S[1]+Q[2]*S[2]);
0
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dpm_sp},
@fref{dp_ord}.
@end table


\JP @node dp_hm dp_ht dp_hc dp_rest,,, グレブナ基底に関する函数
\EG @node dp_hm dp_ht dp_hc dp_rest,,, Functions for Groebner basis computation
@subsection @code{dp_hm}, @code{dp_ht}, @code{dp_hc}, @code{dp_rest}
@findex dp_hm
@findex dp_ht
@findex dp_hc
@findex dp_rest

@table @t
@item dp_hm(@var{dpoly})
\JP :: 頭単項式を取り出す. 
\EG :: Gets the head monomial.
@item dp_ht(@var{dpoly})
\JP :: 頭項を取り出す. 
\EG :: Gets the head term.
@item dp_hc(@var{dpoly})
\JP :: 頭係数を取り出す. 
\EG :: Gets the head coefficient.
@item dp_rest(@var{dpoly})
\JP :: 頭単項式を取り除いた残りを返す. 
\EG :: Gets the remainder of the polynomial where the head monomial is removed.
@end table

@table @var
\BJP
@item return
@code{dp_hm()}, @code{dp_ht()}, @code{dp_rest()} : 分散表現多項式,
@code{dp_hc()} : 数または多項式
@item dpoly
分散表現多項式
\E
\BEG
@item return
@code{dp_hm()}, @code{dp_ht()}, @code{dp_rest()} : distributed polynomial
@code{dp_hc()} : number or polynomial
@item dpoly
distributed polynomial
\E
@end table

@itemize @bullet
\BJP
@item
これらは, 分散表現多項式の各部分を取り出すための函数である. 
@item
分散表現多項式 @var{p} に対し次が成り立つ. 
\E
\BEG
@item
These are used to get various parts of a distributed polynomial.
@item
The next equations hold for a distributed polynomial @var{p}.
\E
@table @code
@item @var{p} = dp_hm(@var{p}) + dp_rest(@var{p})
@item dp_hm(@var{p}) = dp_hc(@var{p}) dp_ht(@var{p})
@end table
@end itemize

@example
[87] dp_ord(0)$
[88] X=ptozp((a46^2+7/10*a46+7/48)*u3^4-50/27*a46^2-35/27*a46-49/216)$
[89] T=dp_ptod(X,[u3,u4,a46])$                                        
[90] dp_hm(T);                                                        
(2160)*<<4,0,2>>
[91] dp_ht(T);
(1)*<<4,0,2>>
[92] dp_hc(T);
2160
[93] dp_rest(T);
(1512)*<<4,0,1>>+(315)*<<4,0,0>>+(-4000)*<<0,0,2>>+(-2800)*<<0,0,1>>
+(-490)*<<0,0,0>>
@end example

\JP @node dpm_hm dpm_ht dpm_hc dpm_hp dpm_rest,,, グレブナ基底に関する函数
\EG @node dpm_hm dpm_ht dpm_hc dpm_hp dpm_rest,,, Functions for Groebner basis computation
@subsection @code{dpm_hm}, @code{dpm_ht}, @code{dpm_hc}, @code{dpm_hp}, @code{dpm_rest}
@findex dpm_hm
@findex dpm_ht
@findex dpm_hc
@findex dpm_hp
@findex dpm_rest

@table @t
@item dpm_hm(@var{dpoly})
\JP :: 加群多項式の頭単項式を取り出す. 
\EG :: Gets the head monomial of a module polynomial.
@item dpm_ht(@var{dpoly})
\JP :: 加群多項式の頭項を取り出す. 
\EG :: Gets the head term of a module polynomial.
@item dpm_hc(@var{dpoly})
\JP :: 加群多項式の頭係数を取り出す. 
\EG :: Gets the head coefficient of a module polynomial.
@item dpm_hp(@var{dpoly})
\JP :: 加群多項式の頭位置を取り出す. 
\EG :: Gets the head position of a module polynomial.
@item dpm_rest(@var{dpoly})
\JP :: 加群多項式の頭単項式を取り除いた残りを返す. 
\EG :: Gets the remainder of a module polynomial where the head monomial is removed.
@end table

@table @var
\BJP
@item return
@code{dp_hm()}, @code{dp_ht()}, @code{dp_rest()} : 加群多項式,
@code{dp_hc()} : 数または多項式
@item dpoly
加群多項式
\E
\BEG
@item return
@code{dpm_hm()}, @code{dpm_ht()}, @code{dpm_rest()} : module polynomial
@code{dpm_hc()} : monomial
@item dpoly
distributed polynomial
\E
@end table

@itemize @bullet
\BJP
@item
これらは, 加群多項式の各部分を取り出すための函数である. 
@item
@code{dpm_hc()} は, @code{dpm_hm()} の, 標準基底に関する係数である単項式を返す.
スカラー係数を取り出すには, さらに @code{dp_hc()} を実行する.
@item
@code{dpm_hp()} は, 頭加群単項式に含まれる標準基底のインデックスを返す.
\E
\BEG
@item
These are used to get various parts of a module polynomial.
@item
@code{dpm_hc()} returns the monomial that is the coefficient of @code{dpm_hm()} with respect to the
standard base.
For getting its scalar coefficient apply @code{dp_hc()}.
@item
@code{dpm_hp()} returns the index of the standard base conteind in the head module monomial.
\E
@end itemize

@example
[2126] dp_ord([1,0]); 
[1,0]
[2127] F=2*<<1,2,0:2>>-3*<<1,0,2:3>>+<<2,1,0:2>>;
(1)*<<2,1,0:2>>+(2)*<<1,2,0:2>>+(-3)*<<1,0,2:3>>
[2128] M=dpm_hm(F);
(1)*<<2,1,0:2>>
[2129] C=dpm_hc(F);
(1)*<<2,1,0>>
[2130] R=dpm_rest(F);
(2)*<<1,2,0:2>>+(-3)*<<1,0,2:3>>
[2131] dpm_hp(F);
2
@end example


\JP @node dp_td dp_sugar,,, グレブナ基底に関する函数
\EG @node dp_td dp_sugar,,, Functions for Groebner basis computation
@subsection @code{dp_td}, @code{dp_sugar}
@findex dp_td
@findex dp_sugar

@table @t
@item dp_td(@var{dpoly})
\JP :: 頭項の全次数を返す. 
\EG :: Gets the total degree of the head term.
@item dp_sugar(@var{dpoly})
\JP :: 多項式の @code{sugar} を返す. 
\EG :: Gets the @code{sugar} of a polynomial.
@end table

@table @var
@item return
\JP 自然数
\EG non-negative integer
@item dpoly
\JP 分散表現多項式
\EG distributed polynomial
@item onoff
\JP フラグ
\EG flag
@end table

@itemize @bullet
\BJP
@item
@code{dp_td()} は, 頭項の全次数, すなわち各変数の指数の和を返す. 
@item
分散表現多項式が生成されると, @code{sugar} と呼ばれるある整数が付与
される. この値は 仮想的に斉次化して計算した場合に結果が持つ全次数の値となる. 
@item
@code{sugar} は, グレブナ基底計算における正規化対の選択のストラテジを
決定するための重要な指針となる.
\E
\BEG
@item
Function @code{dp_td()} returns the total degree of the head term,
i.e., the sum of all exponent of variables in that term.
@item
Upon creation of a distributed polynomial, an integer called @code{sugar}
is associated.  This value is
the total degree of the virtually homogenized one of the original
polynomial.
@item
The quantity @code{sugar} is an important guide to determine the
selection strategy of critical pairs in Groebner basis computation.
\E
@end itemize

@example
[74] dp_ord(0)$
[75] X=<<1,2>>+<<0,1>>$
[76] Y=<<1,2>>+<<1,0>>$
[77] Z=X-Y;
(-1)*<<1,0>>+(1)*<<0,1>>
[78] dp_sugar(T);
3
@end example

\JP @node dp_lcm,,, グレブナ基底に関する函数
\EG @node dp_lcm,,, Functions for Groebner basis computation
@subsection @code{dp_lcm}
@findex dp_lcm

@table @t
@item dp_lcm(@var{dpoly1},@var{dpoly2})
\JP :: 最小公倍項を返す. 
\EG :: Returns the least common multiple of the head terms of the given two polynomials.
@end table

@table @var
@item return
\JP 分散表現多項式
\EG distributed polynomial
@item dpoly1  dpoly2
\JP 分散表現多項式
\EG distributed polynomial
@end table

@itemize @bullet
\BJP
@item
それぞれの引数の頭項の最小公倍項を返す. 係数は 1 である. 
\E
\BEG
@item
Returns the least common multiple of the head terms of the given
two polynomials, where coefficient is always set to 1.
\E
@end itemize

@example
[100] dp_lcm(<<1,2,3,4,5>>,<<5,4,3,2,1>>);
(1)*<<5,4,3,4,5>>
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{p_nf p_nf_mod p_true_nf p_true_nf_mod}.
@end table

\JP @node dp_redble,,, グレブナ基底に関する函数
\EG @node dp_redble,,, Functions for Groebner basis computation
@subsection @code{dp_redble}
@findex dp_redble

@table @t
@item dp_redble(@var{dpoly1},@var{dpoly2})
\JP :: 頭項どうしが整除可能かどうか調べる. 
\EG :: Checks whether one head term is divisible by the other head term.
@end table

@table @var
@item return
\JP 整数
\EG integer
@item dpoly1  dpoly2
\JP 分散表現多項式
\EG distributed polynomial
@end table

@itemize @bullet
\BJP
@item
@var{dpoly1} の頭項が @var{dpoly2} の頭項で割り切れれば 1, 割り切れなければ
0 を返す. 
@item
多項式の簡約を行う際, どの項を簡約できるかを探すのに用いる. 
\E
\BEG
@item
Returns 1 if the head term of @var{dpoly2} divides the head term of
@var{dpoly1}; otherwise 0.
@item
Used for finding candidate terms at reduction of polynomials.
\E
@end itemize

@example
[148] C;
(1)*<<1,1,1,0,0>>+(1)*<<0,1,1,1,0>>+(1)*<<1,1,0,0,1>>+(1)*<<1,0,0,1,1>>
[149] T;
(3)*<<2,1,0,0,0>>+(3)*<<1,2,0,0,0>>+(1)*<<0,3,0,0,0>>+(6)*<<1,1,1,0,0>>
[150] for ( ; T; T = dp_rest(T)) print(dp_redble(T,C));
0
0
0
1
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_red dp_red_mod}.
@end table

\JP @node dpm_redble,,, グレブナ基底に関する函数
\EG @node dpm_redble,,, Functions for Groebner basis computation
@subsection @code{dpm_redble}
@findex dpm_redble

@table @t
@item dpm_redble(@var{dpoly1},@var{dpoly2})
\JP :: 頭項どうしが整除可能かどうか調べる. 
\EG :: Checks whether one head term is divisible by the other head term.
@end table

@table @var
@item return
\JP 整数
\EG integer
@item dpoly1  dpoly2
\JP 加群多項式
\EG module polynomial
@end table

@itemize @bullet
\BJP
@item
@var{dpoly1} の頭項が @var{dpoly2} の頭項で割り切れれば 1, 割り切れなければ
0 を返す. 
@item
多項式の簡約を行う際, どの項を簡約できるかを探すのに用いる. 
\E
\BEG
@item
Returns 1 if the head term of @var{dpoly2} divides the head term of
@var{dpoly1}; otherwise 0.
@item
Used for finding candidate terms at reduction of polynomials.
\E
@end itemize

\JP @node dp_subd,,, グレブナ基底に関する函数
\EG @node dp_subd,,, Functions for Groebner basis computation
@subsection @code{dp_subd}
@findex dp_subd

@table @t
@item dp_subd(@var{dpoly1},@var{dpoly2})
\JP :: 頭項の商単項式を返す. 
\EG :: Returns the quotient monomial of the head terms.
@end table

@table @var
@item return
\JP 分散表現多項式
\EG distributed polynomial
@item dpoly1  dpoly2
\JP 分散表現多項式
\EG distributed polynomial
@end table

@itemize @bullet
\BJP
@item
@code{dp_ht(@var{dpoly1})/dp_ht(@var{dpoly2})} を求める. 結果の係数は 1 
である. 
@item
割り切れることがあらかじめわかっている必要がある.
\E
\BEG
@item
Gets @code{dp_ht(@var{dpoly1})/dp_ht(@var{dpoly2})}.
The coefficient of the result is always set to 1.
@item
Divisibility assumed.
\E
@end itemize

@example
[162] dp_subd(<<1,2,3,4,5>>,<<1,1,2,3,4>>);
(1)*<<0,1,1,1,1>>
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_red dp_red_mod}.
@end table

\JP @node dp_vtoe dp_etov,,, グレブナ基底に関する函数
\EG @node dp_vtoe dp_etov,,, Functions for Groebner basis computation
@subsection @code{dp_vtoe}, @code{dp_etov}
@findex dp_vtoe
@findex dp_etov

@table @t
@item dp_vtoe(@var{vect})
\JP :: 指数ベクトルを項に変換
\EG :: Converts an exponent vector into a term.
@item dp_etov(@var{dpoly})
\JP :: 頭項を指数ベクトルに変換
\EG :: Convert the head term of a distributed polynomial into an exponent vector.
@end table

@table @var
@item return
\JP @code{dp_vtoe} : 分散表現多項式, @code{dp_etov} : ベクトル
\EG @code{dp_vtoe} : distributed polynomial, @code{dp_etov} : vector
@item vect
\JP ベクトル
\EG vector
@item dpoly
\JP 分散表現多項式
\EG distributed polynomial
@end table

@itemize @bullet
\BJP
@item
@code{dp_vtoe()} は, ベクトル @var{vect} を指数ベクトルとする項を生成する. 
@item
@code{dp_etov()} は, 分散表現多項式 @code{dpoly} の頭項の指数ベクトルを
ベクトルに変換する. 
\E
\BEG
@item
@code{dp_vtoe()} generates a term whose exponent vector is @var{vect}.
@item
@code{dp_etov()} generates a vector which is the exponent vector of the
head term of @code{dpoly}.
\E
@end itemize

@example
[211] X=<<1,2,3>>;
(1)*<<1,2,3>>
[212] V=dp_etov(X);
[ 1 2 3 ]
[213] V[2]++$
[214] Y=dp_vtoe(V);
(1)*<<1,2,4>>
@end example

\JP @node dp_mbase,,, グレブナ基底に関する函数
\EG @node dp_mbase,,, Functions for Groebner basis computation
@subsection @code{dp_mbase}
@findex dp_mbase

@table @t
@item dp_mbase(@var{dplist})
\JP :: monomial 基底の計算
\EG :: Computes the monomial basis
@end table

@table @var
@item return
\JP 分散表現多項式のリスト
\EG list of distributed polynomial
@item dplist
\JP 分散表現多項式のリスト
\EG list of distributed polynomial
@end table

@itemize @bullet
\BJP
@item
ある順序でグレブナ基底となっている多項式集合の, その順序に関する分散表現
である @var{dplist} について, 
@var{dplist} が K[X] 中で生成するイデアル I が 0 次元の時, 
K 上有限次元線形空間である K[X]/I の monomial による基底を求める. 
@item
得られた基底の個数が, K[X]/I の K-線形空間としての次元に等しい. 
\E
\BEG
@item
Assuming that @var{dplist} is a list of distributed polynomials which
is a Groebner basis with respect to the current ordering type and
that the ideal @var{I} generated by @var{dplist} in K[X] is zero-dimensional,
this function computes the monomial basis of a finite dimensional K-vector
space K[X]/I.
@item
The number of elements in the monomial basis is equal to the
K-dimenstion of K[X]/I.
\E
@end itemize

@example
[215] K=katsura(5)$
[216] V=[u5,u4,u3,u2,u1,u0]$
[217] G0=gr(K,V,0)$
[218] H=map(dp_ptod,G0,V)$
[219] map(dp_ptod,dp_mbase(H),V)$
[u0^5,u4*u0^3,u3*u0^3,u2*u0^3,u1*u0^3,u0^4,u3^2*u0,u2*u3*u0,u1*u3*u0,
u1*u2*u0,u1^2*u0,u4*u0^2,u3*u0^2,u2*u0^2,u1*u0^2,u0^3,u3^2,u2*u3,u1*u3,
u1*u2,u1^2,u4*u0,u3*u0,u2*u0,u1*u0,u0^2,u4,u3,u2,u1,u0,1]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{gr hgr gr_mod}.
@end table

\JP @node dp_mag,,, グレブナ基底に関する函数
\EG @node dp_mag,,, Functions for Groebner basis computation
@subsection @code{dp_mag}
@findex dp_mag

@table @t
@item dp_mag(@var{p})
\JP :: 係数のビット長の和を返す
\EG :: Computes the sum of bit lengths of coefficients of a distributed polynomial.
@end table

@table @var
@item return
\JP 数
\EG integer
@item p
\JP 分散表現多項式
\EG distributed polynomial
@end table

@itemize @bullet
\BJP
@item
分散表現多項式の係数に現れる有理数につき, その分母分子 (整数の場合は分子)
のビット長の総和を返す. 
@item
対象となる多項式の大きさの目安として有効である. 特に, 0 次元システムにおいては
係数膨張が問題となり, 途中生成される多項式が係数膨張を起こしているかどうか
の判定に役立つ. 
@item
@code{dp_gr_flags()} で, @code{ShowMag}, @code{Print} を on にすることにより
途中生成される多項式にたいする @code{dp_mag()} の値を見ることができる. 
\E
\BEG
@item
This function computes the sum of bit lengths of coefficients of a
distributed polynomial @var{p}. If a coefficient is non integral,
the sum of bit lengths of the numerator and the denominator is taken.
@item
This is a measure of the size of a polynomial. Especially for
zero-dimensional system coefficient swells are often serious and
the returned value is useful to detect such swells.
@item
If @code{ShowMag} and @code{Print} for @code{dp_gr_flags()} are on,
values of @code{dp_mag()} for intermediate basis elements are shown.
\E
@end itemize

@example
[221] X=dp_ptod((x+2*y)^10,[x,y])$
[222] dp_mag(X);
115
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_gr_flags dp_gr_print}.
@end table

\JP @node dp_red dp_red_mod,,, グレブナ基底に関する函数
\EG @node dp_red dp_red_mod,,, Functions for Groebner basis computation
@subsection @code{dp_red}, @code{dp_red_mod}
@findex dp_red
@findex dp_red_mod

@table @t
@item dp_red(@var{dpoly1},@var{dpoly2},@var{dpoly3})
@item dp_red_mod(@var{dpoly1},@var{dpoly2},@var{dpoly3},@var{mod})
\JP :: 一回の簡約操作
\EG :: Single reduction operation
@end table

@table @var
@item return
\JP リスト
\EG list
@item dpoly1  dpoly2  dpoly3
\JP 分散表現多項式
\EG distributed polynomial
@item vlist
\JP リスト
\EG list
@item mod
\JP 素数
\EG prime
@end table

@itemize @bullet
\BJP
@item
@var{dpoly1} + @var{dpoly2} なる分散表現多項式を @var{dpoly3} で
1 回簡約する.
@item
@code{dp_red_mod()} の入力は, 全て有限体係数に変換されている必要がある. 
@item
簡約される項は @var{dpoly2} の頭項である. 従って, @var{dpoly2} の
頭項が @var{dpoly3} の頭項で割り切れることがあらかじめわかっていなければ
ならない. 
@item
引数が整数係数の時, 簡約は, 分数が現れないよう, 整数 @var{a}, @var{b}, 
項 @var{t} により @var{a}(@var{dpoly1} + @var{dpoly2})-@var{bt} @var{dpoly3} として計算される. 
@item
結果は, @code{[@var{a dpoly1},@var{a dpoly2 - bt dpoly3}]} なるリストである.
\E
\BEG
@item
Reduces a distributed polynomial, @var{dpoly1} + @var{dpoly2},
by @var{dpoly3} for single time.
@item
An input for @code{dp_red_mod()} must be converted into a distributed
polynomial with coefficients in a finite field.
@item
This implies that
the divisibility of the head term of @var{dpoly2} by the head term of
@var{dpoly3} is assumed.
@item
When integral coefficients, computation is so carefully performed that
no rational operations appear in the reduction procedure.
It is computed for integers @var{a} and @var{b}, and a term @var{t} as:
@var{a}(@var{dpoly1} + @var{dpoly2})-@var{bt} @var{dpoly3}.
@item
The result is a list @code{[@var{a dpoly1},@var{a dpoly2 - bt dpoly3}]}.
\E
@end itemize

@example
[157] D=(3)*<<2,1,0,0,0>>+(3)*<<1,2,0,0,0>>+(1)*<<0,3,0,0,0>>;
(3)*<<2,1,0,0,0>>+(3)*<<1,2,0,0,0>>+(1)*<<0,3,0,0,0>>
[158] R=(6)*<<1,1,1,0,0>>;                                    
(6)*<<1,1,1,0,0>>
[159] C=12*<<1,1,1,0,0>>+(1)*<<0,1,1,1,0>>+(1)*<<1,1,0,0,1>>; 
(12)*<<1,1,1,0,0>>+(1)*<<0,1,1,1,0>>+(1)*<<1,1,0,0,1>>
[160] dp_red(D,R,C);                                         
[(6)*<<2,1,0,0,0>>+(6)*<<1,2,0,0,0>>+(2)*<<0,3,0,0,0>>,
(-1)*<<0,1,1,1,0>>+(-1)*<<1,1,0,0,1>>]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_mod dp_rat}.
@end table

\JP @node dp_sp dp_sp_mod,,, グレブナ基底に関する函数
\EG @node dp_sp dp_sp_mod,,, Functions for Groebner basis computation
@subsection @code{dp_sp}, @code{dp_sp_mod}
@findex dp_sp
@findex dp_sp_mod

@table @t
@item dp_sp(@var{dpoly1},@var{dpoly2})
@item dp_sp_mod(@var{dpoly1},@var{dpoly2},@var{mod})
\JP :: S-多項式の計算
\EG :: Computation of an S-polynomial
@end table

@table @var
@item return
\JP 分散表現多項式
\EG distributed polynomial
@item dpoly1  dpoly2
\JP 分散表現多項式
\EG distributed polynomial
@item mod
\JP 素数
\EG prime
@end table

@itemize @bullet
\BJP
@item
@var{dpoly1}, @var{dpoly2} の S-多項式を計算する. 
@item
@code{dp_sp_mod()} の入力は, 全て有限体係数に変換されている必要がある. 
@item
結果に有理数, 有理式が入るのを避けるため, 結果が定数倍, あるいは多項式
倍されている可能性がある. 
\E
\BEG
@item
This function computes the S-polynomial of @var{dpoly1} and @var{dpoly2}.
@item
Inputs of @code{dp_sp_mod()} must be polynomials with coefficients in a
finite field.
@item
The result may be multiplied by a constant in the ground field in order to
make the result integral.
\E
@end itemize

@example
[227] X=dp_ptod(x^2*y+x*y,[x,y]);
(1)*<<2,1>>+(1)*<<1,1>>
[228] Y=dp_ptod(x*y^2+x*y,[x,y]);
(1)*<<1,2>>+(1)*<<1,1>>
[229] dp_sp(X,Y);
(-1)*<<2,1>>+(1)*<<1,2>>
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_mod dp_rat}.
@end table

\JP @node dpm_sp,,, グレブナ基底に関する函数
\EG @node dmp_sp,,, Functions for Groebner basis computation
@subsection @code{dpm_sp}
@findex dpm_sp

@table @t
@item dpm_sp(@var{dpoly1},@var{dpoly2}[|coef=1])
\JP :: S-多項式の計算
\EG :: Computation of an S-polynomial
@end table

@table @var
@item return
\JP 加群多項式またはリスト
\EG module polynomial or list
@item dpoly1  dpoly2
\JP 加群多項式
\EG module polynomial
\JP 分散表現多項式
@end table

@itemize @bullet
\BJP
@item
@var{dpoly1}, @var{dpoly2} の S-多項式を計算する. 
@item
オプション @var{coef=1} が指定されている場合, @code{[S,t1,t2]} なるリストを返す.
ここで, @code{t1}, @code{t2} はS-多項式を作る際の係数単項式で @code{S=t1 dpoly1-t2 dpoly2}
を満たす.
\E
\BEG
@item
This function computes the S-polynomial of @var{dpoly1} and @var{dpoly2}.
@item
If an option @var{coef=1} is specified, it returns a list @code{[S,t1,t2]}, 
where @code{S} is the S-polynmial and @code{t1}, @code{t2} are monomials satisfying @code{S=t1 dpoly1-t2 dpoly2}.
\E
@end itemize

\JP @node dpm_schreyer_base,,, グレブナ基底に関する函数
\EG @node dmp_schreyer_base,,, Functions for Groebner basis computation
@subsection @code{dpm_schreyer_base}
@findex dpm_schreyer_base

@table @t
@item dpm_schreyer_base(@var{G})
\JP :: szygy 加群のグレブナー基底の計算
\EG :: Computation of a Groebner basis of the syzygy module
@end table

@table @var
@item return
\JP 加群多項式リスト
\EG list of module polynomials
@item G
\JP 加群多項式リスト
\EG list of module polynomials
@end table

@itemize @bullet
\BJP
@item
加群多項式で表された簡約グレブナー基底 @var{G} に対し, @var{syz(G)} の極小グレブナー基底を計算して返す.
@item
得られる結果は, @var{G} の先頭項から定まる Schreyer 順序に関するグレブナー基底である. 
副作用として, この Schreyer 順序が自動的に設定される.
\E
\BEG
@item
This function computes a minimal Groebner basis of @var{syz(G)} for a Groenber basis @var{G}
that is represented as a list of module polynomials.
@item
The result is a Groebner basis with respect to a Schreyer ordering determined by the leading terms of
@var{G}. As a side effect, this Schreyer ordering is autoatically set.
\E
@end itemize

\JP @node dpm_schreyer_frame,,, グレブナ基底に関する函数
\EG @node dmp_schreyer_frame,,, Functions for Groebner basis computation
@subsection @code{dpm_schreyer_frame}
@findex dpm_schreyer_frame

@table @t
@item dpm_schreyer_frame(@var{G})
\JP :: Schreyer フレームの計算
\EG :: Computation of the Schreyer frame
@end table

@table @var
@item return
\JP 加群単項式リストのリスト
\EG a list of lists of module monomials
@item G
\JP 加群多項式リスト
\EG list of module polynomials
@end table

@itemize @bullet
\BJP
@item
@var{G} の先頭項からスタートして, Schreyer フレーム, すなわち Schreyer の自由分解に現れるグレブナー基底の,
Schreyer 順序に関する先頭単項式を計算する.
@item
得られる結果は, 自由分解における @var{F}_i の標準基底の像の先頭単項式のリスト @var{M}_i のリスト
[@var{M}_m,...,@var{M}_1] である.
@item
副作用として, 各レベルにおける Schreyer 順序を設定するためのデータが作られる. このデータは
@code{dpm_set_schreyer_level} により, 各レベルの Schreyer 順序を設定する際に用いられる.
\E
\BEG
@item
This function computes the Schreyer frame starting from a Groebner basis @var{G}, that is the lists of leading monomials of Groebner bases
of syzygy modules with respect to Schreyer orderings in the Schreyer free resolution.
@item
The result is a list [@var{M}_m,...,@var{M}_1], where @var{M}_i is the list of leading monomials of
the images of standard bases of the free module @var{F}_i in the Schreyer free resolution.
@item
As a by-product, data for setting a Schreyer order in each level are created. The date are
used by @code{dpm_set_schreyer_level} for setting a Schreyer order in each level.
\E
@end itemize

\JP @node dpm_set_schreyer_level,,, グレブナ基底に関する函数
\EG @node dmp_set_schreyer_level,,, Functions for Groebner basis computation
@subsection @code{dpm_set_schreyer_level}
@findex dpm_set_schreyer_level

@table @t
@item dpm_set_schreyer_level(@var{L})
\JP :: 指定されたレベルの Schreyer ordering の設定
\EG :: Setting the Schreyer ordering of a specified level
@end table

@table @var
@item return
\JP 非負整数
\EG a non-negative integer
@item G
\JP 非負整数
\EG a non-negative integer
@end table

@itemize @bullet
\BJP
@item
@var{G} の先頭項からスタートして, Schreyer フレーム, すなわち Schreyer の自由分解に現れるグレブナー基底の,
Schreyer 順序に関する先頭単項式を計算する.
@item
得られる結果は, 自由分解における @var{F}_i の標準基底の像の先頭単項式のリスト @var{M}_i のリスト
[@var{M}_m,...,@var{M}_1] である.
@item
副作用として, 各レベルにおける Schreyer 順序を設定するためのデータが作られる. このデータは
@code{dpm_set_schreyer_level} により, 各レベルの Schreyer 順序を設定する際に用いられる.
\E
\BEG
@item
This function computes the Schreyer frame starting from a Groebner basis @var{G}, that is the lists of leading monomials of Groebner bases
of syzygy modules with respect to Schreyer orderings in the Schreyer free resolution.
@item
The result is a list [@var{M}_m,...,@var{M}_1], where @var{M}_i is the list of leading monomials of
the images of standard bases of the free module @var{F}_i in the Schreyer free resolution.
@item
As a by-product, data for setting a Schreyer order in each level are created. The date are
used by @code{dpm_set_schreyer_level} for setting a Schreyer order in each level.
\E
@end itemize

\JP @node dpm_sp_nf,,, グレブナ基底に関する函数
\EG @node dmp_sp_nf,,, Functions for Groebner basis computation
@subsection @code{dpm_sp_nf}
@findex dpm_sp_nf

@table @t
@item dpm_sp_nf(@var{C},@var{Z},@var{P},@var{Q})
\JP :: S-多項式を多項式配列で割った余りの計算
\EG :: Computation of a remainder of an S-polynomial modulo a polynomial array
@end table

@table @var
@item return
\JP 加群単項式のリスト
\EG a list of module monomials
@item C
\JP 加群多項式配列
\EG an array of module polynomials
@item Z
\JP 整数リストの配列
\EG an array of integer lists
@item P
@itemx Q
\JP 整数
\EG integers
@end table

@itemize @bullet
\BJP
@item
@iftex
@var{C[P]}, @var{C[Q]} の S-多項式を C で割った余り f が
@tex
$$ct C[P]-c't'C[Q]=g_1C[1]+\cdots+g_LC[L]+f$$
@end tex
と表されるとき
@tex
$$g'=ct e_P-c't' e_Q-(g_1 e_1+...+g_L e_L)$$
@end tex
に対し
@tex
[g',f]
@end tex
を返す.
@end iftex
@ifnottex
@var{C[P]}, @var{C[Q]} の S-多項式を C で割った余り f が
ct @var{C[P]}-c't'@var{C[Q]}=g_1@var{C[1]}+...+g_L@var{C[L]}+f
と表されるとき
g'=ct e_P-c't' e_Q-(g_1 e_1+...+g_L e_L)
に対し
[g',f]
を返す.
@end ifnottex
@item
配列 @var{Z} の第 I 成分は, 先頭項の位置が @var{I} であるような @var{C} の元の配列インデックスのリストである.
\E
\BEG
@item
@iftex
When the remainder of the S-polynomial of @var{C[P]} and @var{C[Q]} modulo @var{C}
is represented as 
@tex
$$ct C[P]-c't'C[Q]=g_1C[1]+\cdots+g_LC[L]+f$$
@end tex
this function returns a list 
@tex
[g',f],
@end tex
where 
@tex
$$g'=ct e_P-c't' e_Q-(g_1 e_1+...+g_L e_L).$$
@end tex
@end iftex
@ifnottex
When the remainder of the S-polynomial of @var{C[P]} and @var{C[Q]} modulo @var{C}
is represented as 
ct @var{C[P]}-c't'@var{C[Q]}=g_1@var{C[1]}+...+g_L@var{C[L]}+f,
this function returns a list [g',f], where 
g'=ct eP-c't' eQ-(g_1 e1+...+gL e_L).
@end ifnottex
@item
The @var{I}-th element of an array @var{Z} is a list of indices of elements of @var{C}
whose leading position is @var{I}.
\E
@end itemize



\JP @node p_nf p_nf_mod p_true_nf p_true_nf_mod,,, グレブナ基底に関する函数
\EG @node p_nf p_nf_mod p_true_nf p_true_nf_mod,,, Functions for Groebner basis computation
@subsection @code{p_nf}, @code{p_nf_mod}, @code{p_true_nf}, @code{p_true_nf_mod}
@findex p_nf
@findex p_nf_mod
@findex p_true_nf
@findex p_true_nf_mod

@table @t
@item p_nf(@var{poly},@var{plist},@var{vlist},@var{order})
@itemx p_nf_mod(@var{poly},@var{plist},@var{vlist},@var{order},@var{mod})
\JP :: 表現多項式の正規形を求める. (結果は定数倍されている可能性あり)
\BEG
:: Computes the normal form of the given polynomial. 
(The result may be multiplied by a constant.)
\E
@item p_true_nf(@var{poly},@var{plist},@var{vlist},@var{order})
@itemx p_true_nf_mod(@var{poly},@var{plist},@var{vlist},@var{order},@var{mod})
\JP :: 表現多項式の正規形を求める. (真の結果を @code{[分子, 分母]} の形で返す)
\BEG
:: Computes the normal form of the given polynomial. (The result is returned
as a form of @code{[numerator, denominator]})
\E
@end table

@table @var
@item return
\JP @code{p_nf} : 多項式, @code{p_true_nf} : リスト
\EG @code{p_nf} : polynomial, @code{p_true_nf} : list
@item poly
\JP 多項式
\EG polynomial
@item plist vlist
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@item mod
\JP 素数
\EG prime
@end table

@itemize @bullet
\BJP
@item
@samp{gr} で定義されている. 
@item
多項式の, 多項式リストによる正規形を求める. 
@item
@code{dp_nf()}, @code{dp_true_nf()}, @code{dp_nf_mod()}, @code{dp_true_nf_mod}
に対するインタフェースである. 
@item
@var{poly} および @var{plist} は, 変数順序 @var{vlist} および
変数順序型 @var{otype} に従って分散表現多項式に変換され, 
@code{dp_nf()}, @code{dp_true_nf()}, @code{dp_nf_mod()},
@code{dp_true_nf_mod()} に渡される. 
@item
@code{dp_nf()}, @code{dp_true_nf()}, @code{dp_nf_mod()},
@code{dp_true_nf_mod()} は @var{fullreduce} が 1 で呼び出される. 
@item
結果は多項式に変換されて出力される. 
@item
@code{p_true_nf()}, @code{p_true_nf_mod()} の出力に関しては,
@code{dp_true_nf()}, @code{dp_true_nf_mod()} の項を参照. 
\E
\BEG
@item
Defined in the package @samp{gr}.
@item
Obtains the normal form of a polynomial by a polynomial list.
@item
These are interfaces to @code{dp_nf()}, @code{dp_true_nf()}, @code{dp_nf_mod()},
 @code{dp_true_nf_mod}
@item
The polynomial @var{poly} and the polynomials in @var{plist} is
converted, according to the variable ordering @var{vlist} and
type of term ordering @var{otype}, into their distributed polynomial
counterparts and passed to @code{dp_nf()}.
@item
@code{dp_nf()}, @code{dp_true_nf()}, @code{dp_nf_mod()} and
@code{dp_true_nf_mod()}
is called with value 1 for @var{fullreduce}.
@item
The result is converted back into an ordinary polynomial.
@item
As for @code{p_true_nf()}, @code{p_true_nf_mod()}
refer to @code{dp_true_nf()} and @code{dp_true_nf_mod()}.
\E
@end itemize

@example
[79] K = katsura(5)$
[80] V = [u5,u4,u3,u2,u1,u0]$
[81] G = hgr(K,V,2)$
[82] p_nf(K[1],G,V,2);
0
[83] L = p_true_nf(K[1]+1,G,V,2);
[-1503...,-1503...]
[84] L[0]/L[1];
1
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_ptod},
@fref{dp_dtop},
@fref{dp_ord},
@fref{dp_nf dp_nf_mod dp_true_nf dp_true_nf_mod dp_weyl_nf dp_weyl_nf_mod}.
@end table

\JP @node p_terms,,, グレブナ基底に関する函数
\EG @node p_terms,,, Functions for Groebner basis computation
@subsection @code{p_terms}
@findex p_terms

@table @t
@item p_terms(@var{poly},@var{vlist},@var{order})
\JP :: 多項式にあらわれる単項をリストにする. 
\EG :: Monomials appearing in the given polynomial is collected into a list.
@end table

@table @var
@item return
\JP リスト
\EG list
@item poly
\JP 多項式
\EG polynomial
@item vlist
\JP リスト
\EG list
@item order
\JP 数, リストまたは行列
\EG number, list or matrix
@end table

@itemize @bullet
\BJP
@item
@samp{gr} で定義されている. 
@item
多項式を単項に展開した時に現れる項をリストにして返す.
@var{vlist} および @var{order} により定まる項順序により, 順序の高いもの
がリストの先頭に来るようにソートされる. 
@item
グレブナ基底はしばしば係数が巨大になるため, 実際にどの項が現れて
いるのかを見るためなどに用いる. 
\E
\BEG
@item
Defined in the package @samp{gr}.
@item
This returns a list which contains all non-zero monomials in the given
polynomial.  The monomials are ordered according to the current
type of term ordering and @var{vlist}.
@item
Since polynomials in a Groebner base often have very large coefficients,
examining a polynomial as it is may sometimes be difficult to perform.
For such a case, this function enables to examine which term is really
exists.
\E
@end itemize

@example
[233] G=gr(katsura(5),[u5,u4,u3,u2,u1,u0],2)$
[234] p_terms(G[0],[u5,u4,u3,u2,u1,u0],2);
[u5,u0^31,u0^30,u0^29,u0^28,u0^27,u0^26,u0^25,u0^24,u0^23,u0^22,
u0^21,u0^20,u0^19,u0^18,u0^17,u0^16,u0^15,u0^14,u0^13,u0^12,u0^11,
u0^10,u0^9,u0^8,u0^7,u0^6,u0^5,u0^4,u0^3,u0^2,u0,1]
@end example

\JP @node gb_comp,,, グレブナ基底に関する函数
\EG @node gb_comp,,, Functions for Groebner basis computation
@subsection @code{gb_comp}
@findex gb_comp

@table @t
@item gb_comp(@var{plist1}, @var{plist2})
\JP :: 多項式リストが, 符号を除いて集合として等しいかどうか調べる. 
\EG :: Checks whether two polynomial lists are equal or not as a set
@end table

@table @var
\JP @item return 0 または 1
\EG @item return 0 or 1
@item plist1  plist2
@end table

@itemize @bullet
\BJP
@item
@var{plist1}, @var{plist2} について, 符号を除いて集合として等しいかどうか
調べる. 
@item
異なる方法で求めたグレブナ基底は, 基底の順序, 符号が異なる場合があり, 
それらが等しいかどうかを調べるために用いる. 
\E
\BEG
@item
This function checks whether @var{plist1} and @var{plist2} are equal or
not as a set .
@item
For the same input and the same term ordering different
functions for Groebner basis computations may produce different outputs
as lists. This function compares such lists whether they are equal
as a generating set of an ideal.
\E
@end itemize

@example
[243] C=cyclic(6)$
[244] V=[c0,c1,c2,c3,c4,c5]$
[245] G0=gr(C,V,0)$
[246] G=tolex(G0,V,0,V)$
[247] GG=lex_tl(C,V,0,V,0)$
[248] gb_comp(G,GG);
1
@end example

\JP @node katsura hkatsura cyclic hcyclic,,, グレブナ基底に関する函数
\EG @node katsura hkatsura cyclic hcyclic,,, Functions for Groebner basis computation
@subsection @code{katsura}, @code{hkatsura}, @code{cyclic}, @code{hcyclic}
@findex katsura
@findex hkatsura
@findex cyclic
@findex hcyclic

@table @t
@item katsura(@var{n})
@item hkatsura(@var{n})
@item cyclic(@var{n})
@item hcyclic(@var{n})
\JP :: 多項式リストの生成
\EG :: Generates a polynomial list of standard benchmark.
@end table

@table @var
@item return
\JP リスト
\EG list
@item n
\JP 整数
\EG integer
@end table

@itemize @bullet
\BJP
@item
@code{katsura()} は @samp{katsura}, @code{cyclic()} は @samp{cyclic}
で定義されている. 
@item
グレブナ基底計算でしばしばテスト, ベンチマークに用いられる @code{katsura}, 
@code{cyclic} およびその斉次化を生成する. 
@item
@code{cyclic} は @code{Arnborg}, @code{Lazard}, @code{Davenport} などの
名で呼ばれることもある. 
\E
\BEG
@item
Function @code{katsura()} is defined in @samp{katsura}, and
function @code{cyclic()} in  @samp{cyclic}.
@item
These functions generate a series of polynomial sets, respectively,
which are often used for testing and bench marking:
@code{katsura}, @code{cyclic} and their homogenized versions.
@item
Polynomial set @code{cyclic} is sometimes called by other name:
@code{Arnborg}, @code{Lazard}, and @code{Davenport}.
\E
@end itemize

@example
[74] load("katsura")$
[79] load("cyclic")$ 
[89] katsura(5);
[u0+2*u4+2*u3+2*u2+2*u1+2*u5-1,2*u4*u0-u4+2*u1*u3+u2^2+2*u5*u1,
2*u3*u0+2*u1*u4-u3+(2*u1+2*u5)*u2,2*u2*u0+2*u2*u4+(2*u1+2*u5)*u3
-u2+u1^2,2*u1*u0+(2*u3+2*u5)*u4+2*u2*u3+2*u1*u2-u1,
u0^2-u0+2*u4^2+2*u3^2+2*u2^2+2*u1^2+2*u5^2]
[90] hkatsura(5);
[-t+u0+2*u4+2*u3+2*u2+2*u1+2*u5,
-u4*t+2*u4*u0+2*u1*u3+u2^2+2*u5*u1,-u3*t+2*u3*u0+2*u1*u4+(2*u1+2*u5)*u2,
-u2*t+2*u2*u0+2*u2*u4+(2*u1+2*u5)*u3+u1^2,
-u1*t+2*u1*u0+(2*u3+2*u5)*u4+2*u2*u3+2*u1*u2,
-u0*t+u0^2+2*u4^2+2*u3^2+2*u2^2+2*u1^2+2*u5^2]
[91] cyclic(6);
[c5*c4*c3*c2*c1*c0-1,
((((c4+c5)*c3+c5*c4)*c2+c5*c4*c3)*c1+c5*c4*c3*c2)*c0+c5*c4*c3*c2*c1,
(((c3+c5)*c2+c5*c4)*c1+c5*c4*c3)*c0+c4*c3*c2*c1+c5*c4*c3*c2,
((c2+c5)*c1+c5*c4)*c0+c3*c2*c1+c4*c3*c2+c5*c4*c3,
(c1+c5)*c0+c2*c1+c3*c2+c4*c3+c5*c4,c0+c1+c2+c3+c4+c5]
[92] hcyclic(6);
[-c^6+c5*c4*c3*c2*c1*c0,
((((c4+c5)*c3+c5*c4)*c2+c5*c4*c3)*c1+c5*c4*c3*c2)*c0+c5*c4*c3*c2*c1,
(((c3+c5)*c2+c5*c4)*c1+c5*c4*c3)*c0+c4*c3*c2*c1+c5*c4*c3*c2,
((c2+c5)*c1+c5*c4)*c0+c3*c2*c1+c4*c3*c2+c5*c4*c3,
(c1+c5)*c0+c2*c1+c3*c2+c4*c3+c5*c4,c0+c1+c2+c3+c4+c5]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{dp_dtop}.
@end table

\JP @node primadec primedec,,, グレブナ基底に関する函数
\EG @node primadec primedec,,, Functions for Groebner basis computation
@subsection @code{primadec}, @code{primedec}
@findex primadec
@findex primedec

@table @t
@item primadec(@var{plist},@var{vlist})
@item primedec(@var{plist},@var{vlist})
\JP :: イデアルの分解
\EG :: Computes decompositions of ideals.
@end table

@table @var
@item return
@itemx plist
\JP 多項式リスト
\EG list of polynomials
@item vlist
\JP 変数リスト
\EG list of variables
@end table

@itemize @bullet
\BJP
@item
ここで解説されているイデアル分解については, 新しいパッケージ @samp{noro_pd.rr} 
においてより高速な実装が利用できる.
@item
@code{primadec()}, @code{primedec} は @samp{primdec} で定義されている.
@item
@code{primadec()}, @code{primedec()} はそれぞれ有理数体上でのイデアルの
準素分解, 根基の素イデアル分解を行う.
@item
引数は多項式リストおよび変数リストである. 多項式は有理数係数のみが許される. 
@item
@code{primadec} は @code{[準素成分, 付属素イデアル]} のリストを返す. 
@item
@code{primadec} は 素因子のリストを返す. 
@item
結果において, 多項式リストとして表示されている各イデアルは全て
グレブナ基底である. 対応する項順序は, それぞれ 
変数 @code{PRIMAORD}, @code{PRIMEORD} に格納されている. 
@item
@code{primadec} は @code{[Shimoyama,Yokoyama]} の準素分解アルゴリズム
を実装している. 
@item
もし素因子のみを求めたいなら, @code{primedec} を使う方がよい. 
これは, 入力イデアルが根基イデアルでない場合に, @code{primadec}
の計算に余分なコストが必要となる場合があるからである. 
\E
\BEG
@item
A new package @samp{noro_pd.rr} provides more efficient functions for ideal decomposition.
@item
Function @code{primadec()} and @code{primedec} are defined in @samp{primdec}.
@item
@code{primadec()}, @code{primedec()} are the function for primary
ideal decomposition and prime decomposition of the radical over the
rationals respectively.
@item
The arguments are a list of polynomials and a list of variables.
These functions accept ideals with rational function coefficients only.
@item
@code{primadec} returns the list of pair lists consisting a primary component
and its associated prime.
@item
@code{primedec} returns the list of prime components.
@item
Each component is a Groebner basis and the corresponding term order
is indicated by the global variables @code{PRIMAORD}, @code{PRIMEORD}
respectively.
@item
@code{primadec} implements the primary decomposition algorithm 
in @code{[Shimoyama,Yokoyama]}.
@item
If one only wants to know the prime components of an ideal, then
use @code{primedec} because @code{primadec} may need additional costs
if an input ideal is not radical.
\E
@end itemize

@example
[84] load("primdec")$
[102] primedec([p*q*x-q^2*y^2+q^2*y,-p^2*x^2+p^2*x+p*q*y,
(q^3*y^4-2*q^3*y^3+q^3*y^2)*x-q^3*y^4+q^3*y^3,
-q^3*y^4+2*q^3*y^3+(-q^3+p*q^2)*y^2],[p,q,x,y]);
[[y,x],[y,p],[x,q],[q,p],[x-1,q],[y-1,p],[(y-1)*x-y,q*y^2-2*q*y-p+q]]
[103] primadec([x,z*y,w*y^2,w^2*y-z^3,y^3],[x,y,z,w]);
[[[x,z*y,y^2,w^2*y-z^3],[z,y,x]],[[w,x,z*y,z^3,y^3],[w,z,y,x]]]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{fctr sqfr},
\JP @fref{項順序の設定}.
\EG @fref{Setting term orderings}.
@end table

\JP @node primedec_mod,,, グレブナ基底に関する函数
\EG @node primedec_mod,,, Functions for Groebner basis computation
@subsection @code{primedec_mod}
@findex primedec_mod

@table @t
@item primedec_mod(@var{plist},@var{vlist},@var{ord},@var{mod},@var{strategy})
\JP :: イデアルの分解
\EG :: Computes decompositions of ideals over small finite fields.
@end table

@table @var
@item return
@itemx plist
\JP 多項式リスト
\EG list of polynomials
@item vlist
\JP 変数リスト
\EG list of variables
@item ord
\JP 数, リストまたは行列
\EG number, list or matrix
@item mod
\JP 正整数
\EG positive integer
@item strategy
\JP 整数
\EG integer
@end table

@itemize @bullet
\BJP
@item
@code{primedec_mod()} は @samp{primdec_mod}
で定義されている. @code{[Yokoyama]} の素イデアル分解アルゴリズム
を実装している. 
@item
@code{primedec_mod()} は有限体上でのイデアルの
根基の素イデアル分解を行い, 素イデアルのリストを返す. 
@item
@code{primedec_mod()} は, GF(@var{mod}) 上での分解を与える. 
結果の各成分の生成元は, 整数係数多項式である. 
@item
結果において, 多項式リストとして表示されている各イデアルは全て
[@var{vlist},@var{ord}] で指定される項順序に関するグレブナ基底である.
@item
@var{strategy} が 0 でないとき, incremental に component の共通
部分を計算することによる early termination を行う. 一般に, 
イデアルの次元が高い場合に有効だが, 0 次元の場合など, 次元が小さい
場合には overhead が大きい場合がある. 
@item
計算途中で内部情報を見たい場合には、
前もって @code{dp_gr_print(2)} を実行しておけばよい.
\E
\BEG
@item
Function @code{primedec_mod()}
is defined in @samp{primdec_mod} and implements the prime decomposition
algorithm in @code{[Yokoyama]}.
@item
@code{primedec_mod()}
is the function for prime ideal decomposition 
of the radical of a polynomial ideal over small finite field,
and they return a list of prime ideals, which are associated primes
of the input ideal.
@item
@code{primedec_mod()} gives the decomposition over GF(@var{mod}).
The generators of each resulting component consists of integral polynomials.
@item
Each resulting component is a Groebner basis with respect to
a term order specified by [@var{vlist},@var{ord}].
@item
If @var{strategy} is non zero, then the early termination strategy
is tried by computing the intersection of obtained components
incrementally. In general, this strategy is useful when the krull
dimension of the ideal is high, but it may add some overhead
if the dimension is small.
@item
If you want to see internal information during the computation,
execute @code{dp_gr_print(2)} in advance.
\E
@end itemize

@example
[0] load("primdec_mod")$
[246] PP444=[x^8+x^2+t,y^8+y^2+t,z^8+z^2+t]$
[247] primedec_mod(PP444,[x,y,z,t],0,2,1);
[[y+z,x+z,z^8+z^2+t],[x+y,y^2+y+z^2+z+1,z^8+z^2+t],
[y+z+1,x+z+1,z^8+z^2+t],[x+z,y^2+y+z^2+z+1,z^8+z^2+t],
[y+z,x^2+x+z^2+z+1,z^8+z^2+t],[y+z+1,x^2+x+z^2+z+1,z^8+z^2+t],
[x+z+1,y^2+y+z^2+z+1,z^8+z^2+t],[y+z+1,x+z,z^8+z^2+t],
[x+y+1,y^2+y+z^2+z+1,z^8+z^2+t],[y+z,x+z+1,z^8+z^2+t]]
[248] 
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{modfctr},
@fref{dp_gr_main dp_gr_mod_main dp_gr_f_main dp_weyl_gr_main dp_weyl_gr_mod_main dp_weyl_gr_f_main},
\JP @fref{項順序の設定}.
\EG @fref{Setting term orderings},
@fref{dp_gr_flags dp_gr_print}.
@end table

\JP @node bfunction bfct generic_bfct ann ann0,,, グレブナ基底に関する函数
\EG @node bfunction bfct generic_bfct ann ann0,,, Functions for Groebner basis computation
@subsection @code{bfunction}, @code{bfct}, @code{generic_bfct}, @code{ann}, @code{ann0}
@findex bfunction
@findex bfct
@findex generic_bfct
@findex ann
@findex ann0

@table @t
@item bfunction(@var{f})
@itemx bfct(@var{f})
@itemx generic_bfct(@var{plist},@var{vlist},@var{dvlist},@var{weight})
\JP :: @var{b} 関数の計算
\EG :: Computes the global @var{b} function of a polynomial or an ideal
@item ann(@var{f})
@itemx ann0(@var{f})
\JP :: 多項式のベキの annihilator の計算
\EG :: Computes the annihilator of a power of polynomial
@end table

@table @var
@item return
\JP 多項式またはリスト
\EG polynomial or list
@item f
\JP 多項式
\EG polynomial
@item plist
\JP 多項式リスト
\EG list of polynomials
@item vlist dvlist
\JP 変数リスト
\EG list of variables
@end table

@itemize @bullet
\BJP
@item @samp{bfct} で定義されている. 
@item @code{bfunction(@var{f})}, @code{bfct(@var{f})} は多項式 @var{f} の global @var{b} 関数 @code{b(s)} を
計算する. @code{b(s)} は, Weyl 代数 @code{D} 上の一変数多項式環 @code{D[s]}
の元 @code{P(x,s)} が存在して, @code{P(x,s)f^(s+1)=b(s)f^s} を満たすような
多項式 @code{b(s)} の中で, 次数が最も低いものである. 
@item @code{generic_bfct(@var{f},@var{vlist},@var{dvlist},@var{weight})}
は, @var{plist} で生成される @code{D} の左イデアル @code{I} の, 
ウェイト @var{weight} に関する global @var{b} 関数を計算する. 
@var{vlist} は @code{x}-変数, @var{vlist} は対応する @code{D}-変数
を順に並べる. 
@item @code{bfunction} と @code{bfct} では用いているアルゴリズムが
異なる. どちらが高速かは入力による.
@item @code{ann(@var{f})} は, @code{@var{f}^s} の annihilator ideal
の生成系を返す. @code{ann(@var{f})} は, @code{[@var{a},@var{list}]}
なるリストを返す. ここで, @var{a} は @var{f} の @var{b} 関数の最小整数根,
@var{list} は @code{ann(@var{f})} の結果の @code{s}$ に, @var{a} を
代入したものである.
@item 詳細については, [Saito,Sturmfels,Takayama] を見よ. 
\E
\BEG
@item These functions are defined in @samp{bfct}.
@item @code{bfunction(@var{f})} and @code{bfct(@var{f})} compute the global @var{b}-function @code{b(s)} of
a polynomial @var{f}.
@code{b(s)} is a polynomial of the minimal degree 
such that there exists @code{P(x,s)} in D[s], which is a polynomial
ring over Weyl algebra @code{D}, and @code{P(x,s)f^(s+1)=b(s)f^s} holds.
@item @code{generic_bfct(@var{f},@var{vlist},@var{dvlist},@var{weight})}
computes the global @var{b}-function of a left ideal @code{I} in @code{D}
generated by @var{plist}, with respect to @var{weight}.
@var{vlist} is the list of @code{x}-variables, 
@var{vlist} is the list of corresponding @code{D}-variables.
@item @code{bfunction(@var{f})} and @code{bfct(@var{f})} implement
different algorithms and the efficiency depends on inputs.
@item @code{ann(@var{f})} returns the generator set of the annihilator
ideal of @code{@var{f}^s}.
@code{ann(@var{f})} returns a list @code{[@var{a},@var{list}]},
where @var{a} is the minimal integral root of the global @var{b}-function
of @var{f}, and @var{list} is a list of polynomials obtained by
substituting @code{s} in @code{ann(@var{f})} with @var{a}.
@item See [Saito,Sturmfels,Takayama] for the details.
\E
@end itemize

@example
[0] load("bfct")$
[216] bfunction(x^3+y^3+z^3+x^2*y^2*z^2+x*y*z);
-9*s^5-63*s^4-173*s^3-233*s^2-154*s-40
[217] fctr(@@);
[[-1,1],[s+2,1],[3*s+4,1],[3*s+5,1],[s+1,2]]
[218] F = [4*x^3*dt+y*z*dt+dx,x*z*dt+4*y^3*dt+dy,
x*y*dt+5*z^4*dt+dz,-x^4-z*y*x-y^4-z^5+t]$
[219] generic_bfct(F,[t,z,y,x],[dt,dz,dy,dx],[1,0,0,0]);
20000*s^10-70000*s^9+101750*s^8-79375*s^7+35768*s^6-9277*s^5
+1278*s^4-72*s^3
[220] P=x^3-y^2$
[221] ann(P);
[2*dy*x+3*dx*y^2,-3*dx*x-2*dy*y+6*s]
[222] ann0(P);
[-1,[2*dy*x+3*dx*y^2,-3*dx*x-2*dy*y-6]]
@end example

@table @t
\JP @item 参照
\EG @item References
\JP @fref{Weyl 代数}.
\EG @fref{Weyl algebra}.
@end table

