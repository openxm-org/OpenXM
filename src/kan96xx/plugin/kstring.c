#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>
#include "kstring.h"
#include "../Kan/datatype.h"
#include "../Kan/stackm.h"
#include "../Kan/kclass.h"
#include "../Kan/extern.h"

/*
   For sm1 command
   [(string) (remove) input_str target_reg_expression] result 
*/
/* generated by gemini, 2026-02-01, see also misc-2025/A2/barcode-web/Ref
*/

/*
 * Function to return a new string with matches of the regex pattern removed.
 *
 * Arguments:
 * input:   The original input string.
 * pattern: The regular expression pattern (e.g., "[0-9]+", "<[^>]+>").
 *
 * Return value:
 * Pointer to the new string (must be freed after use).
 * Returns NULL on error.
 */
static char* remove_regex_match(const char* input, const char* pattern) {
    regex_t regex;
    int reti;
    
    // 1. Compile the regular expression
    // REG_EXTENDED: Use extended regular expressions (supports modern syntax)
    reti = regcomp(&regex, pattern, REG_EXTENDED);
    if (reti) {
        fprintf(stderr, "Regex compilation failed\n");
        return NULL;
    }

    int input_len = strlen(input);
    
    // Allocate memory for the result
    // (At most, it will be the original length + 1)
    char* result = (char*)sGC_malloc(input_len + 1);
    if (result == NULL) {
        regfree(&regex);
        return NULL;
    }

    const char* cursor = input; // Current reading position
    char* p_res = result;       // Current writing position
    regmatch_t pmatch[1];       // Structure to hold match information

    // 2. Scan the string to find matches
    while (1) {
        // Execute regex search starting from the cursor
        reti = regexec(&regex, cursor, 1, pmatch, 0);

        if (reti == 0) {
            // Match found (reti == 0)
            
            // Copy the part *before* the match to the result
            // pmatch[0].rm_so is the offset of the match start
            int len_before_match = pmatch[0].rm_so;
            memcpy(p_res, cursor, len_before_match);
            
            p_res += len_before_match; // Advance write pointer
            
            // Advance cursor to *after* the match
            // pmatch[0].rm_eo is the offset of the match end
            cursor += pmatch[0].rm_eo;
            
            // Prevent infinite loops if matching an empty string
            if (pmatch[0].rm_so == pmatch[0].rm_eo) {
                if (*cursor == '\0') break; 
                *p_res++ = *cursor++;
            }

        } else if (reti == REG_NOMATCH) {
            // No more matches found
            // Copy the remaining string
            strcpy(p_res, cursor);
            break;
        } else {
            // Handle other errors
            char msgbuf[100];
            regerror(reti, &regex, msgbuf, sizeof(msgbuf));
            fprintf(stderr, "Regex match failed: %s\n", msgbuf);
            free(result);
            regfree(&regex);
            return NULL;
        }
    }

    // 3. Free memory allocated for regex
    regfree(&regex);

    return result;
}


struct object Kstring_remove(struct object oInput,struct object oKey) {
  char *input;
  char *key;
  char *result;
  struct object rob;
  if ((oInput.tag != Sdollar) || (oKey.tag != Sdollar)) {
    errorKan1("%s\n","Arguments of Kstring_remove should be Sdollar (string)");
  }
  input = KopString(oInput);
  key = KopString(oKey);
  result = remove_regex_match(input,key);
  rob = KpoString(result);
  return rob;
}
