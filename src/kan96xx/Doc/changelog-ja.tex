% $OpenXM: OpenXM/src/kan96xx/Doc/changelog-ja.tex,v 1.16 2005/07/18 10:55:15 takayama Exp $
\documentclass{jarticle}
\title{ChangeLog \\ ---kan96xx, kxx, k097}
\author{Nobuki Takayama}
\date{}
\begin{document}
\maketitle


%%OpenXM/doc/Papers/rims-2003-12* に oxshell, polymake

\section{2004-02, port 化}

\begin{enumerate}
\item gmp はネットワークからダウンロードしてインストールするようにする.
{\tt OpenXM\_contrib} はつかわない.
\item {\tt OpenXM/src/gmp/Makefile-ports} 1.1--1.5,
%%Mail/openxm-cvs.inbox 141
\end{enumerate}

\section{2004-02,  memory leak}
\begin{enumerate}
\item {\tt misc-2003/A2/bs-poly/bs2-leak.sm1} 実行時にクライアント構造体
が壊れる.  gmp 4.x によるメモリリークを疑うも, {\tt GC\_malloc} を使うべきところで
{\tt malloc} を用いていたのでメモリが破壊されていたと判明.
{\tt malloc} の中にポインタを入れてはいけない.
\item {\tt OpenXM/src/kan96xx} 以下の各ファイル.
{\tt Kan/kanExport1.c} 1.11,
{\tt Kan/poly3.c} 1.7,
{\tt Kan/shell.c} 1.11,
{\tt plugin/file2.c} 1.9 (原因),
{\tt plugin/oxKan0.h} 1.16,
{\tt plugin/sm1Socket.c} 1.16 (原因).
{\tt OpenXM/src/kxx/oxmain.c} 1.15.
%%Mail/openxm-cvs.inbox 164 2004-2-23
\end{enumerate}

\section{2004-02, 03, ox\_texmacs}
\begin{enumerate}
\item sm1 を基礎として ox\_texmacs を作る.  {\tt -q} option で余計な
メッセージを標準出力へ出さないようにする.  次のファイルを変更.
%%Mail/openxm-cvs.inbox 203, 204, 210, 213, 215, 220, 221, 222
\item {\tt OpenXM/src/util/ox\_pathfinder.c} 1.18--1.19,
{\tt OpenXM/src/util/ox\_pathfinder.h} 1.11,
{\tt OpenXM/src/kxx/ox100start.c} 1.6,
{\tt OpenXM/src/kan96xx/Doc/ox.sm1} 1.34--1.35,
{\tt OpenXM/src/kan96xx/Kan/ext.c} 1.23,
{\tt OpenXM/src/kan96xx/Kan/kanExport0.c} 1.21,
{\tt OpenXM/src/kan96xx/plugin/mytcpio.c} 1.14.
\item {\tt ox\_texmacs}. 
 {\tt OpenXM/src/kxx} 以下の次のファイルを変更.
\item {\tt ox\_texmacs.c} 1.1--1.17,
{\tt sample\_kanlib.c} 1.1,
\item {\tt init-openxm.scm} の作成 (小原).
\end{enumerate}

\section{2004-03, ox 機能の強化}
\begin{enumerate}
\item option つきの関数よびだし.
%%Mail/openxm-cvs.inbox 286, 288  まだ書いてない
\end{enumerate}

\section{2004-07, dhecart (2重同時化による gb)}
\begin{enumerate}
\item h[0,1](D) でのグレブナ fan の計算のための準備.
\item Doc/dhecart.sm1,  dh.gb 
%%Mail/openxm-cvs.inbox ??
\end{enumerate}

\section{2004-08-22, lcm, polylcm, gcd, polygcd, その他}
\begin{enumerate}
\item polylcm, polygcd は ox を用いる.
\item mpzext (lcm, gcd).  int32 は universalNumber (mpz\_int) へ自動変換.
\item ox.sm1 は起動の時から load すべきだがまだやってない.
%%Mail/openxm-cvs.inbox ??
\item \verb@[(exponents) ...] gbext @ で exponents を取り出せる. 始めの版は 8 月頃.
\item {\tt exponents} のformat を変えた. (9/5. cf.gfan.sm1, cone.sm1) \\
{\tt OpenXM/src/kan96xx/Kan/kanExport1.c} 1.16.
\end{enumerate}

\section{2004-08-31, weight ベクトルで univNum を受け取る}
\begin{enumerate}
\item {\tt to\_int32}, {\tt Kto\_int32} で univNum を int32 へ.
\item {\tt to\_int} は {\tt to\_univNum} に同値. どちらかを廃止しよう.
\item 内部関数の変更: {\tt KordWsAll()}, {\tt KsetUpRing()}, {\tt oInitW()}
\item マクロ: {\tt ord\_w}, {\tt weight\_vector}, {\tt s\_weight\_vector},
{\tt w\_to\_vec}, {\tt ecart.weight\_vector}, {\tt ord\_ws\_all}
\item  テスト方法.  cvs-eventail/aux-cone.sm1 の test7 を用いる.
%%Mail/openxm-cvs.inbox ??
\end{enumerate}

\section{2004-09-5, error および ctrl-C でマクロの呼び出し履歴を表示(trace)}
\begin{enumerate}
\item {\tt traceShowStack()} を呼び出すと呼び出し履歴が表示される.
履歴を文字列で戻す.
\item \verb@ ctrlC_hook @ の実行中にエラーをおこすと, ox103\_reset が
よばれ, これが無限ループを生む. これを防止.
\item {\tt executeToken} する前に関数の名前を trace 用のスタック
{\tt TraceNameStack} へ push.
実行がおわれば pop することにより, 履歴表示をコントロール.
\item extension で履歴のクリア, 強制表示ができる.
\item ctrl-C で履歴の表示, クリアをする. これは各 ox server で対処の必要あり.
\item 
{\tt OpenXM/src/kan96xx/Kan/ext.c} 1.24 \\
{\tt OpenXM/src/kan96xx/Kan/kanExport0.c} 1.30 \\
{\tt OpenXM/src/kan96xx/Kan/stackmachine.c} 1.15--1.18  \\
{\tt OpenXM/src/kan96xx/Kan/usage.c} 1.30 \\
{\tt OpenXM/src/k097/ox\_k0.c} 1.6 \\
{\tt OpenXM/src/kxx/ox\_texmacs.c} 1.19 \\
{\tt OpenXM/src/kxx/oxserver00.c} 1.15 \\
{\tt OpenXM/src/kxx/sample\_kanlib.c} 1.2
\end{enumerate}

\section{2004-09-05, EUC等 8-bit の名前を受け付ける}
\begin{enumerate}
\item hash 値の計算方法にバグがあった. hash の値は負ではいけない.
\item {\tt OpenXM/src/kan96xx/Kan/stackmachine.c} 1.17
\end{enumerate}


\section{2004-09-05, グレブナfanの計算}
\begin{enumerate}
\item polymake が必要.  9/1, 9/2, 9/3, 9/4 のノートも参照.
\item OpenXM の cvs への commit は大きい区切りで. 
      細かい変更は {\tt eventail/cone.sm1} で.
\item {\tt OpenXM/src/kan96xx/Doc/gfan.sm1} 1.1
\end{enumerate}

\section{2004-09-05, グレブナfanの計算}
\begin{enumerate}
\item polymake が必要.  9/1, 9/2, 9/3, 9/4 のノートも参照.
\item OpenXM の cvs への commit は大きい区切りで. 
      細かい変更は {\tt eventail/cone.sm1} で.
\item {\tt OpenXM/src/kan96xx/Doc/gfan.sm1} 1.1
\end{enumerate}

\section{2004-09-09, 11, list の強化}
\begin{enumerate}
\item array の {\tt join} を行うとメモリの無だ使いがはげしい.
list の {\tt cons} を導入.  rest も導入. join は使えるが危険.
\item 
{\tt arrayToList}, {\tt listToArray} : 変換関数を準備.
\item {\tt get} がリストでも動くように.
\item {\tt Kan/dr.sm1} 1.35--1.36, 1.38 \\
{\tt Kan/extern.h} 1.24--1.25 \\
{\tt Kan/ext.c} 1.25 \\
{\tt Kan/kanExport0.c} 1.31--1.33 \\
{\tt Kan/list.c} 1.3--1.5 \\
{\tt Kan/primitive.c} 1.12 \\
{\tt Kan/smacro.sm1} 1.5 \\
{\tt Kan/usage.c} 1.32 \\
{\tt Kan/usage.sm1} 1.9
\end{enumerate}

\section{2004-09-10, コンマ {\tt ,} の扱いの変更}
\begin{enumerate}
\item  コンマ {\tt ,} はいままでマクロであったが, 空白として扱うように変更する.
\item  システムの変更は以下の通り. \\
{\tt Kan/scanner.c} 1.5--1.6 \\
{\tt Kan/scanner2.c} 1.4--1.5 \\
{\tt Kan/dr.sm1} 1.37 \\
{\tt Kan/smacro.sm1} 1.6 
\item その他はライブラリ内部で {\tt ,,} を {\tt \_\_} へ,
{\tt ,,,} を {\tt \_\_\_} へ変更した.
\end{enumerate}

\section{2004-09-11,12, infix operator を導入}
\begin{enumerate}
\item {\tt getattr} を加えた (step 1). 
\item {\tt attr} に {\tt ATTR\_INFIX} 属性 bit を立てて,
infix operator とする.
\item {\tt attr} の PROTECT 属性を bit で処理するように変更 (step 2).
テストは {\tt k0} で
\begin{verbatim}
sm1(" [(getattr) /cons] extension :: ");
cons = 1;
\end{verbatim}
Warning が表示されるか?
\item infix 属性があるとき, {\tt getokenSM(GET)} で次の token を読み込み
それを {\tt executeToken} してから, infix 属性のあるマクロを実行すれば
いいかというと, それでは top level  の処理しかできない.
たとえば, tokenArray を順番に処理しているような場合はだめ.
よって, {\tt executeToken} の戻り値の status の値を
用いる.  status は {\tt loop} から {\tt exit} するときにも使われている
ので, status の判定方法を見直す必要がある.
\end{enumerate}

\section{2004-09-13, 部分的な ecart division}

\noindent Debug 用のデータ 1.
{\footnotesize \begin{verbatim}
[ [( (x Dx)^2 + (y Dy)^2 -1) ] (x,y) 
  [ [ (Dx) 1 ] [(x) -1 (y) -1 (Dx) 1 (Dy) 1]] 
  [(partialEcartGlobalVarX) [(x) (y)]] ] ecart.gb /ff set

ff getRing ring_def show_ring

\end{verbatim}
}

\noindent Debug 用のデータ 2.
{\footnotesize \begin{verbatim}
/ecart.checkOrder { 1 } def
[(DebugReductionEcart) 3] system_variable
[ [(1-x-y-z) (1-z)] (x,y,z) 
  [ [(y) -1 (z) -1 (Dy) 1 (Dz) 1] [(x) 1 (Dx) 1]] 
  [(partialEcartGlobalVarX) [(x)]] ] ecart.gb /ff set

ff getRing ring_def show_ring

 [ [(1-z) (-x+1-y-z)] (x,y,z) 
  [ [(y) -1 (z) -1 (Dy) 1 (Dz) 1] [(x) 1 (Dx) 1]] 
  [(partialEcartGlobalVarX) [(x)]] ] /std set
(1+x^3) std ecartd.reduction
(x*y*z) std ecartd.reduction
\end{verbatim}
}
GlobalVarX の変数については local order ではいけない.
無限ループとなる.
{\tt ecart.checkOrder} も書き直さないといけない.

\begin{enumerate}
\item \verb@ ringp->partialEcart @ は int の配列
\verb@ ringp->partialEcartGlobalVarX @ の長さ.
この配列に local でない変数 (first weight が non-negative な x 変数) のリストを入れる.
{\tt ecartGetEllPartial()} で利用される.
\item Todo: ring のメンバ {\tt ringInInputForm} の活用. ( weight vector や
input 形式の ring を object として格納.
\item Todo: {\tt KgetRingInfo} を実装する. index から 変数, 変数から index 等.
\end{enumerate}

\section{2004-09, {\tt ATTR\_EXPORT} と {\tt RestrictedMode}}

\noindent
現在の RestrictedMode には以下の脆弱性がある (2004.9.19).
\begin{verbatim}
(cohom.sm1) run
[(or_attr) 8 /gb] extension 
[(or_attr) 8 /;] extension ;
[(RestrictedMode) 1] system_variable ;
[ [{(hello) message } ] (x,y) ] gb ;
hello     <----  error を起こす前に {(hello) message} が実行されてしまう.
ERROR(sm): 
<< /name object def >>  or  << object /name set >>
\end{verbatim}
\noindent 原因: 
引数に executableArray を与えることにより, 評価が抑制され
{\tt ATTR\_EXPORT} bit がセットされた関数の評価がはじまってから
executableArray が変数 {\tt arg1} に代入され, その変数を scanner
が評価することにより, executableArray が評価される.

\noindent 対策:
{\tt isThereExecutableArrayOnStack(ob)} でスタックを検査するようにする.
\begin{verbatim}
(cohom.sm1) run
[(or_attr) 8 /gb] extension 
[(or_attr) 8 /;] extension ;
0 1 10 { pop pop } for
[(RestrictedMode) 1] system_variable ;
[ [{(hello) message } ] (x,y) ] gb ;
\end{verbatim}

テスト 2 (こちらは正常に動くはず).
\begin{verbatim}
(ox.sm1) run
[(or_attr) 8 /fctr] extension 
[(or_attr) 8 /pmat] extension ;
[(or_attr) 8 /;] extension ;
0 1 10 { pop pop } for
[(RestrictedMode) 1] system_variable ;
[ (x^2-1) (x,y) ] fctr pmat ;
\end{verbatim}

\section{2004-11-23, POST ベースの cgiPolymake 等}

\begin{enumerate}
\item 
{\tt Kan/plugin/mytcpio.c} 1.15 \\
{\tt Kan/plugin/oxcgi.c} 1.7 \\
{\tt Kan/ext.c} 1.33 \\
{\tt Kan/Doc/cgi.sm1} 1.8--1.11 \\
{\tt polymake/cgi/cgi-polymake.sh} 1.3 
\end{enumerate}

GET では受渡しできるデータの量に制限があるため,
POST ベースに変更した.
\begin{verbatim}
POST http://polymake.math.kobe-u.ac.jp/cgi-bin/cgi-asir.sh HTTP/0.9
Content-length: 20

oxMessageBody=2-1%0A
\end{verbatim}

POST のデータをうけとるため,
\verb@ [(read) fd size] extension @
システムコールを加えた.

システムコール {\tt perror} を用いて,
tcpip のエラー等を表示するようにした.
{\tt eventail/data/test32.sm1} の途中のエラーは,
GET では受渡しできるデータの量に制限があるため
起きたようであるが, 適切なエラーメッセージがなくて
原因の究明に時間がかかった反省.

{\tt misc-2004/11/cgi} も参照のこと.
Risa/Asir の \verb@ set_secure_mode @ , \verb@ set_secure_flag @
にも対応中.

\section{2004-12-16, gnuplot v4 への対応.}

\begin{enumerate}
\item 1.3-1.4     OpenXM/src/kan96xx/Doc/gnuplot.sm1 
\item 1.11        OpenXM/src/kan96xx/plugin/file2.c 
\item 1.6           OpenXM/src/kan96xx/plugin/file2.h
\item 1.6        OpenXM/src/kan96xx/plugin/file2.hh
\item 1.4          OpenXM/src/kan96xx/plugin/file2.sm1
\item 1.15        OpenXM/src/asir-contrib/packages/src/gnuplot
\end{enumerate}

gnuplot で mouse  を利用できるようにしたい.
そのため, gnuplot を batch mode でなく,
interactive mode で利用できるようにした.
http://www.gnuplot.info にあった, サンプルプログラム
{\tt gpReadMouseTest.c} ({\tt misc-2004/12/misc}) 
を参考に mkfifo, popen 等を用いて実装した.
mkfifo, popen 等のシステムコールは plugin-file2 へ加えた.

sm1 でやるテストの手順は以下のとおり.
\begin{verbatim}
 (gnuplot.sm1) run
 plotstart.aux
 (splot x**2-y**2;) gnuplot
 plotstop.aux
\end{verbatim}

Windows, Debian package の build のテストはまだ.
({\tt gnuplot4ox} は {\tt gnuplot} に. {\tt gnuplot\_x11} は {\tt libexec}
の下へ install されるため.)

Bug: {\tt plot\_dots} で, 計算しながら表示するという方法がうまくいかない.
大きなデータを渡すとうまく動かない. cf. {\tt heat()}.

\section{2005-01-23, EUC等 8-bit の名前を受け付ける. bug fix}
\begin{enumerate}
\item scanner2 の bug により, トップレベル以外では 8 bit の名前をうけつけ
    なかった.
\item {\tt OpenXM/src/kan96xx/Kan/scanner2.c} 1.7
\end{enumerate}

\section{2005-02-28, ox, bug fix}

\begin{enumerate}
\item Engine のみを quit  すると control server が残るバグ.
解決: oxmain.c で  SIGCHLD を受け取るようにした.
\item Engine を quit してしまったあと, Engine でデータをおくろうとすると,
SIGPIPE で クライアントが終了してしまうバグ.
\begin{verbatim}
  (ox.sm1) run
  sm1connectr
  oxsm1.ccc (quit) oxsubmit
  oxsm1.ccc oxpopcmo --> クライアント終了.
\end{verbatim}
まだ完全に解決してない. 
ox texmacs が正しく動作するのか要テスト.
\end{enumerate}

\section{2005-06-9, 16, attribute, options.}
\begin{enumerate}
\item  全ての object に attr (attribute field) をつけた.
効率に関する調査は {\tt misc-2005/06/gfan/test1.sm1} (taka).
時間的効率についてはあまり問題ない.
\item 構造体の {\tt attr} フィールドを初期化するため {\tt OINIT} マクロを
加えた. {\tt stackm.h}
初期化がないと segfault する場合も.
\item {\tt @s/2005/06/16-note.pdf} (taka) に開発メモあり.
\item {\tt attr} を {\tt groebner}, {\tt gb} 等で活用する.
\end{enumerate}

ソースの変更は多岐にわたるので一部のみ記す.
\begin{enumerate}
\item {\tt OpenXM/src/kan96xx/Kan/dr.sm1} 1.49,  {\tt setAttribute} 等のマクロ.
\item {\tt OpenXM/src/kan96xx/kan/gb.c} 1.10,11, {\tt groebner} が attr で gb かどうかの情報を戻す.
\item {\tt OpenXM/src/kan96xx/Doc/hol.sm1} 1.23,  gb, pgb, gb\_h が option を attr で受け取れるようにする変更.
\end{enumerate}

例:
{\footnotesize
\begin{verbatim}
  ob key getAttribute value
  Example: [(x-1) (y-1)] (gb) 1 setAttribute /ff set
           ff (gb) getAttribute ::
  
  ob getAttributeList attr-obj
  Example: [(x-1) (y-1)] [(gb) 1] setAttributeList /ff set
           ff getAttributeList ::

  sm1> [(x0,x1) ring_of_polynomials 0] define_ring
           [(x0^2+x1^2-h^2). (x0 x1 -4 h^2).] /ff set ;
  sm1>[ff [(gbCheck)]] groebner /gg set ;
   3.gbCheck failed.
  Note that the result is NOT groebner basis.
  
  Completed.
  sm1>gg getAttributeList ::
  [    $gb$ , 0 ]


   [ [( (x Dx)^2 + (y Dy)^2 + 1) ( x y Dx Dy -1)] (x,y)
       [ [ (Dx) 1 ] ] ] [(gbCheck) 1] setAttributeList gb getAttributeList ::
  
   [ [[(h+x) (x^3 + 2 h^3 + 2 x h^2)] [(x) (x)]] (x)]
              [(reduceOnly)] setAttributeList gb_h pmat


\end{verbatim}
}

\section{2005-07-07, gfan.sm1}
\begin{enumerate}
\item  Collar-Kalkbrener-Moll のアルゴリズムを実装した.
\item {\tt getNextCone}, {\tt ckmFlip}
\item {\tt cone.ckmFlip} が 1 の時 CKM アルゴリズムを用いる.
\item  {\tt cone.DhH} が 1 の時 $\partial x = x \partial + hH$,
0 の時 $\partial x = x \partial + h^2$ を選択.
{\tt cone.gb}, {\tt cone.reduction}, {\tt cone.gb\_gr}.
\item 関連する sm1 本体の変更.
\item {\tt eventail/data/test35.sm1}, {\tt test36.sm1}.
\end{enumerate}

\begin{enumerate}
\item {\tt OpenXM/src/kan96xx/Doc/gfan.sm1} 1.10, 1.11.
\end{enumerate}

\section{2005-07-18, Error Message}
\begin{enumerate}
\item  サーバはエラーの位置およびエラーの位置での読み込みデータを
XML 形式で送る.
\begin{verbatim}
 (ox.sm1) run  sm1connectr
 oxsm1.ccc (1 shell) oxsubmit 
 oxsm1.ccc oxpopcmo  ::
\end{verbatim}
\item {\tt scanner.c}, {\tt scanner2.c} で {\tt ScannerBuf} に
 読み込んだデータを書き込む.
\item {\tt stackmachineError()} で 
 大域変数 {\tt MsgStackTrace}, {\tt MsgSourceTrace} に書き込んでおく.
\item {\tt kxx/sm1stackmachine.c} の {\tt Sm1\_pushError2} で,
上の大域変数に設定されたメッセージをもとに,  error package
の文字列に XML 形式で error message を書く.
\item \verb@ [(traceShowScannerBuf)] extension :: @
\item Todo: {\tt executeToken} の中までみないと, すでに定義された関数のどの位置でエラーを起こしたのかがわからない.
\end{enumerate}

\section{2006-01-26, -engineLogToStdout}
\begin{enumerate}
\item   engine を xterm 内部で動かさないで呼び出したプログラム
の標準出力へつないだまま動かす.
\begin{verbatim}
 (ox.sm1) run 
 /Xm_engineLogToStdout 1 def
 asirconnectr 
 ((x-2)^2). fctr ::
\end{verbatim}
\item   cfep への対応.
\begin{verbatim}
  ox_texmacs --view cfep --engineLogToStdout
  ox_texmacs --view debug --engineLogToStdout
\end{verbatim}
\end{enumerate}

ソースの変更.
\begin{enumerate}
\item {\tt OpenXM/src/kan96xx/Doc/ox.sm1} 1.46
\item {\tt OpenXM/src/kxx/ox_texmacs.c} 1.26
\item {\tt OpenXM/src/kxx/ox100start.c}  1.7
\item {\tt OpenXM/src/util/ox_pathfinder.c, h} 1.30

\end{document}

