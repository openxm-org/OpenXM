%%%%%%%%%%%  $OpenXM: OpenXM/src/kan96xx/Doc/ox.sm1,v 1.58 2013/09/19 10:15:11 takayama Exp $

/ox.sm1.myname (ox-new.sm1) def

[(ostype)] extension 0 get (unix) eq {
  /oxstart100 
    [[(getenv) (OpenXM_HOME)] extension (/bin/ox100start )] cat 
  def
} {
  /oxstart100 
   [[(getenv) (OpenXM_HOME)] extension
    (/bin/ox100start.exe )] cat 
  def
} ifelse
[(getenv) (OXSTART100)] extension tag 0 eq not {
  /oxstart100 [(getenv) (OXSTART100)] extension def
} {  } ifelse 
oxstart100  message-quiet

/ox.sm1.loaded 1 def
/oxasir.sm1.loaded 1 def
/ox.k0.loaded 1 def
/Ox103_loaded 1 def

/ox.verbose 0   def
/ox.version (3.030000) def
ox.version [(Version)] system_variable gt 
{ (This package requires the latest version of kan/sm1) message
  (Please get it from http://www.math.kobe-u.ac.jp/KAN) message
  error
} { } ifelse
(ox.sm1, ---OpenXM protocol module 07/20, 2003  (C) N.Takayama.) message-quiet
(           for ox_sm1, ox_asir, ox_k0 ) message-quiet

/ox.ccc load isArray 
{ }
{ /ox.ccc [ ] def } ifelse
/oxsm1.ccc load isArray 
{ }
{ /oxsm1.ccc [ ] def } ifelse
/ox.takelog 0 def

(@@@.Xm_noX) boundp {
}{ 
  /@@@.Xm_noX 0 def
} ifelse
(Xm_noX) boundp {
  /@@@.Xm_noX Xm_noX def
}{  } ifelse
/Xm_noX @@@.Xm_noX def
/Xm_engineLogToStdout 0 def

/oxNoX {
   /Xm_noX 1 def
} def

(@@@.monitor) boundp {
}{ 
  /@@@.monitor ( ) def
} ifelse

/oxMonitor {
  /@@@.monitor ( -monitor ) def
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%   basic functions for OX-RFC 100
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/SM_executeStringByLocalParser 268 def
/SM_execute 268 def
/SM_popString  263  def
/SM_mathcap 264 def

/SM_popCMO 262 def
/SM_executeFunction 269 def
/SM_DUMMY_sendcmo   2147418112 1 add def    %%% SM_PRIVATE+1
/SM_sync_ball 281 def

/SM_pops  265  def
/SM_setName 266  def
/SM_evalName 267  def

/SM_setMathCap 273 def

/SM_getsp     275  def
/SM_dupErrors 276  def

/SM_pushCMOtag 277 def
/SM_executeFunctionWithOptionalArgument 282 def

/SM_control_kill 1024 def
/SM_control_reset_connection  1030 def
/SM_control_spawn_server  1027 def

/Etag_error 257 def

[(ox)
 [
  (client aa oxpushcmo (oxsendcmo), client oxpopcmo dd, client popstring dd, client ss oxrpc) 
 (Example: oxsm1.ccc [1 2 3] oxpushcmo oxsm1.ccc oxpopcmo /ff set  ff :: ) 
 (  )
 (client ss oxexecutestring(oxsubmit) <<executeString>>, client ss oxexec <<executeFunction>>) 
 (client ss oxexecWithOpt )
 
 (Example: oxsm1.ccc (0 1 10 { pop $Hello$ message } for) oxexecutestring ) 
 (Example: oxsm1.ccc (2).. oxpushcmo oxsm1.ccc (10).. oxpushcmo )
 (         oxsm1.ccc (power) oxexec  oxsm1.ccc oxpopcmo :: )
 (  )
 (client str oxevalname, client str oxsetname, client num oxpops, client oxget) 
 (   )
 (client oxmathcap, client oxsetmathcap, oxgenportfile, oxremoveportfile)
 (client oxpushcmotag)
 (   )
 (client oxgetsp --- get stack pointer,  client oxgeterrors --- get all errors)
 (client oxclearstack --- clear the stack of the ox server.)
 (cleint oxisData, client oxreset, client oxshutdown)
 (oxhelp for this message)
 ([(oxWatch) client] extension to start a log.)
 $        ex 1.  (ox.sm1) run sm1connectr [(oxWatch) oxsm1.ccc] extension  $
 $               oxsm1.ccc ( [(cmoLispLike) 0] extension ) oxsubmit $
 $               oxsm1.ccc ( [(cmoLispLike) 1] extension ) oxsubmit $
 ([(oxSerial)] extension serial-number-of-out-going-ox-packet.)
 (oxpopcmo1, oxpopcmo2, sm1connectr ox_launch, ox_launch_nox)
 (oxNoX : set an environment to invoke oxlog without xterm and to call oxlog with >& /dev/null)
 $        ex 1.  (ox.sm1) run oxNoX sm1connectr $
 $        ex 2.  (ox.sm1) run oxNoX (x^2-1). fctr pmat ; $
 $   $
 $cf. extension-oxLog $
 (oxMonitor : ox_sm1 server outputs packet dumps.)
 $        ex 1. (ox.sm1) run oxMonitor sm1connectr $
 ]
] putUsages

[(extension-oxLog)
[
$Take the log of communication in files.$
$[(oxLog) client logfile_for_incomming_data logfile_for_outgoing_data] extension $
$Example:$
$  [(parse) (ox.sm1) pushfile] extension$
$  sm1connectr$
$  (i.t) (w) file /ii set$
$  (o.t) (w) file /oo set$
$  [(oxLog) oxsm1.ccc ii oo] extension $
$  [(oxWatch) oxsm1.ccc ] extension$
$  oxsm1.ccc 1 oxpushcmo ;$
$  oxsm1.ccc oxpopcmo ;$
$  [(oxLogStop) oxsm1.ccc] extension$
]] putUsages

/oxconnect {
  /arg1 set
  [(oxCreateClient) arg1 aload pop] extension 
} def

ox.verbose { oxhelp } {  } ifelse

/oxpushcmo { oxsendcmo } def
/oxsendcmo {
  /arg1 set
  /arg2 set
  ox.takelog { ox.log [(oxSerial)] extension ox.mod arg1 put 
  } {  } ifelse
  [(oxReq) arg2 SM_DUMMY_sendcmo arg1] extension pop
} def

/oxpushcmotag {
  /arg2 set
  [(oxReq) arg2 SM_pushCMOtag ] extension pop
} def

/oxpopcmo {
  /arg1 set
  [(oxReq) arg1 SM_popCMO ] extension pop
  [(oxGet) arg1] extension 
} def

/oxgetsp {
  /arg1 set
  [(oxReq) arg1 SM_getsp ] extension pop
  [(oxReq) arg1 SM_popCMO ] extension pop
  [(oxGet) arg1] extension 
} def

/oxgeterrors {
  /arg1 set
  [(oxReq) arg1 SM_dupErrors ] extension pop
  [(oxReq) arg1 SM_popCMO ] extension pop
  [(oxGet) arg1] extension 
} def

/oxmathcap0 {
  /arg1 set
  [(oxReq) arg1 SM_mathcap ] extension pop
} def
/oxmathcap {
  /arg1 set
  [/in-oxmathcap /mypeer /mmm] pushVariables
  [ /mypeer arg1 def
    mypeer oxmathcap0 
    mypeer oxpopcmo /mmm set
    mypeer 10 mmm put  %% set math cap.
  ] pop
  popVariables
} def
/oxsetmathcap {
  /arg1 set
  [/in-oxsetmathcap /mypeer /mymathcap] pushVariables
  [
    /mypeer arg1 def
    /mymathcap     [(cmoMathCap)] extension (array) dc def
    [(oxReq) 
      mypeer   SM_setMathCap
      mymathcap
    ] extension pop
  ] pop
  popVariables
} def

/oxpopcmo1 {  %% ask of the transmission.
  /arg1 set
  [(oxReq) arg1 SM_popCMO ] extension pop
} def
/oxpopcmo2 {  %% wait the data.
  /arg1 set
  [(oxGet) arg1] extension 
} def


/oxpopstring {
  /arg1 set
  [(oxReq) arg1 SM_popString ] extension pop
  [(oxGet) arg1] extension 
} def

/oxrpc {
  /arg1 set
  /arg2 set
  [/ans /ff] pushVariables
  [
   /ff arg2 def
   ox.takelog { ox.log [(oxSerial)] extension ox.mod arg1 put 
                ox.log [(oxSerial)] extension 1 add ox.mod (executeString) put
   } {  } ifelse
   [(oxReq) ff SM_execute arg1] extension pop
   [(oxReq) ff SM_popCMO] extension pop
   [(oxGet) ff] extension /ans set
   ans etag Etag_error  eq {
     (Got an error object.) message
     /arg1 ans def
   }
   {  /arg1 ans def
    } ifelse
  ] pop
  popVariables
  arg1
} def

/oxexecutestring { oxsubmit } def
/oxsubmit {
  /arg1 set
  /arg2 set
   ox.takelog { ox.log [(oxSerial)] extension ox.mod arg1 put 
                ox.log [(oxSerial)] extension 1 add ox.mod (executeString) put
   } {  } ifelse
  [(oxReq) arg2 SM_execute arg1] extension pop
} def

/oxexec {
  /arg1 set
  /arg2 set
   ox.takelog { ox.log [(oxSerial)] extension ox.mod arg1 put
                ox.log [(oxSerial)] extension 1 add ox.mod (executeFunction) put
   } {  } ifelse
  [(oxReq) arg2 SM_executeFunction arg1] extension pop
} def
/oxexecWithOpt {
  /arg1 set
  /arg2 set
   ox.takelog { ox.log [(oxSerial)] extension ox.mod arg1 put
                ox.log [(oxSerial)] extension 1 add ox.mod 
               (executeFunctionWithOptionalArgument) put
   } {  } ifelse
  [(oxReq) arg2 SM_executeFunctionWithOptionalArgument arg1] extension pop
} def
[(oxexecWithOpt)
 [
  $Example: $
  $oxsm1.ccc (/foo { message message message } def) oxsubmit ;$
  $oxsm1.ccc (hello) oxpushcmo oxsm1.ccc 1 oxpushcmo oxsm1.ccc [[(opt) 0]] oxpushcmo ;$
  $oxsm1.ccc (foo) oxexecWithOpt $
 ]
] putUsages
/oxsubmit2 {
  oxexec
} def

/oxpops {
  /arg1 set
  /arg2 set
  [(oxReq) arg2 SM_pops arg1] extension pop
} def

/oxsetname {
  /arg1 set
  /arg2 set
  [(oxReq) arg2 SM_setName arg1] extension pop
} def

/oxevalname {
  /arg1 set
  /arg2 set
  [(oxReq) arg2 SM_evalName arg1] extension pop
} def


/oxreset {
  /arg1 set
  [(oxReq) arg1 SM_control_reset_connection] extension pop
%%  [(oxGetFromControl) arg1 ] extension pop
  [(oxGet) arg1] extension message
} def

/oxisData {
  /arg1 set
  [/pp /ff] pushVariables
  [
    /ff arg1 def
    [(oxMultiSelect) [ff] 10] extension /pp set
    pp message
    pp 0 get 1 eq {
      pp 1 get 0 get 1 eq {  %% data is in the data stream.
        /arg1 [(oxGet) ff] extension def
      } {/arg1 (no data) def  } ifelse
    }
    { /arg1 (no data) def }
    ifelse
  ] pop
  popVariables
  arg1
} def

/oxget {
  oxisData
} def


/oxshutdown {
  /arg1 set
  [(fp2fclose) arg1 1 get] extension
  [(oxReq) arg1 SM_control_kill] extension
  arg1 0 (closed) put
} def

/oxgenportfile {
  [(oxGenPortFile)] extension
}def
/oxremoveportfile {
  [(oxRemovePortFile)] extension
}def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/ox_launch_nox { 
  Xm_noX /ox_launch_nox.save set
  oxNoX
  ox_launch_aux
  /Xm_noX ox_launch_nox.save def
} def
/ox_launch { 
  ox_launch_aux
} def

/ox_launch_aux {
 /arg1 set
 [/in-launch_nox /pass /peer /data /control /name /machine
  /your-peer /comm /remoteOpenXMbin /remoteServer /myhost
  /argNumber /aaa  /myssh
 ] pushVariables
 [
   /aaa arg1 def
   /argNumber aaa length def 
   /machine aaa 0 get def
   machine (localhost) eq argNumber 5 lt and {
     aaa 1 get ox_launch_localhost /your-peer set
     /LLL.end goto
   } {
     /remoteServer aaa 1 get def
     /name aaa 2 get def
   } ifelse

   /myssh [(which) (ssh)] oxshell def
   myssh tag 0 eq {
     (ssh is not found.) error
   } { } ifelse

   [(gethostname)] extension /myhost set

   /pass ox_encrypt_104_genPass def
   /peer [(oxGetPort) myhost] extension def
   /data peer 1 get toString def
   /control peer 3 get toString def
   peer message
   peer 0 get -1 eq {
     (Error in oxGetPort) error
   } { } ifelse
 [myssh ( -X -f ) machine ( -l ) name ( )
    [
     (ox100start ) % it must be on a path of the remote host
     @@@.quiet { ( -quiet ) } {  } ifelse
     Xm_noX { ( -nox ) } { } ifelse
     ( -oxserver ) remoteServer ( -e )
     ( -reverse )
     ( -host ) myhost
     ( -data ) data ( -control ) control   pass [1 2] get  
    ] cat 
 ] cat /comm set
 (Executing the command : ) messagen comm message 
  comm execve 0 lt {
    (Fork exec failed) error
  } { } ifelse
% ipmask must be 1 to accept from a global address.
 [(oxCreateClient2) peer 1 , pass 0 get] extension /your-peer set
 /LLL.end
 /arg1 your-peer def
 ] pop
 popVariables
 arg1
} def

[(ox_launch)
[( [remote-machine remote-ox-server-name remote-login-name] )
 (  ox_launch  client )
 $or $
 $ [(localhost) ox-server-name] ox_launch client$
 (This command launches ox server via ssh.)
 (My hostname is set by the function gethostname.)
 (Example 1: )
 $ [(orange2-clone) $
 $  (bin/ox_sm1) (taka)$
 $ ] ox_launch /@@@.oxsm1 set $
]] putUsages

[(ox_launch_nox)
[( [remote-machine remote-ox-server-name remote-login-name] )
 (  ox_launch_nox  client )
 (Example 1: )
 $ [(tau.math.kobe-u.ac.jp) $
 $  (bin/ox_math) (taka) $
 $ ] ox_launch_nox /@@@.oxmath set $
]] putUsages

/ox_launch_localhost {
 /arg1 set
 [/in-ox_launch_localhost /pass /peer /data /control /oxserver
  /my-peer] pushVariables
 [
    /oxserver arg1 def
    /pass ox_encrypt_104_genPass def
    /peer [(oxGetPort) (localhost)] extension def
    /data peer 1 get toString def
    /control peer 3 get toString def
    peer message
    [
     oxstart100
     @@@.quiet { ( -quiet ) } {  } ifelse
     Xm_noX { ( -nox ) } { } ifelse
     ( -oxserver ) oxserver ( -e )
     ( -reverse )
     ( -data ) data ( -control ) control   pass [1 2] get  
    ] cat execve
    [(oxCreateClient2) peer 0 pass 0 get] extension /my-peer set
                         %% 0 means connect from only localhost. 
    /arg1 my-peer def
 ] pop
 popVariables
 arg1
} def

/oxrpc2 {
  /arg2 set
  /arg1 set
 [/in-oxrpc2 /pid /n /comm /i] pushVariables
 [
   /pid arg1 def
   /comm arg2 def
   /n comm length def
   n 1 sub -1 1 {
       /i set
       pid comm i get oxsendcmo
   } for
   pid n 1 sub oxsendcmo
   pid comm 0 get oxexec
 ] pop
 popVariables
} def

[(oxrpc2)
  [(Remote procedure call by using oxexec)
   (client [function-name  arg1 arg2 ...] oxrpc2 )
   (cf. ox-cmo-rpc in Risa/Asir)
   (Example: )
   $ (oxasir.sm1) run (x^2-1). fctr $  
   (oxasir.ccc [(igcd) (6).. (10)..] oxrpc2) 
   (oxasir.ccc oxpopcmo :: )
  ]
] putUsages

/oxIsServerReady {
  /arg1 set
  [/in-isServerReady /sdata /ans] pushVariables
  [
    /sdata arg1 def
    /ans 0 def
    sdata isArray {
     sdata length 1 gt {
       sdata 0 get (client) eq { /ans 1 def } { } ifelse
     } { } ifelse
    } { } ifelse
    /arg1 ans def
  ] pop
  popVariables
  arg1
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%  Functions to start server by OX-RFC-101
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/sm1StartControl101 {
 [/in-sm1connectr /pass /peer /data /control ] pushVariables
 [
 /pass ox_encrypt_104_genPass def
 /peer [(oxGetPort1) (localhost)] extension def
 /data peer 1 get toString def
 peer message
 [(/home/nobuki/OpenXM/src/oxc/oxc)
  ( -c ) pass ( -h ) (localhost) ( -p ) data ( -x )
  oxpath.null
  ( &)] cat system-csh

 [(oxCreateControl_RFC_101) peer 0 pass] extension /oxsm1.ccc set
                     %% 0 means connect from only localhost. 
 /ox.ccc oxsm1.ccc def
 (The server is binded to the variable oxsm1.ccc) message-quiet
  oxsm1.ccc
 ] pop
 popVariables
} def

/sm1StartEngine101 {
 [/in-sm1StartEngine101 /peer /data /control /engineID] pushVariables
 [
    /peer [(oxGetPort1) (localhost)] extension def
    /data peer 1 get def

    oxsm1.ccc data oxpushcmo
    oxsm1.ccc (/home/nobuki/OpenXM/bin/ox_sm1) oxpushcmo
    [(oxPushCMD) oxsm1.ccc SM_control_spawn_server] extension
    oxsm1.ccc oxpopcmo /engineID set
    [(oxCreateEngine_RFC_101) peer 0 (Empty) engineID] extension
    /ox.ddd set
    (The engine is binded to the variables ox.ddd) message-quiet
 ] pop
 popVariables
 arg1
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Functions for OX-RFC 103
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[(chattr) 0 /ctrlC-hook] extension
/ctrlC-hook {
  ox103_reset
} def
/ox103_disable {
  [(chattr) 0 /ctrlC-hook] extension
  /ctrlC-hook {  } def
} def

[(ox103_reset)
 [(ox103_reset broadcasts the OX reset to all processes)
  (cf. ctrlC-hook, register_hander)
]] putUsages
/ox103_reset {
  [/in-ox103_reset /L /n /i] pushVariables
  [
     /L [(oxGetClientList)] extension def
    (In ox103_reset...) message
    (killall in oxshell...) message [(killall)] oxshell pop
     /n L length def
     0 1 n 1 sub {
       /i set
       L i get oxreset
     } for
     (Done) message
  ] pop
  popVariables
} def

%%%%%%%
/ox103_asir_init {
  /arg1 set
  [/ttt] pushVariables
  [
    /ttt arg1 def
    %% ttt oxsetmathcap     ttt oxmathcap  %% It is done in asir.init
    %% Do nothing special for now.
  ] pop
  popVariables
} def
/ox103_sm1_init {
  /arg1 set
  [/ttt] pushVariables
  [
    /ttt arg1 def
    ttt oxsetmathcap
    ttt oxmathcap
    ttt ([(parse) (oxrfc103.sm1) pushfile] extension ) oxsubmit 
  ] pop
  popVariables
} def
%%% 

/Xm_rfc103_shared [ ] def

[(ox103_set_shared_variable)
 [(value name 2 ox103_set_shared_variable)
  (It broadcasts the <<value>> of a shared variable <<name>>)
  (to all processes.)
  (cf. Xm_rfc103_shared, )
  $Example:  (2).. (hoge) 2 ox103_set_shared_variable$
]] putUsages 
/ox103_set_shared_variable {
  /arg0 set  %% Dummy to be called by rpc2. Number of args
  /arg1 set  %% Name
  /arg2 set  %% Value,  [Name Value] not [Value Name]
  [/in-ox103_set_shared_variable /Name /Value
   /Found /N /i  /L 
  ] pushVariables
  [
    /Name arg1 def
    /Value arg2 def
    Value message
    /Found 0 def
    /N  Xm_rfc103_shared length def
    0 1 N 1 sub {
      /i set
      Xm_rfc103_shared i get 0 get
      Name eq {
        Xm_rfc103_shared i [Name Value] put
        /Found 1 def
        exit 
      } {  } ifelse
    } for
    Found 1 eq { }
    {
      Xm_rfc103_shared [Name Value] append
      /Xm_rfc103_shared set
    } ifelse
    /L [(oxGetClientList)] extension def    
    0 1 L length 1 sub {
      /i set
      L i get [(ox103_set_shared_variable) Name Value] oxrpc2
    } for 

    (ox103_set_shared_variable: Xm_rfc103_shared=) message
    Xm_rfc103_shared message
    %% [(parse) [(/) Name ( ) Value toString ( def )] cat] extension
    %% Add $ $ when Value is a string.
 
    /arg1 [Name Value] def
  ] pop
  popVariables
  arg1
} def

/ox103_test {
  (x^2-1). fctr
  oxasir.ccc ( sm1_start(); ) oxexecutestring
  sm1connectr
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%   Starting ox_sm1.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/sm1connectr {
 [/in-sm1connectr /pass /peer /data /control ] pushVariables
 [
   [(getServerEnv) (bin/ox_sm1)] extension tag 0 eq {
     (Server bin/ox_sm1 is not found.) error
   }{ } ifelse
 /pass ox_encrypt_104_genPass def
 /peer [(oxGetPort) (localhost)] extension def
 /data peer 1 get toString def
 /control peer 3 get toString def
 peer message-quiet
 [
  oxstart100
  @@@.quiet { ( -quiet ) } {  } ifelse
  Xm_noX { ( -nox ) } {  } ifelse
  Xm_engineLogToStdout { ( -nox -engineLogToStdout ) } { } ifelse %bug.onlyForsm1
  ( -oxserver bin/ox_sm1 -e ) ( -reverse ) @@@.monitor
  ( -data ) data ( -control ) control   pass [1 2] get  
  ( )] cat execve
 [(oxCreateClient2) peer 0 pass 0 get] extension /oxsm1.ccc set
                     %% 0 means connect from only localhost. 
 (The server is binded to the variable oxsm1.ccc) message-quiet
  /ox.ccc oxsm1.ccc def
  oxsm1.ccc.init 
  oxsm1.ccc
 ] pop
 popVariables
} def

/oxsm1.ccc.init { 
   oxsm1.ccc ( [(oxPrintMessage) 0] extension pop ) oxsubmit 
   Xm_noX { oxsm1.ccc ( /@@@.Xm_noX 1 def ) oxsubmit }
          { oxsm1.ccc ( /@@@.Xm_noX 0 def ) oxsubmit } ifelse
   (Ox103_loaded) boundp
   { oxsm1.ccc ox103_sm1_init }
   { }  ifelse
} def

/sm1connectr-ssh {
%% It has not yet implemented.
 /arg1 set
 [/in-sm1connectr /pass /peer /data /control /name /machine
  /your-peer /comm
 ] pushVariables
 [
 /machine arg1 0 get def
 /name arg1 1 get def

 /pass ox_encrypt_104_genPass def
 /peer [(oxGetPort) myhostname-ssh] extension def
 /data peer 1 get toString def
 /control peer 3 get toString def
 peer message-quiet
 [(ssh -f ) machine ( -l ) name ( ")
  oxpath.oxlog.xterm-ssh  oxpath.ox-ssh ( -reverse -ox ) oxpath.oxsm1-ssh
  ( -host ) myhostname-ssh
  ( -data ) data ( -control ) control   pass [1 2] get  
  oxpath.null
  ( ")
 ] cat /comm set
 (Executing the command : ) messagen comm message message
  comm system
 (sleep 5) system-csh
 [(oxCreateClient2) peer 1 pass 0 get] extension /your-peer set
 /arg1 your-peer def
 ] pop
 popVariables
 arg1
} def
[(sm1connectr-ssh)
[([hostname login-name] sm1connectr-ssh client)
 (Starting oxpath.oxsm1-ssh by the launcher oxpath.ox-ssh on the "hostname".)
 (cf. oxNoX  ox )
 (Set the following varialbes to appropriate values:)
 (oxpath.oxlog.xterm-ssh  oxpath.oxsm1-ssh  oxpath.ox-ssh myhostname-ssh )
 $Example 1: $
 $  *** Path names on the remote machine dc1.math.kobe-u.ac.jp $
 $    /oxpath.oxlog.xterm-ssh (/home/taka/OpenXM/bin/oxlog /usr/X11R6/bin/xterm -icon -e ) def $
 $    /oxpath.oxsm1-ssh (/home/taka/OpenXM/bin/ox_sm1) def $
 $    /oxpath.ox-ssh    (/home/taka/OpenXM/bin/ox) def $
 $  *** The machine name on which you are running sm1. $
 $    /myhostname-ssh   (yama.math.kobe-u.ac.jp) def $
 $         [(dc1.math.kobe-u.ac.jp) (taka)] sm1connectr-ssh /ox.ccc set  $
 $Example 2: $
 $  *** Path names on the remote machine dc2.math.kobe-u.ac.jp $
 $  *** We will not use X11 debug windows. $
 $    oxNoX $
 $    /oxpath.oxlog.xterm-ssh (/home/taka/OpenXM/bin/oxlog ) def $
 $    /oxpath.oxsm1-ssh (/home/taka/OpenXM/bin/ox_sm1) def $
 $    /oxpath.ox-ssh    (/home/taka/OpenXM/bin/ox) def $
 $  *** the machine name on which you are running sm1. $
 $    /myhostname-ssh   (dc1.math.kobe-u.ac.jp) def $
 $         [(dc2.math.kobe-u.ac.jp) (taka)] sm1connectr-ssh /ox.ccc set  $
]] putUsages

%%% ntl
/ntlconnectr {
 [/in-ntlconnectr /pass /peer /data /control ] pushVariables
 [
   [(getServerEnv) (bin/ox_ntl)] extension tag 0 eq {
     (Server bin/ox_ntl is not found.) error
   }{ } ifelse
 /pass ox_encrypt_104_genPass def
 /peer [(oxGetPort) (localhost)] extension def
 /data peer 1 get toString def
 /control peer 3 get toString def
 peer message-quiet
 [
  oxstart100
  Xm_noX { ( -nox ) } {  } ifelse
  ( -oxserver bin/ox_ntl -e ) ( -reverse )
  ( -data ) data ( -control ) control   pass [1 2] get  
  ( )] cat execve
 [(oxCreateClient2) peer 0 pass 0 get] extension /oxntl.ccc set
                     %% 0 means connect from only localhost. 
 (The server is binded to the variable oxntl.ccc) message-quiet
%  oxntl.ccc.init 
   oxntl.ccc
 ] pop
 popVariables
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%   Aux functions for ox_asir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/ox_asirConnectMethod { 
  asirconnectr /oxasir.ccc set 
  [(getenv) (OX_ASIR_LOAD_FILE)] extension tag 0 eq { 0 }
  { /oxasir.loadfile [$load("$[(getenv) (OX_ASIR_LOAD_FILE)] extension $");$] 
    cat  def
    oxasir.ccc oxasir.loadfile oxsubmit
    oxasir.ccc oxpopcmo } ifelse
} def
/oxasir.loadmethod 1 def   %% "..." oxsendcmo (load) ox...
/oxasir.verbose 0   def
/oxasir.ccc load isArray 
{ }
{ /oxasir.ccc [ ] def } ifelse
/loadAsirFile {
  /arg1 set
  [/in-loadAsirFile /peer /fname] pushVariables
  [
    /peer arg1 0 get def
    /fname arg1 1 get def
    oxasir.loadmethod  {
      peer  fname oxsendcmo peer 1 oxsendcmo
      peer (load) oxexec
    }{
      peer  [$load("$ fname $");$] cat oxsubmit
    }ifelse
  ] pop
  popVariables
} def
[(loadAsirFile)
[$[client fname] loadAsirFile   (ox_asir function)$
 $Load a file into the client$
]] putUsages

/set_oxasir.rr_path {
 [(ostype)] extension  0 get (windows) eq {
  [(getenv) (OSTYPE)] extension tag 0 eq {
     /oxasir.rr.name  (oxasir-win.rr) def
  }{
   [(getenv) (OSTYPE)] extension (cygwin) eq {
     /oxasir.rr.name  (oxasir.asir) def
   }{
     /oxasir.rr.name  (oxasir-win.rr) def
   } ifelse
  } ifelse
 }{
     /oxasir.rr.name  (oxasir.asir) def
 } ifelse
} def
set_oxasir.rr_path
/oxasirpath.asirlib [[(getenv) (OpenXM_HOME)] extension
                      (/lib/sm1/) oxasir.rr.name] cat  def
oxasir.verbose {
 oxasirpath.asirlib message
} { } ifelse

%% Note.  oxasir.asir is under OpenXM/src/kan96xx/lib/
%%        oxasir-win.asir is generated under OpenXM/misc/packages/Windows
%%       They are installed under $OpenXM_HOME/lib/sm1
%%       Todo:  ox_asir has to understand /cygdrive/c/... on windows-native.
%%              Since ox_asir is generated by cygwin, it will be OK.
/asir.init {
 %% gr and primdec are loaded by .asirrc
 /asir.init.peer set
 [(ostype)] extension  0 get (windows) eq {
  [(getenv) (OSTYPE)] extension tag 0 eq {
    [asir.init.peer (oxasir-win.rr)] oxasirParseFile
  }{
   [(getenv) (OSTYPE)] extension (cygwin) eq {
     [asir.init.peer  oxasirpath.asirlib] loadAsirFile
   }{
     [asir.init.peer  (oxasir-win.rr)] oxasirParseFile
   } ifelse
  } ifelse
 }{
   [asir.init.peer  oxasirpath.asirlib] loadAsirFile
 } ifelse
 asir.init.peer oxmathcap
 asir.init.peer oxsetmathcap 
 Xm_noX {
   asir.init.peer (Xm_noX=1$) oxsubmit
 }{  
   asir.init.peer (Xm_noX=0$) oxsubmit
 } ifelse
 (Ox103_loaded) boundp 
 {
   asir.init.peer ox103_asir_init
 }{  } ifelse
} def

[(asir)
 [(pid [asir-command, asir-arg1, asir-arg2, ...] asir result  (ox_asir function)) 
  (Call open asir server. You need to install ox_asir on your system)
  (to use this function. cf. primadec, fctr, asirconnect2, asirconnectr.)
  (If you interrupted the computation by typing ctrl-C, type in )
  (   oxasir.ccc oxreset  ; )
  (to interrupt the ox_asir server.)
  (NOTE: all asir-args must belong to the same ring. cf.oxasir.changeRing. )
  (Example: oxasir.ccc [(fctr) (x^10-1).] asir )
  (  )
  (This function requires plugins cmo, socket and ox_asir server. cf. oxasir)
  (See, http://www.math.kobe-u.ac.jp/Asir on asir)
 ]
] putUsages

/asir {
  /arg2 set
  /arg1 set
  [/pid  /asir-comm /comm /n /i /rr] pushVariables
  [(CurrentRingp)] pushEnv
  [
     /pid arg1 def
     /asir-comm arg2 def
     pid tag 6 eq {  } { (Invalid pid. See asir.) error } ifelse
     pid 0 get (client) eq { } { (Invalid pid. See asir.) error } ifelse
     asir-comm tag 6 eq {  } { (Invalid argument asir-comm. See asir) error } ifelse

    [ %% Change the current ring if necessary to send a correct OxVlist.
      asir-comm oxasir.changeRing
    ] pop
    %%% Setting OxVlist to tell asir a way to change dist-poly <==> poly.
    (OxVlist=) getVlist2 toString ($) 3 cat_n /comm set
     %% comm message
     pid comm oxsubmit 
     pid (print(OxVlist)$) oxsubmit


     /n asir-comm length def
     n 1 sub -1 1 {
       /i set
       pid asir-comm i get oxsendcmo
       pid 1 oxsendcmo pid (ox_dtop) oxexec
     } for
     pid n 1 sub oxsendcmo
     pid asir-comm 0 get oxexec

     pid 1 oxsendcmo pid (ox_ptod) oxexec
     pid oxpopcmo /arg1 set


  ] pop
  popEnv
  popVariables
  arg1
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Mathematical functions for asir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/oxasir.changeRing {
  /oxasir.changeRing.rr.prev 0 def
  oxasir.changeRing2
} def
/oxasir.changeRing2 {
  /arg1 set
  [/in-oxasir.changeRing2 /f /rr ] pushVariables
  [
     /f arg1 def
     f isArray {
       f {oxasir.changeRing2} map 
     }{
       f isPolynomial {
         f (0). eq { } 
         { f (ring) dc /rr set [(CurrentRingp) rr] system_variable 
           oxasir.changeRing.rr.prev tag 1 eq { }
           {    
              oxasir.changeRing.rr.prev rr eq  {  } 
              {  (asir : arguments must belong to the same ring.) error } ifelse
           } ifelse
           /oxasir.changeRing.rr.prev rr def
         } ifelse
       } {  } ifelse
     } ifelse
  ] pop
  popVariables
} def

/fctr {
  /arg1 set
  [/f /comm /vv] pushVariables
  [(CurrentRingp)] pushEnv
  [
    /f arg1 def
    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse

    f isPolynomial not {
      /vv f 1 get def
      vv isArray { /vv vv from_records  def } {  } ifelse
      /f f 0 get def
      [vv ring_of_polynomials 0] define_ring
      f . /f set
    }{ } ifelse
    oxasir.ccc [(fctr) f] asir /arg1 set
  ] pop
  popEnv
  popVariables
  arg1
} def

[(fctr)
 [(You need to install ox_asir server to use this function. (ox_asir function))
  (f fctr g)
  (poly f; array g;)
  ([f v] fctr g ;  string f, string or array of string v)
  (This function factors the polynomial f over Q.)
  ( )
  (Example 1:  [(x^10-y^10) (x,y)] fctr ::)
  (Example 2:  (x^10-1). fctr ::)
  ( )
  (If you interrupted the computation by typing ctrl-C, type in )
  (   oxasir.ccc oxreset  ; )
  (to interrupt the ox_asir server.)
  (  )
  (This function requires plugins cmo, socket and ox_asir server. cf.oxasir)
]] putUsages


[(primadec)
 [(You need to install ox_asir server to use this function. (ox_asir function))
  ([ ii ] primadec [[q1 p1] [q2 p2] ... ] )
  ( array of poly ii; array of poly q1, p1, q2, p2 ...;)
  ( q1, q2, ... are primary components of the primary ideal decomposition)
  ( of the ideal generated by << ii >>.)
  (  )
  ([ ii v ] primadec [[q1 p1] [q2 p2] ... ] )
  ( array of poly or string ii; array of string v; array of poly q1, p1, q2, p2 ...;)
  (<< v >> is an array of independent variables.)
  (  )
  ([ ii v ] primadec [[q1 p1] [q2 p2] ... ] )
  ( array of poly or string ii; array of string v; array of poly q1, p1, q2, p2 ...;)
  ( v  is a string of variables separated by , )
  (  )
  (Example:  [(x,y) ring_of_polynomials 0] define_ring)
  (          [ [(x^2-1). (x y).] ] primadec pmat ;)
  (  )
  (Example:  [ [(x^2-1) (x y)] [(x) (y)]] primadec pmat ;)
  (  )
  (If you interrupted the computation by typing ctrl-C, type in )
  (   oxasir.ccc oxreset  ; )
  (to interrupt the ox_asir server.)
  (  )
  (This function requires plugins cmo, socket and ox_asir server. cf.oxasir)
]] putUsages

/primadec {
  /arg1 set
  [/in-primadec /aa /f  /comm /vvv /r /setarg] pushVariables
  [(CurrentRingp)] pushEnv
  [
    /aa arg1 def
    aa isArray { } { (<<array>> primadec) error } ifelse
    /setarg 0 def
    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse
    aa { tag } map /typev set
    typev [ ArrayP ] eq
    {  /f aa 0 get def
       f 0 get (ring) dc /r set
       [(CurrentRingp) r] system_variable
       /vvv getVariableNames def
       /setarg 1 def
    } { } ifelse
    typev [ArrayP StringP] eq
    {  /f aa 0 get def
       /vvv [ aa 1 get to_records pop ] def
       /setarg 1 def
    } { } ifelse
    typev [ArrayP ArrayP] eq
    {  /f aa 0 get def
       /vvv aa 1 get {toString} map def
       /setarg 1 def
    } { } ifelse
    setarg { } { (primadec : Argument mismatch) error } ifelse

    f 0 get isPolynomial {
      /r f 0 get (ring) dc def
      /vvv vvv { r __ } map def
    }
    {
      [vvv from_records ring_of_polynomials 0] define_ring
      f { toString . } map /f set
      vvv { . } map /vvv set
    } ifelse
    oxasir.ccc [(primadec) f vvv] asir /arg1 set
  ] pop
  popEnv
  popVariables
  arg1
} def


/getVlist2 {
  [/n  /i ] pushVariables
  [
    /n [(N)] system_variable def
    [
      0 1 n 1 sub { /i set (x) i (dollar) dc 2 cat_n } for
      0 1 n 1 sub { /i set (d) i (dollar) dc 2 cat_n } for
    ] /arg1 set
  ] pop
  popVariables
  arg1
} def

%%%%%%%%%%%%%%%%%%%   
/getVlist {
  [/n  /i ] pushVariables
  [
    /n [(N)] system_variable def
    [
      0 1 n 1 sub { /i set [(x) (var) i] system_variable } for
      0 1 n 1 sub { /i set [(D) (var) i] system_variable } for
    ] /arg1 set
  ] pop
  popVariables
  arg1
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/polygcd {
  /arg1 set
  [/pp /f /g /comm /vv] pushVariables
  [(CurrentRingp)] pushEnv
  [
    /pp arg1 def
    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse

    pp isArray {
      /f pp 0 get def
      /g pp 1 get def 
      pp length 3 eq {
        /vv pp 2 get def
        vv isArray { /vv vv from_records  def } {  } ifelse
        [vv ring_of_polynomials 0] define_ring
        f . /f set
        g . /g set
      } { } ifelse
    }{ (usage: [f g] polygcd) error } ifelse
    oxasir.ccc [(gcd) f g] asir /arg1 set
  ] pop
  popEnv
  popVariables
  arg1
} def
[(polygcd)
 [( [f g] polygcd r )
  ( [f g v] polygcd r)
  (Example: [(x^2-1) (x-1) [(x)]] polygcd )
 ]
] putUsages
/polylcm {
  /arg1 set
  [/pp /f /g /comm /vv] pushVariables
  [(CurrentRingp)] pushEnv
  [
    /pp arg1 def
    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse

    pp isArray {
      /f pp 0 get def
      /g pp 1 get def 
      pp length 3 eq {
        /vv pp 2 get def
        vv isArray { /vv vv from_records  def } {  } ifelse
        [vv ring_of_polynomials 0] define_ring
        f . /f set
        g . /g set
      } { } ifelse
    }{ (usage: [f g] polylcm) error } ifelse
    oxasir.ccc [(lcm) f g] asir /arg1 set
  ] pop
  popEnv
  popVariables
  arg1
} def
[(polylcm)
 [( [f g] polylcm r )
  ( [f g v] polylcm r)
  (Example: [(x^2-1) (x-1) [(x)]] polylcm )
 ]
] putUsages

/asir_red {
  /arg1 set
  [/pp /f /g /rr /vv] pushVariables
  [(CurrentRingp)] pushEnv
  [
    /pp arg1 def
    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse
    {
     pp isRational {
      /f pp numerator def
      /g pp denominator def
      [[f g]] reduceByAsir /rr set
     }{ } ifelse
     exit

     pp isArray {
       /vv pp 2 get def
       /f pp 0 get 0 get def
       /g pp 0 get 1 get def
       [[f toString g toString] vv] reduceByAsir /rr set
     } {  } ifelse
     exit

     (asir_red: not implemented) error exit
    } loop

    rr 1 get isPolynomial {
      rr 0 get rr 1 get div /rr set
    }{ 
      rr 1 get (1).. eq {
         rr 0 get /rr set
      }{
         rr 0 get rr 1 get div /rr set
      } ifelse
    } ifelse

    /arg1 rr def
  ] pop
  popEnv
  popVariables
  arg1
} def
[(asir_red)
 [(Calling the function red of asir. It simplifies a rational function.)
  (cf. cancel)
  (Example:  (x^2). (x). div asir_red )
]] putUsages

/asir_fctr { fctr } def
[(asir_fctr)
 [(Calling the factorizer of asir.)
]] putUsages

/asir_primadec { primadec } def
[(asir_primadec)
 [(Calling the primadec of asir.)
]] putUsages

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[(chattr) 0 /findIntegralRoots] extension pop
/findIntegralRoots {
  /arg1 set 
  [/in-findIntegralRoots /pp ] pushVariables
  [
    /pp arg1 def
    oxasir.ccc [ ] eq {
      (Starting ox_asir server.) message
       ox_asirConnectMethod
    } {  } ifelse
    oxasir.ccc oxIsServerReady
    { pp findIntegralRoots.oxasir /arg1 set}
    { pp findIntegralRoots.slow /arg1 set} ifelse
  ] pop
  popVariables
  arg1
} def

/findIntegralRoots.oxasir {
  /arg1 set
  [/in-findIntegralRoots /f /r /g /aa /rlist] pushVariables
  [(CurrentRingp) (KanGBmessage)] pushEnv
  [
    /f arg1 def
    [(s) ring_of_polynomials 0] define_ring
    f toString . /f set
    f fctr rest /g set
    g { 
         0 get /aa set 
         aa (s). degree 1 eq {
           aa (s). coeff 1 get /aa set
           aa length 1 eq { 0 }
           {  aa 0 get (1). eq {
                 0 << aa 1 get (integer) dc >> sub
              } { } ifelse
           } ifelse
         }{ } ifelse
     } map
    /rlist set
    %% rlist ::
    [-1000000] rlist join shell rest /arg1 set
  ] pop
  popEnv
  popVariables
  arg1
} def

%%%%%%%%%%%%%   From gbhg3/Int/intw.sm1
%% This function needs solv1.asir and ox_asir.
%% See solv1.asir for the usage of this function.
/rationalRoots2 {
  /arg1 set
  [/in-rationalRoots2 /aa /f  /comm /vvv /r /setarg
   /w /ans
  ] pushVariables
  [(CurrentRingp) (KanGBmessage)] pushEnv
  [
    /aa arg1 def
    aa isArray { } { (<<array>> rationalRoots2) error } ifelse
    /setarg 0 def
    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse
    aa { tag } map /typev set
    typev [ArrayP StringP ArrayP] eq
    {  /f aa 0 get def
       /vvv [ aa 1 get to_records pop ] def
       /w aa 2 get def
       /setarg 1 def
    } { } ifelse
    typev [ArrayP ArrayP ArrayP] eq
    {  /f aa 0 get def
       /vvv aa 1 get {toString} map def
       /setarg 1 def
       /w aa 2 get def
    } { } ifelse
    setarg { } { (rationalRoots2 : Argument mismatch) error } ifelse


    [vvv from_records ring_of_polynomials 0] define_ring
    f { toString . } map /f set
    vvv { . } map /vvv set
    w { toString . } map /w set
    
    (rationalRoots2 -- f = ) messagen f messagen 
    ( , vvv= ) messagen vvv messagen ( , w = ) messagen w message

    vvv length 1 eq w 0 get (1). eq and
    {
       [(KanGBmessage) 0] system_variable
       [f] groebner_sugar 0 get /f set
       vvv 0 get toString (s) eq {
       }{ [[vvv 0 get toString (s)] from_records ring_of_polynomials 0] define_ring}
       ifelse
       f 0 get toString . [[vvv 0 get toString . (s).]] replace
       findIntegralRoots /ans set
    }
    {
      oxasir.ccc [(sm1_rationalRoots2) f vvv w] asir 
      {(integer) dc} map
      /ans set
    } ifelse

    /arg1 ans def
  ] pop
  popEnv
  popVariables
  arg1
} def
[(rationalRoots2)
[(rationalRoots2  (ox_asir function) called from intw.sm1 to analyze integral)
 (roots.)
]] putUsages

/ptozp_subst  {
  /arg1 set
  [/in-ptozp_subst /aaa /fff /xxx /vvv /vlist] pushVariables
  [(CurrentRingp)] pushEnv
  [
     /aaa arg1 def
     /fff aaa 0 get def
     /xxx aaa 1 get toString def
     /vvv aaa 2 get {toString ..} map def
     aaa length 4 eq {
       /vlist aaa 3 get def
     } {  
       /vlist 0 def
     } ifelse
     oxasir.ccc [ ] eq {
        (Starting ox_asir server.) message
        ox_asirConnectMethod
     } {  } ifelse
     fff isPolynomial {
       fff (ring) dc ring_def
       fff toString /fff set
     } 
     { vlist isInteger { (ptozp_subst: need variable names.) error } {  } ifelse
       [vlist ring_of_differential_operators 0] define_ring
     } ifelse
     oxasir.ccc [(sm1_ptozp_subst) fff . xxx .  vvv] asir
     /arg1 set
  ] pop
  popEnv
  popVariables
  arg1
} def

[(ptozp_subst)
 [$[f  s  [p q] v] ptozp_subst g   (ox_asir function)$
  $It returns ptozp(subst(f,s,p/q))$
  $Example 1:  [ (x Dx - s) (s) [2 3] (x,s)] ptozp_subst $
  $   ===>     3 x Dx - 2 $
]] putUsages

/reduceByAsir  {
  /arg1 set
  [/in-reduceByAsir /aaa /fff /fff0 /fff1 /vlist] pushVariables
  [(CurrentRingp)] pushEnv
  [
     /aaa arg1 def
     /fff aaa 0 get def
     aaa length 2 eq {
       /vlist aaa 1 get def
     } {  
       /vlist 0 def
     } ifelse
     oxasir.ccc [ ] eq {
        (Starting ox_asir server.) message
        ox_asirConnectMethod
     } {  } ifelse
     fff isArray {
       fff length 2 eq {
         /fff0 fff 0 get def
         /fff1 fff 1 get def
       } {
         ([ << [f g] >> vlist ] reduceByAsir ) error
       } ifelse
     } {
       ([ << [f g] >> vlist ] reduceByAsir ) error
     } ifelse
     fff0 isPolynomial fff1 isPolynomial and {
       fff0 (ring) dc ring_def
       fff0 toString . /fff0 set
       fff1 (ring) dc ring_def
       fff1 toString . /fff1 set
     } 
     { vlist isInteger { (reduceByAsir: need variable names.) error } {  } ifelse
       [vlist ring_of_differential_operators 0] define_ring
       fff0 toString . /fff0 set
       fff1 toString . /fff1 set
     } ifelse
     oxasir.ccc [(sm1_rat2plist2) [fff0 fff1]] asir
     /arg1 set
  ] pop
  popEnv
  popVariables
  arg1
} def

[(reduceByAsir)
[$ [[f g] v] reduceByAsir [ff gg]   (ox_asir function)$
 $ [[f g]] reduceByAsir [ff gg]  $
 $Example 1: [[(2 x -2) (4 x - 8)] (x)] reduceByAsir $
 (Note that there may be a gcd that is more than 1 among the coefficients.)
]] putUsages

%% File should be preprocessed by OpenXM/misc/packages/Windows/oxpp 
%% and ./oxapp --removeSharp 
[(oxasirParseFile)
[$[peer filename] oxasirParseFile $
 $File should be preprocessed by OpenXM/misc/packages/Windows/oxpp$ 
 $and ./oxapp --removeSharp $
]] putUsages

/oxasirParseFile {
  /arg1 set
  [/in-oxasirParseFile /fname /sss] pushVariables
  [
    /fname arg1 1 get def
    /peer  arg1 0 get def 
    fname pushfile /sss set
    peer
    [$if (1) { ; $ sss (}$)] cat
    oxsubmit
  ] pop
  popVariables
} def

[(bfct)
 [
  ( f bfct b )
  ( poly f; poly b)
  ([f v] bfct b)
  ( string f )
  ( b is the global b-function of the polynomial f.)
  (Example: [(x^3-y^2) (x,y)] bfct fctr :: )
  (Algorithm: M.Noro, Mathematical Software, icms 2002, pp.147--157.)
  (  )
  (If you interrupted the computation by typing ctrl-C, type in )
  (   oxasir.ccc oxreset  ; )
  (to interrupt the ox_asir server.)
  (  )
  (This function requires plugins cmo, socket and ox_asir server. cf.oxasir)
  (You need to install ox_asir server to use this function. (ox_asir function))
]] putUsages

/bfct {
  /arg1 set
  [/in-bfct /f /comm /vv] pushVariables
  [(CurrentRingp)] pushEnv
  [
    /f arg1 def
    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse

    f isPolynomial not {
      /vv f 1 get def
      vv isArray { /vv vv from_records  def } {  } ifelse
      /f f 0 get def
      [vv ring_of_polynomials 0] define_ring
      f . /f set
    }{ } ifelse
    oxasir.ccc [(oxasir_bfct) f] asir /f set
    [(s) ring_of_polynomials 0] define_ring
    f . /f set
    [f f fctr] /arg1 set 
  ] pop
  popEnv
  popVariables
  arg1
} def

[(generic_bfct)
 [
  ( [ii weight] generic_bfct b )
  ( list of poly ii; list weight)
  ([ii weight variables] generic_bfct b)
  ( list of string ii; list weight; list variables)
  ( b is the general b-function of the ideal ii w.r.t the weight.)
  (Example: [[(Dx^2) (Dy^2)] [(x) -1 (Dx) 1] [(x) (y)]] generic_bfct :: )
  (Notion: Saito, Sturmfels, Takayama, Grobner deformations of hypergeometric differential equaitons)
  (Algorithm:  M.Noro, Mathematical Software, icms 2002, pp.147--157.)
  (  )
  (If you interrupted the computation by typing ctrl-C, type in )
  (   oxasir.ccc oxreset  ; )
  (to interrupt the ox_asir server.)
  (  )
  (This function requires plugins cmo, socket and ox_asir server. cf.oxasir)
  (You need to install ox_asir server to use this function. (ox_asir function))
]] putUsages

/generic_bfct {
  /arg1 set
  [/in-generic_bfct /aa /f  /comm /vvv0 /n /vvv /ddd /r /setarg 
   /bf /wt ] pushVariables
  [(CurrentRingp)] pushEnv
  [
    /aa arg1 def
    aa isArray { } { (<<array>> generic_bfct) error } ifelse
    /setarg 0 def
    aa { tag } map /typev set
    typev [ ArrayP ArrayP] eq
    {  /f aa 0 get def
       f 0 tag PolyP { } {  (The first argument must be a list of differential operators. Give the third variable: a list of variables) error } ifelse
       f 0 get (ring) dc /r set
       [(CurrentRingp) r] system_variable
       /wt aa 1 get def

       /vvv0 getVariableNames def
       /n [(N)] system_variable def
       /vvv vvv0 n carN rest reverse rest reverse def
       /ddd vvv0 reverse n carN reverse 
                   rest reverse rest reverse def

       /wt wt generic_bfct.aux1 def

       /setarg 1 def
    } { } ifelse
    typev [ArrayP ArrayP StringP] eq
    {  /f aa 0 get def
       /vvv [ aa 2 get to_records pop ] def
       /wt aa 1 get def

       /n vvv length def
       /ddd vvv { (D) 2 1 roll 2 cat_n } map def

       /setarg 1 def
    } { } ifelse
    typev [ArrayP ArrayP ArrayP] eq
    {  /f aa 0 get def
       /vvv aa 2 get {toString} map def
       /wt aa 1 get def
 
       /n vvv length def
       /ddd vvv { (D) 2 1 roll 2 cat_n } map def

       /setarg 1 def
    } { } ifelse
    setarg { } { (generic_bfct : Argument mismatch) error } ifelse

    f 0 get isPolynomial {

    }
    {
      [vvv from_records ring_of_differential_operators 0] define_ring
      f { toString . } map /f set
      vvv { . } map /vvv set
      ddd { . } map /ddd set
      /wt [vvv ddd wt] generic_bfct.aux1 def  
    } ifelse
    [f vvv ddd wt] message

    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse

    oxasir.ccc [(oxasir_generic_bfct) f vvv ddd wt] asir /bf set
    [(s) ring_of_polynomials 0] define_ring
    bf . /bf set
    [bf bf fctr] /arg1 set 
  ] pop
  popEnv
  popVariables
  arg1
} def

/generic_bfct.aux1 {
  /arg1 set
  [/in-generic_bfct.aux1 /ii /jj /wt /wtx /wtd /vv /dd /n]  pushVariables
  [
    arg1 2 get /wt set
    arg1 0 get /vv set
    arg1 1 get /dd set
    /wtx [ 0 1 vv length 1 sub { pop (0).. } for ] def
    /n wt length def
    0 2 n 1 sub {
      /ii set
      0 1 vv length 1 sub {
        /jj set
        wt ii get toString dd jj get toString eq {
          wtx jj << wt ii 1 add get >> put
        } {  } ifelse
      } for 
    } for

    wtx /wt set
    wt { dup tag IntegerP eq { (universalNumber) dc } {    } ifelse } map /wt set
    wt /arg1 set
  ] pop
  popVariables
  arg1 
} def
/verbose.wgr  1 def
%[ ff vv ww ] asir.wgb [gb  init]
/asir.wgr {
  /arg1 set
  [/in-asir.gb  /ff /vv /ww /vvx /vvd /avv /comm /wvec /i] pushVariables
  [
    /ff arg1 0 get def
    /vv arg1 1 get def
    /ww arg1 2 get def

    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse

    vv isArray {
      vv from_records /vv set
    } {  } ifelse
    oxasir.ccc [(dp_gr_print) (2)..] asir
    [vv to_records pop] /vvx set 
    vvx { toString (D) 2 1 roll 2 cat_n  } map /vvd set

    [ 
      0 1 vvx length 1 sub {
        /i set
       vvx i get
       0 ww i get  sub
       vvd i get
       ww i get 
      } for
     ] /wvec set

    [vv ring_of_differential_operators 
     [wvec] weight_vector
    0] define_ring

    ff { toString . dehomogenize homogenize } map /ff set
    vvx { . } map /vvx set %%ex  [x,y] 
    vvd { . } map /vvd set %%ex  [Dx,Dy]
    vvx vvd join [(h).] join /avv set

    verbose.wgr {
    (Asir (-w,w) gb in the Weyl algebra) message
    (wvec=) messagen wvec message
    (ff=) messagen ff message
    (avv=) messagen avv message
    } {  } ifelse

    [$dp_weyl_set_weight(newvect($  ww length toString $,$
     ww toString $));;$ ] cat /comm set

    verbose.wgr {
      comm message
    } { } ifelse

    oxasir.ccc comm oxsubmit ;

    oxasir.ccc [(dp_weyl_gr_main) ff avv (0).. (1).. (11)..] asir
    /arg1 set
  ] pop
  popVariables
  arg1
} def
[(asir.wgr)
[([ ff vv ww ] asir.wgr g)
 $It computes the (-ww,ww) Grobner basis of ff in the homogenized Weyl algebra.$
 (Homogenization is automatically done.)
 $Example 1: $
 $ [ [(x*Dx+y*Dy-1)  (Dx*Dy)] $
 $   (x,y)  $
 $   [1 2 ] ] asir.wgr   $
]] putUsages

/print_tex_form.aux {
  /arg1 set
  [/f /ans] pushVariables
  [
     arg1 /f set
     [(UseDsmall)] system_variable /vv set
     [(UseDsmall) 1] system_variable
     f isArray {
       f { print_tex_form.aux } map /ans set
     }{  
       [$quote($, f toString, $) $] cat /ans set
     } ifelse
    [(UseDsmall) vv] system_variable
     ans /arg1 set
  ] pop
  popVariables
  arg1
} def

/print_tex_form {
  /arg1 set
  [/f /comm /vv] pushVariables
  [(CurrentRingp)] pushEnv
  [
    /f arg1 def
    oxasir.ccc [ ] eq {
       (Starting ox_asir server.) message
        ox_asirConnectMethod
    } {  } ifelse

    oxasir.ccc ( quotetotex_env("conv_rule",7)$ ) oxsubmit 
    oxasir.ccc oxpopcmo ;

    f print_tex_form.aux /f set 
    [$ print_tex_form($,  f $);; $] cat /comm set
    oxasir.ccc comm oxsubmit 
    oxasir.ccc oxpopcmo /arg1 set
  ] pop
  popEnv
  popVariables
  arg1
} def

[(print_tex_form)
[ (obj print_tex_form str)
]] putUsages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% functions to start ox_asir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/asirconnectr {
 [/in-asirconnectr /pass /peer /data /control /oxasir] pushVariables
 [
   [(getServerEnv) (bin/ox_asir)] extension tag 0 eq {
     (Server bin/ox_sm1 is not found.) error
   }{ } ifelse

 /pass ox_encrypt_104_genPass def
 /peer [(oxGetPort) (localhost)] extension def
 /data peer 1 get toString def
 /control peer 3 get toString def
 peer message-quiet
 [
  oxstart100
  @@@.quiet { ( -quiet ) } {  } ifelse
  Xm_noX { ( -nox ) } {  } ifelse
  Xm_engineLogToStdout { ( -nox -engineLogToStdout ) } { } ifelse %bug.onlyForasir
  ( -oxserver bin/ox_asir -e ) ( -reverse )
  ( -data ) data ( -control ) control   pass [1 2] get  
  ( )] cat execve
 [(oxCreateClient2) peer 0 pass 0 get] extension /oxasir.ccc set
                     %% 0 means connect from only localhost. 
 oxasir.ccc asir.init
 /arg1 oxasir.ccc def
 ] pop
 popVariables
 arg1
} def

[(asirconnectr)
 [(asirconnectr server  (ox_asir function))
  (array server;)
  (Example: asirconnectr /oxasir.ccc set)
]] putUsages

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% functions to start ox_k0
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/oxk0.ccc load isArray 
{ }
{ /oxk0.ccc [ ] def } ifelse

/ox.k0.init { 
  % oxk0.ccc ( Print("Hello!"); ) oxsubmit 
  Xm_noX { oxk0.ccc (Xm_noX=true;) oxsubmit }
         { oxk0.ccc (Xm_noX=false;) oxsubmit } ifelse
} def

/k0connectr {
 [/in-k0connectr /pass /peer /data /control ] pushVariables
 [
   [(getServerEnv) (bin/ox_k0)] extension tag 0 eq {
     (Server bin/ox_sm1 is not found.) error
   }{ } ifelse

 /pass ox_encrypt_104_genPass def
 /peer [(oxGetPort) (localhost)] extension def
 /data peer 1 get toString def
 /control peer 3 get toString def
 peer message-quiet
 [
  oxstart100 
  Xm_noX { ( -nox ) } {  } ifelse
  ( -oxserver bin/ox_k0 -e ) ( -reverse )
  ( -data ) data ( -control ) control   pass [1 2] get  
  ( )] cat execve
 [(oxCreateClient2) peer 0 pass 0 get] extension /oxk0.ccc set
                     %% 0 means connect from only localhost. 
 (The server is binded to the variable oxk0.ccc) message-quiet
  ox.k0.init 
  /arg1 oxk0.ccc def
 ] pop
 popVariables
 arg1
} def
/@@@polymake.k0.ccc [ ] def

/ox_server_mode {
  /:: {   } def  % do nothing
} def

%% Encryption methods
/ox_encrypt_104.NONE  0 def
/ox_encrypt_104.FILE  1 def
/ox_encrypt_104.RSA   2 def
/@@@.ox_encrypt_104.method  ox_encrypt_104.NONE  def
/ox_encrypt_104.1 {
  /arg1 set
  [/sss /rrr] pushVariables
  [
    /sss arg1 def
    sss toString /sss set
    { 
      @@@.ox_encrypt_104.method  ox_encrypt_104.NONE  eq {
        /rrr [sss] def
        exit
      } {  } ifelse
      (The encryption method has not yet been implemented.) error
    } loop
    /arg1 rrr def 
  ] pop
  popVariables
  arg1
} def

%<
% Usages: ox_encrypt_104_genPass 
%  [[ c-pass d-pass ] [c-pass-encrypted d-pass-encrypted ox-command-str ] ...]
%>
/ox_encrypt_104_genPass {
  [/sss /p1 /p2 /e1 /e2 /rrr] pushVariables
  [
    /r1 [(oxGenPass)] extension def
    /r2 [(oxGenPass)] extension def
    r1 ox_encrypt_104.1 /e1 set
    r2 ox_encrypt_104.1 /e2 set
    {
      @@@.ox_encrypt_104.method  ox_encrypt_104.NONE  eq {
        [( -passControl ) e1 0 get ( -passData ) e2 0 get ( )] cat /sss set
        [[r1 r2] [e1 0 get , e2 0 get , sss]] /rrr set
        exit
      } { } ifelse
      (The encryption method has not been implemented.) error
    } loop
    rrr /arg1 set
  ] pop
  popVariables
  arg1
} def

[[(lines),[10,-1]],
 [(where),[(shell), (length)]],
 [(reason_of_error), (invalid argument)],
 [(asir_where),[[(toplevel),10],[(string),(foo),3],[(string),(hoge),-1]]
]]
/i1 set
%% /translateErrorForCfep.sampleInput  set

[(translateErrorForCfep)
[
 (translate the error packet defined in ox-rfc-103 into series of commands for cfep.)
]
] putUsages
/translateErrorForCfep {
  /arg1 set
  [/ee /ans /tt /lf /i /nn /ee.orig /tt2] pushVariables
  [
   /ee arg1 def
   {
    ee etag 257 eq {
      ee (body) dc 1 get /ee set  ee /ee.orig set
      ee length 3 gt {
        ee 3 get /ee set
        ee [[(reason_of_error) ee.orig 2 get toString ]] join /ee set
      }{ 
        %% nn should be 2, [serial, common error no, short message]
        ee length /nn set
        nn 0 gt {
          /ee [(reason_of_error) ee nn 1 sub get toString ] def
        } {  /ee [ ] def } ifelse
      } ifelse
    }{ } ifelse
    ee etag 6 eq not { /ans [ ] def exit } { } ifelse
    /ans [ ] def
    /lf 12 (string) dc def  % line feed.
    ans [(Begin) nl lf] join /ans set

    ee (lines) getNode  /tt set
    tt tag 0 eq { 
      ee (parse_error_at) getNode /tt set
    } { } ifelse
    tt isArray {
      tt length 0 gt { 
         ans
         [(gotoLine, ) tt 0 get toString  nl lf] join /ans set
      }{ } ifelse
    } { } ifelse
    tt isInteger {
      [(gotoLine, ) tt toString  nl lf] join /ans set
    } { } ifelse

    ee (where) getNode  /tt set
    tt isArray {
      tt length 0 gt { 
         ans
         [(findAndSelect, ) tt 0 get (string) dc  nl lf] join /ans set
      }{ } ifelse
      1 1, tt length 1 sub {
        /i set
         ans
         [(findAndShow, ) tt i get (string) dc  nl lf] join /ans set
      } for
    } { } ifelse

    ee (reason_of_error) getNode  /tt set
    tt tag 0 eq { 
      ee (reason_of_parse_error) getNode /tt set
    } { } ifelse
    tt tag 0 eq not {
      ans [(printErrorMessage, ) 
           tt (string) dc localizedString  % for translation.
           nl lf] join /ans set
    }{ } ifelse

%% Keyword from asir.  [(asir_where) [[(toplevel),3],[(string),(foo),3],[(filename),(func),4]]]
    ee (asir_where) getNode  /tt set
    tt (toplevel) getNode /tt2 set
    tt2 isInteger, tt2 tag 15 eq, or {
      ans [(gotoLine, ) tt2 toString  nl lf] join /ans set
    } { } ifelse
    tt isArray {
      0 1 tt length 1 sub {
         /i set
        tt i get /tt2 set
        tt2 (string) getNode tag 0 eq { }
        {  
           tt2 length 2 gt {
              tt2 2 get /tt2 set
              tt2 isInteger, tt2 tag 15 eq, or {
                tt2 toString .. /tt2 set
                tt2 (-1).. gt, tt2 (4294967295).. lt, and { 
                  ans [(gotoLine, ) tt2 toString  nl lf] join /ans set
                } { } ifelse
              } { } ifelse
           }{ } ifelse
        } ifelse
      } for 
    }{ } ifelse

    exit
   } loop
   ans [(End) nl lf] join /ans set
   ans cat /arg1 set
  ] pop
  popVariables
  arg1
} def

/oxclearstack {
  /arg1 set
  [/cl /n] pushVariables
  [
    /cl arg1 def 
    cl oxgetsp /n set
    n tag 0 eq { /n 0 def } { } ifelse
    n tag 15 eq { n (integer) dc /n set } { } ifelse
    cl n oxpops 
  ] pop
  popVariables
} def
